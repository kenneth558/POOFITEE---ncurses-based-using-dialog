#! /bin/bash
version="version 0.0.1"
#
# Downloading this script: YOU SHOULDN'T COPY/PASTE BECAUSE THERE ARE ADJACENT SPACES THAT WOULD GET CONSOLIDATED THAT WAY.  Instead, download with raw or download the file
#
# Copyright: see comments below and the notice displayed during runtime for the details
# PROJECT NAME: POOFITEE: "Packet filtering Owner Only access linux Firewall - the system is Invisible To Everyone Else" 
# TODO: Determine why a file named '1' remains in local directory after postfix configure
# TODO: make undo feature in case of merely testing or changes of heart
# TODO: convert to CIDR address consolidation where port and tcp flags for individual addresses would be tracked in a separate file instead of in the iptables rule.
# TODO: accommodate other countries' different date, etc. formatting preferences in log files, directory listings, etc.
# TODO: Firewalling options this install script should be able to alter from the script set defaults:
# TODO: -- Stop probe logging/blacklisting to save resources or if you're just not curious - comment out the crontab entry and kill the process
# TODO: -- Open specific ports to offer public services
# TODO: -- Force single-interface firewalling even though two interfaces exist
# TODO: -- Alter the IP address of the private-side interface from 192.168.3.1
# TODO: -- Dynamic re-config of interfaces: external may swap with internal and private IP on external my become public & vice versa for laptops, etc.  Triggered on whenever change in external interface
# TODO: -- Allow installer to specify which internal interface to trust
# TODO: -- accommodate multiple vlans
# TODO: Testing using DHCP client and server on the private interface
# TODO: WARNING -- NEVER PIPE THE OUTPUT OF 'IPTABLES -L' INTO 'LESS' OR YOU MAY LOSE ENTIRE CHAINS IN IPTABLES!
# TODO: check for sufficient resources prior to executing, like disk space
# TODO: fix postfix log errs about badly named email account if full install doesn't and make more secure with smtp_tls_per_site, 
# TODO:  replace initd with systemd when referencing iptables-persistent and postfix
# TODO: replace iptables with nftables
# TODO: before anything that requires iptables to be persistent is started, make sure iptables is persistently configured
# TODO:  before installing on Raspbian, set up /etc/apt/sources.list with some valid repository like: deb http://mirror.glennmcgurrin.com/raspbian/ jessie main contrib non-free rpi
# installing postfix is different for different distros, may not be "postmap"
# So why anyone would want a blacklist to accumulate:
#  1) differentiate between neutral and hostile when providing public services,
#  2) assist in selecting ports for knock sequence or email knock by which are least probed,
#  3) just to have a blacklist so admin/owner can blacklist their own choices of Internet addresses,
#  4) give to other firewall software in a multi-box environment,
#  5) sales, marketing, winning a bet, or other reasons to prove the point to self or others,
#  6) curiousity
# Why use DROP instead of REJECT:
# -- minimize cost in terms of cpu and interface load.  These costs more often than not correlate, at least indirectly, to a financial cost.
# -- stranger invisbility not only means less cost but fewer hacking options are available to hackers. Security is improved
#  investigate how/if sort and/or uniq commands properly account for all digits in ip v4 address.  Noticed once that some digits/places were getting ignored
# ensure $poofitee_home_dir/email_fetch_parse cannot collect in processes
#
#/etc/postfix/main.cf
#
#. . .
#mailbox_size_limit = 0
#recipient_delimiter = +
#inet_interfaces = all
#. . .
#
#Change the line that reads inet_interfaces = all to inet_interfaces = loopback-only.
# Options:
# Email parser on/off
#  --- email address, password
#  --- command set (suggest default set, allow deletes, adds and mods)
#
# firewall on/off
#   --- check if dual interface, allow select of dual from display of suggested
#   --- determine private IP range, allow for changing
#   --- track first time probers (forms dynamic blacklist or file)
#   ---  build  iptables rules reconstructer shell script
#   ---  suggest starter iptables ruleset scenario, allowing for blacklist or whitelist to have higher pwr
#   ---- get list of alert email destinations with authenticating email addr and pw
#  --- allow option for always-on ports like 80
#  --- don't forget persistence
#
# dhcp notifier on/off
#   ---- get list of alert email destinations with authenticating email addr and pw
# in /var/log/auth.log:
# 12:43:11 firewall systemd-logind[979]: New session 125 of user homeowner.
# 12:43:34 firewall $sudopath: pam_unix($sudopath:auth): authentication failure; logname=homeowner uid=1000 euid=0 tty=/dev/pts/2 ruser=homeowner rhost=  user=homeowner
# 12:43:11 firewall $sudopath: pam_unix($sudopath:auth): conversation failed
# 12:43:11 firewall $sudopath: pam_unix($sudopath:auth): auth could not identify password for [homeowner]
# 12:43:11 firewall $sudopath: homeowner : 1 incorrect password attempt ; TTY=pts/2 ; PWD=/home/homeowner ; USER=root ; COMMAND=/bin/su
# and
#  bad key ssh:
# 12:48:31 firewall sshd[583]: Connection closed by 97.107.199.77 [preauth]
#
# DEVELOP A TAIL GREP ON AUTH.LOG FILE TO INCLUDE THE FOLLOWING _PLUS_ LINES THAT HAVE KNOWN STRINGS "pam_unix(sshd:session): session opened for user " WITHOUT OTHER KNOWN STRINGS (whitelisted user names)
# $greppath -we "failure" -e "failed" -e "not" -e "fail" -e "incorrect" -e "attempt" -e "preauth"
# ($greppath "pam_unix(sshd:session): session opened for user "|$greppath -v " user homeowner") < /var/log/auth.log
# while read line;do echo "$line"|$greppath -we "failure" -e "failed" -e "not" -e "fail" -e "incorrect" -e "attempt" -e "[preauth]";echo "\"$line\""|$greppath "pam_unix(sshd:session): session opened for user "|$greppath -v " user xxxxx";done



# test emailing while setting up
#
# remind about ssh keys

# set up port knocking
#  ---- normal port knocking
#   ---- port knocking with lookup table
#   ---- port knock to fetch remote controlling email
#
#  accommodate reconfiguration of already installed system
#
#    Arrangement for your freedom from copyright display obligation: Prior to
#  distribution, email me the author: kenlovesjesus at gmail dot com to arrange USD payment.
#  You'll insert name and details of party responsible for making the payment to the
#  author into comments in the script's sourcecode.  I, the author, will only give
#  you permission to free yourself from copyright display obligation in writing addressed
#  directly to the party making payment to me after you have made contact with me.
#  End of copyright message
#
#
# POOFITEE firewall install helper script layout
#
#####################          iptables-persistent               ##################
#    copy the init.d script iptables-persistent to /etc/init.d/ and make it executable
#    copy iptables-persistent.conf to /etc/default/iptables-persistent.conf and edit it to suit your needs
#    copy rules to /etc/iptables/rules and edit it to suit your needs
#    copy ipv6_rules to /etc/iptables/ipv6_rules and edit it to suit your needs (you can copy this file even if you don’t activate IPv6 support in the configuration, it will be ignored)
#    make iptables-persistent to be lauched at startup
#    update-rc.d iptables-persistent defaults
#
#Configuration variables
#
#Edit /etc/default/iptables-persistent.conf to set the following parameters:
#
#SAVE_NEW_RULES (default: 0) – if set different than 0 then the current iptables ruleset will be saved with iptables-save when iptables-persistent is stopped (or restarted)
#
#MODULES (default: “”) – a space-separated list of the modules that iptables-persistent should load/unload. Useful to activate FTP connection tracking for example.
#
#IPV6 (default: 0) – if set different than 0 it will additionnaly use ip6tables to handle the loading/unloading of the ruleset stored at /etc/iptables/ipv6_rules
#
#ENABLE_ROUTING (default: 0) – if set different than 0 then routing is enabled (in /proc/sys/net/ipv4/ip_forward and /proc/sys/net/ipv6/conf/all/forwarding), otherwise it’s not.
#
################  FUNCTIONS FIRST, THEN MAIN:
create_tmp_timeouttry_script () {
(cat <<EOF1
#!/bin/bash
lineshere="\$($greppath -E --line-number "^:$" < \$0)"
(cat << EOF
#!/bin/bash
$headpath -n "\${lineshere%::*}" \$0 > \$0.bak
mv \$0.bak \$0
chmod 777 \$0
EOF
) > /tmp/fifos_and_temp_files_for_poofitee_installer/cleanup.sh
chmod 777 /tmp/fifos_and_temp_files_for_poofitee_installer/cleanup.sh
/tmp/fifos_and_temp_files_for_poofitee_installer/cleanup.sh
# read -s -n 1 -p "press a key before while..."
while getopts "t:" opt; do
# read -s -n 1 -p "press a key in while before case..."
  case "\$opt" in
      t) timeout=\$OPTARG;shift \$((OPTIND-1)) ;;
  esac
#  read -s -n 1 -p "press a key in while after case..."
done
# read -s -n 1 -p "press a key after both while and case..."

start_watchdog(){
  timeout="\$1"
  (( i = timeout ))
  while (( i > 0 ))
  do
      kill -0 \$\$ || exit 0
      sleep 1
      (( i -= 1 ))
  done

  # echo "killing process after timeout of \$timeout seconds"
  kill \$\$
}

start_watchdog "\$timeout" 2>/dev/null &
echo "\$@" >> "\$0"
:

EOF1
) > "/tmp/fifos_and_temp_files_for_poofitee_installer/timeouttry.sh"
chmod 700 "/tmp/fifos_and_temp_files_for_poofitee_installer/timeouttry.sh"
}
ensure_connection () {
          while ! [[ "$(ping -c1 opendns.com &>/dev/null;echo "$?")" == "0" ]];do
               printf "\r\033[KNo internet connection found with full DNS.  Press a key when corrected or to ignore...";read -rsn 1;read -rst 0.001 -n3
               break
          done
}
test_this_awk () {
    ! [[ -f  "${awkspaths[$awks_index]}" ]] && return 1
    echo "" > /tmp/fifos_and_temp_files_for_poofitee_installer/awktestbed
    echo "" > /tmp/fifos_and_temp_files_for_poofitee_installer/awktestresults # This line might be optional depending on whether next line does this rain or shine
    $tailpath -fn0 /tmp/fifos_and_temp_files_for_poofitee_installer/awktestbed 2>/dev/null|$stdbufpath -o0 "${awkspaths[$awks_index]}" '{print $1}' > /tmp/fifos_and_temp_files_for_poofitee_installer/awktestresults 2>/dev/null &
    awktestpid="$!"
    tailawktestpid="$($pspath aux|$greppath -v grep|$greppath "$tailpath -fn0 /tmp/fifos_and_temp_files_for_poofitee_installer/awktestbed"|"$awkpath" '{print $2}')"
    sleep 1
    echo "testline" >> /tmp/fifos_and_temp_files_for_poofitee_installer/awktestbed
    sleep 1
    kill $awktestpid &>/dev/null
    kill $tailawktestpid &>/dev/null
    if [[ "$($tailpath -n1 /tmp/fifos_and_temp_files_for_poofitee_installer/awktestresults)" =~ testline ]];then
        return 0
    else
        return 1
    fi
}  2>/dev/null #redirection needed because in our development environment mawk breaks pipe and spews out an error
set_awks_paths () {
for awks_index_set in "${!awks[@]}";do
    [[ "${awks_installed_states[$awks_index_set]}" == succeeded ]] && return 2
    awk_path_tmp="$($whereispath $binaryflag ${awks[$awks_index_set]})"
    awk_path_tmp="${awk_path_tmp#*:}"
    awk_path_tmp="${awk_path_tmp#* }"
    awkspaths[$awks_index_set]="${awk_path_tmp%% *}"
    if [[ "$1" == "label_olds" ]];then
        ! [[ -z "${awkspaths[$awks_index_set]}" ]] && awks_installed_states[$awks_index_set]=old || awks_installed_states[$awks_index_set]=not
    fi
done
}
install_or_upgrade_then_test_this_awktype () {
    printf "Installing ${awks[$awks_index]}\n"
    while true;do ps a|$greppath -v grep|$greppath preconfigure &>/dev/null || printf ".";sleep 1;done &
    progress_dots="$!"
    eval "$xargspath -a <(printf "${awks[$awks_index]}") -r -- $sudopath $installerpath" &>/dev/null
    install_result="$?"
    kill $progress_dots; trap 'kill $progress_dots' SIGTERM
    if [[ "$install_result" == "0" ]];then
        set_awks_paths
        if [[ $(test_this_awk;echo "$?") == "0" ]];then
            return 0
        else
            printf "${awks[$awks_index]} installed but failed to work with tail -f command\n"
        fi
    else
        printf "${awks[$awks_index]} failed to install\n"
    fi
    return 1
}

what_needs_to_be_installed () {
[[ -z "$inotifywaitpath" ]] && inotifywaitpath=$($whereispath $binaryflag inotifywait);inotifywaitpath="${inotifywaitpath#*:}";inotifywaitpath="${inotifywaitpath# }";inotifywaitpath="${inotifywaitpath%% *}"
[[ -z "$iptablespath" ]] && iptablespath=$($whereispath $binaryflag iptables);iptablespath="${iptablespath#*:}";iptablespath="${iptablespath# }";iptablespath="${iptablespath%% *}"
[[ -z "$stdbufpath" ]] && stdbufpath=$($whereispath $binaryflag stdbuf);stdbufpath="${stdbufpath#*:}";stdbufpath="${stdbufpath# }";stdbufpath="${stdbufpath%% *}"
[[ -z "$crontabpath" ]] && crontabpath=$($whereispath $binaryflag crontab);crontabpath="${crontabpath#*:}";crontabpath="${crontabpath# }";crontabpath="${crontabpath%% *}"
[[ -z "$timeoutpath" ]] && timeoutpath=$($whereispath $binaryflag timeout);timeoutpath="${timeoutpath#*:}";timeoutpath="${timeoutpath# }";timeoutpath="${timeoutpath%% *}"
[[ -z "$sleeppath" ]] && sleeppath=$($whereispath $binaryflag sleep);sleeppath="${sleeppath#*:}";sleeppath="${sleeppath# }";sleeppath="${sleeppath%% *}"
[[ -z "$ifdownpath" ]] && ifdownpath=$($whereispath $binaryflag ifdown);ifdownpath="${ifdownpath#*:}";ifdownpath="${ifdownpath# }";ifdownpath="${ifdownpath%% *}"
[[ -z "$ifuppath" ]] && ifuppath=$($whereispath $binaryflag ifup);ifuppath="${ifuppath#*:}";ifuppath="${ifuppath# }";ifuppath="${ifuppath%% *}"
[[ -z "$datepath" ]] && datepath=$($whereispath $binaryflag date);datepath="${datepath#*:}";datepath="${datepath# }";datepath="${datepath%% *}"
[[ -z "$bashpath" ]] && bashpath=$($whereispath $binaryflag bash);bashpath="${bashpath#*:}";bashpath="${bashpath# }";bashpath="${bashpath%% *}"
[[ -z "$bcpath" ]] && bcpath=$($whereispath $binaryflag bc);bcpath="${bcpath#*:}";bcpath="${bcpath# }";bcpath="${bcpath%% *}"
[[ -z "$wcpath" ]] && wcpath=$($whereispath $binaryflag wc);wcpath="${wcpath#*:}";wcpath="${wcpath# }";wcpath="${wcpath%% *}"
[[ -z "$freepath" ]] && freepath=$($whereispath $binaryflag free);freepath="${freepath#*:}";freepath="${freepath# }";freepath="${freepath%% *}"
[[ -z "$atpath" ]] && atpath=$($whereispath $binaryflag at);atpath="${atpath#*:}";atpath="${atpath# }";atpath="${atpath%% *}";! [[ "${atpath: -2:2}" == "at" ]] && atpath=""
[[ -z "$ipsetpath" ]] && ipsetpath=$($whereispath $binaryflag ipset);ipsetpath="${ipsetpath#*:}";ipsetpath="${ipsetpath# }";ipsetpath="${ipsetpath%% *}"
[[ -z "$visudopath" ]] && visudopath=$($whereispath $binaryflag visudo);visudopath="${visudopath#*:}";visudopath="${visudopath# }";visudopath="${visudopath%% *}"
[[ -z "$nicepath" ]] && nicepath=$($whereispath $binaryflag nice);nicepath="${nicepath#*:}";nicepath="${nicepath# }";nicepath="${nicepath%% *}"
[[ -z "$netfiltperspath" ]] && netfiltperspath=$($whereispath $binaryflag netfilter-persistent);netfiltperspath="${netfiltperspath#*:}";netfiltperspath="${netfiltperspath# }";netfiltperspath="${netfiltperspath%% *}"
# [[ -d "/usr/share/netfilter-persistent/plugins.d" ]] && netfiltperspath=$($whereispath $binaryflag netfilter-persistent);netfiltperspath="${netfiltperspath#*:}";netfiltperspath="${netfiltperspath# }";netfiltperspath="${netfiltperspath%% *}"
[[ -z "$mailpath" ]] && mailpath=$($whereispath $binaryflag mail);mailpath="${mailpath#*:}"
[[ -z "$mailpath" ]] && mailpath=" $($whereispath $binaryflag mailx)";mailpath="${mailpath#*:}"
[[ -z "$mailpath" ]] && mailpath=" $($whereispath $binaryflag sendmail)";mailpath="${mailpath#*:}"
mailpath="${mailpath# }";mailpath="${mailpath%% *}";mailpath="${mailpath%%.*}" # note the unique filter here!!!!!!!!!!!!!!!!!!!!!!!!
[[ -z "$postmappath" ]] && postmappath=$($whereispath $binaryflag postmap);postmappath="${postmappath#*:}";postmappath="${postmappath# }";postmappath="${postmappath%% *}"
[[ -z "$postqueuepath" ]] && postqueuepath=$($whereispath $binaryflag postqueue);postqueuepath="${postqueuepath#*:}";postqueuepath="${postqueuepath# }";postqueuepath="${postqueuepath%% *}"c
if [[ "$1" == "checkawk" ]];then
    awks=(awk gawk mawk nawk)
    for function_state in "" oldtested upgrade;do
        set_awks_paths $([[ -z "$function_state" ]] && printf "label_olds")
        [[ $(($?)) == 2 ]] && break
        for awks_index in "${!awks[@]}";do
            case $function_state in
            "")
                ! [[ "${awks_installed_states[$awks_index]}" == "old" ]] && continue
                if [[ $(test_this_awk;echo "$?") == "0" ]];then
                    awkpath="${awkspaths[$awks_index]}"
                    break 2
                else
                    awks_installed_states[$awks_index]="oldtoupgrade"
                fi
            ;;
            oldtested)
                ! [[ "${awks_installed_states[$awks_index]}" == "not" ]] && continue
            ;;&
            upgrade)
                ! [[ "${awks_installed_states[$awks_index]}" == "oldtoupgrade" ]] && continue
            ;;&
            oldtested|upgrade)
                [[ $(install_or_upgrade_then_test_this_awktype;echo "$?") == "0" ]] && awkpath="${awkspaths[$awks_index]}" && break 2
                awks_installed_states[$awks_index]=failed
            ;;
            esac
        done
    done
    if [[ "${awks_installed_states[$awks_index]}" == "failed" ]];then
        cat <<-EOF
		WARNING:
		One or more features that you selected will require another version of awk than
		this system has currently - the version of $awkpath
		on this system does not receive input via the stdbuf command like it will need 
		to.  This is a common deficiency with some versions of awk.  This install script
		is not advanced enough to locate the right version of awk to install for you.  
		The best fix for this condition is that you manually upgrade awk, mawk, or gawk, 
		verifying that the new version succeeds with the code snippet below, then 
		restart this poofitee installer again.  If you decide to keep your current
		version[s] of awk/gawk and install a separate version for poofitee only so that
		none of your other scripts run the new awk version that poofitee needs, restart 
		this installer script with the command line argument added as follows:

		poofitee awk=/substitute_real_path_here/substitute_gawk_mawk_awk_etc_here

		You may use another terminal window to upgrade awk and resume in this one to see
		if this script discovers the new awk version.  Code snippet will now follow,
		adjust the awk name to what you install:
		EOF
        press_a_key
        cat <<-EOF
		Here is the test code snippet that awk, mawk, or gawk needs to succeed with:

		echo "" > /tmp/fifos_and_temp_files_for_poofitee_installer/awktestbed
		$tailpath -fn0 /tmp/fifos_and_temp_files_for_poofitee_installer/awktestbed 2>/dev/null|$stdbufpath -o0 awk '{print \$1}' > /tmp/fifos_and_temp_files_for_poofitee_installer/awktestresults 2>/dev/null &
		awktestpid="\$!"
		tailawktestpid="\$($pspath aux|$greppath -v grep|$greppath "$tailpath -fn0 /tmp/fifos_and_temp_files_for_poofitee_installer/awktestbed"|$awkpath '{print \$2}')"
		echo "testline" >> /tmp/fifos_and_temp_files_for_poofitee_installer/awktestbed
		sleep 1
		kill \$awktestpid &>/dev/null
		kill \$tailawktestpid &>/dev/null
		if [[ -z "\$(cat /tmp/fifos_and_temp_files_for_poofitee_installer/awktestresults)" ]];then printf "\\nThis awk version fails\\n";else printf "\\nThis awk version succeeds\\n";echo;fi
		EOF
        press_a_key
    fi
fi
notinstalled=""
if [[ $answer =~ f ]];then
     set_notinstalled_var # during development, just install everything
fi
if [[ $answer =~ e ]];then
     set_notinstalled_var # during development, just install everything
fi
if [[ $answer =~ d ]];then
     set_notinstalled_var # during development, just install everything
fi
if [[ $answer =~ p ]];then
     set_notinstalled_var # during development, just install everything
fi
pronotinstalled="$(printf "$notinstalled"|$sortpath|$uniqpath)\n"
# packages are in alpha order so duplicates got removed, now we need to rearrange to workable order
# packages that need to be tried once and changed go first, then awk/gawk/mawk/nawk, example shown commented below, but awk is dealt with elsewhere instead of here
# netfilter-persistent first, then crontab, then awk/gawk/mawk/nawk for example
printf "$pronotinstalled"|while read package;do [[ "$package" == "netfilter-persistent" ]] && echo "$package" > /tmp/fifos_and_temp_files_for_poofitee_installer/notinstalled;done
printf "$pronotinstalled"|while read package;do [[ "$package" != "netfilter-persistent" ]] && [[ "$package" == "cronie" ]] && echo "$package" > /tmp/fifos_and_temp_files_for_poofitee_installer/notinstalled;done
# printf "$pronotinstalled"|while read package;do [[ "$package" != "netfilter-persistent" ]] && [[ "$package" != "cronie" ]] && [[ "$package" =~ ^gawk$|^mawk$|^nawk$ ]] && echo "$package" >> /tmp/fifos_and_temp_files_for_poofitee_installer/notinstalled;done
# printf "$pronotinstalled"|while read package;do [[ "$package" != "netfilter-persistent" ]] && [[ "$package" != "cronie" ]] && ! [[ "$package" =~ ^gawk$|^mawk$|^nawk$ ]] && echo "$package" >> /tmp/fifos_and_temp_files_for_poofitee_installer/notinstalled;done
printf "$pronotinstalled"|while read package;do [[ "$package" != "netfilter-persistent" ]] && [[ "$package" != "cronie" ]] && echo "$package" > /tmp/fifos_and_temp_files_for_poofitee_installer/notinstalled;done
notinstalled=$(cat /tmp/fifos_and_temp_files_for_poofitee_installer/notinstalled)
notinstalled+="\n"
rm /tmp/fifos_and_temp_files_for_poofitee_installer/notinstalled
not_installed_single_line="$(printf "$notinstalled"|$awkpath '{gsub("\\n"," ");printf $0" "}')"
not_installed_single_line="${not_installed_single_line:: -1}"
[ -z "$not_installed_single_line" ] && return 0
return "$(printf "$notinstalled"|$wcpath -l)"
}
sendmail_works_or_not () {
sendmail_works=""
if ! [[ -z $mailpath ]];then
     mailadd=""
     mailcmd="echo $0 \"test at $($datepath).  Press y\"|$mailpath"
     if [[ -f "$poofitee_home_dir/toemailadds" ]];then
           adds=$(cat "$poofitee_home_dir/toemailadds")
     elif [[ -f "./toemailadds" ]];then
           adds=$(cat "./toemailadds")
     fi

     cat <<-EOF

			One aspect of an option you selected will be to send you alert notices to your
			email account.  For emailing alerts to you, specialized configuration is
			required so this computer can send emails from the command line.  We'll send a
			test email now to see if it can send from the command line already if you'll
			please enter an email address to which a subsequent mail command will send a
			test email.

			For this test, provide an email address here that you can immediately receive
			a test email through and verify reception of it, possibly on a different
			computing device.

			$(! [[ -z "$adds" ]] && printf "Optionally select, modify, or enter new, then e" || printf "E")nter that email address: 
	EOF
	newemailconfigwarning="Installing a new configuration is definitely NOT what you want\
\nif this computer is already or will be in use in a business email service role,\
\nlike MTA, MDA, email relay, or email server because the settings that this\
\ninstallation script will change will most certainly be incompatible with said\
\nrole.  If you need to avoid installing the emailing configuration, you should\
\nmanually get the email sending to function via the command line  to work with\
\nwhichever mail command is shown above, \"mail\", \"mailx\", or \"sendmail\", that this\
\nscripting has found to currently exist on your system."
     until false;do
          ! [[ -z "$mailadd" ]] && printf "That doesn't appear to be a valid email address.  Try again or remove it to skip\
\nthis test and install a full, new configuration on this computer\
\nfor sending emails from the command line.  $newemailconfigwarning"
          echo
          get_sendto_emailadds onlyneed1 optional
          if [[ -z "$mailadd" ]]; then break;fi
          read -eri "$mailadd" -p "$mailcmd " mailadd
          if ! [[ "$mailadd" =~ ^(([-a-zA-Z0-9\!#\$%\&\'*+/=?^_\`{\|}~]+|(\"([][,:;<>\&@a-zA-Z0-9\!#\$%\&\'*+/=?^_\`{\|}~-]|(\\\\[\\ \"]))+\"))\.)*([-a-zA-Z0-9\!#\$%\&\'*+/=?^_\`{\|}~]+|(\"([][,:;<>\&@a-zA-Z0-9\!#\$%\&\'*+/=?^_\`{\|}~-]|(\\\\[\\ \"]))+\"))+@[A-Za-z0-9.-]+\.[A-Za-z]{2,4}$ ]];then
               continue
          fi
          if ! [[ -z "$mailadd" ]];then
               printf "Sending a test email to $mailadd..."
               eval "$timeoutpath 10 $mailcmd $mailadd &>/dev/null"
               if [[ "$?" == "0" ]];then
                    printf "\n\nDid the test email get sent and received? y/n/t/a (Yes, No, or Try Again): "
                    read -r -n1
                    if [[ $REPLY =~ y ]];then 
                          sendmail_works="sendmail_works"
                          echo
                          break
                    elif [[ $REPLY =~ [at] ]];then
                         continue
                    fi
               fi
               printf "\n\nBased on your answer, a full, new email sending configuration will be set up on\
\nthis computer.  $newemailconfigwarning"
               printf "\n\nIf you are unsure this is what you want, press ctrl-c before continuing\n"
               press_a_key
               echo
               break
          fi
     done
fi
}
install_openall () {
(cat <<EOF
#!/bin/bash
#This script will add or remove to iptables (IPv4) poofitee_whitelist set
# It is referenced by email_fetch_parse and by process_logfile_line; can also be launched manually if given an ip address
#This test will allow CIDR-type consolidated IPv4 address ranges
if ! [[ \$1 =~ ^((1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\.){3}(1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])((/[0-2]?[0-9])|(/3[0-2]))?$ ]]; then
    echo "This script requires a valid IP address besides the script name" >> "\$0.log";
    exit;
fi
email_subjectline_front="Poofitee "
recipient_list="\$(cat "\$poofitee_home_dir/toemailadds")"
if ! [ "\$2x" == "-rx" ];then
      if ! ($sudopath $ipsetpath add poofitee_whitelist \$1 comment "\$($datepath) \$2 \$3" 2>"$poofitee_home_dir/ramdisk/returerr"); then
          if [[ "\$(cat "$poofitee_home_dir/ramdisk/returerr" )" =~ is\ full ]];then # send the email notice out FIRST
               echo "Increasing the size of the whitelist. Verify continued server operation NOW"|$mailpath -s "\$email_subjectline_front" "\$recipient_list"
               $sudopath $ipsetpath create poofitee_whitelisttmp hash:ip comment maxelem \$($sudopath $ipsetpath list -t|$greppath -iA 3 "^name: poofitee_whitelist"|$tailpath -n1|$awkpath '{printf \$7+65536}')
               $sudopath $ipsetpath list poofitee_whitelist|$tailpath -n+8|while read ipadd comment;do
                   $sudopath $ipsetpath add poofitee_whitelisttmp "\$ipadd \$comment"
               done
               $sudopath $ipsetpath w poofitee_whitelist whitelisttmp && $sudopath $ipsetpath x poofitee_whitelisttmp
          fi
          rm "$poofitee_home_dir/ramdisk/returerr"
     fi

else
      $sudopath $ipsetpath del poofitee_whitelist \$1 2>/dev/null
fi
# This next statement will fail if netfilter-persistent package was not available for this distro.  Poofitee was designed
# to need it because it utilizes /usr/share/netfilter-persistent/plugins.d/ for allowing saves of both iptables and ipset
# with a single call which iptables-persistent alone does not allow.
#  You're on your own if you choose to depend on some other iptables + $ipsetpath persistence technique.
# If you come up with something that works well for you, please share it on the POOFITEE wiki forum
$sudopath \$([[ -z "$iptabsavepath" ]] && printf "$netfiltperspath save" || printf "$iptabsavepath") >/dev/null  || $sudopath $ipsetpath save > /etc/iptables/ipset.sets
exit

EOF
) > "$poofitee_home_dir/openall.sh"
chown poofitee "$poofitee_home_dir/openall.sh"
chmod 700 "$poofitee_home_dir/openall.sh"
printf "\nCreated whitelisting script\n"
}
firewall_external_interface_not_in_privateIP_ranges () {
localresult=""
IFS=. read -r -a octets <<< "$($ippath -o route get 8.8.8.8|$awkpath '{for (i=1;i<NF;i++){if ($i=="src"){print $(i+1);exit}}}')"
if [[ "${octets[0]}" != "10" ]];then
     localresult+="1"
fi
if [[ "${octets[0]}" != "172" ]] || [[ $((${octets[1]})) -lt 16 ]] || [[ $((${octets[1]})) -ge 32 ]];then
     localresult+="2"
fi
if [[ "${octets[0]}" != "192" ]] || [[ "${octets[1]}" != "168" ]];then
     localresult+="3"
fi
return $((localresult))
}
adjust_for_private_ip () {
$ipsetpath del poofitee_bogons,privateIPs_cidr  10.0.0.0/8 &>/dev/null
$ipsetpath del poofitee_bogons,privateIPs_cidr  172.16.0.0/12 &>/dev/null
$ipsetpath del poofitee_bogons,privateIPs_cidr 192.168.0.0/16 &>/dev/null
$ipsetpath add poofitee_static_trusted_cidr 10.0.0.0/8 &>/dev/null
$ipsetpath add poofitee_static_trusted_cidr 172.16.0.0/12 &>/dev/null
$ipsetpath add poofitee_static_trusted_cidr 192.168.0.0/16 &>/dev/null
if [[ firewall_external_interface_not_in_privateIP_ranges =~ 1 ]];then
     $ipsetpath add poofitee_bogons,privateIPs_cidr  10.0.0.0/8 &>/dev/null
     $ipsetpath del poofitee_static_trusted_cidr  10.0.0.0/8 &>/dev/null
fi
if [[ firewall_external_interface_not_in_privateIP_ranges =~ 2 ]];then
     $ipsetpath add poofitee_bogons,privateIPs_cidr  172.16.0.0/12 &>/dev/null
     $ipsetpath del poofitee_static_trusted_cidr  172.16.0.0/12 &>/dev/null
fi
if [[ firewall_external_interface_not_in_privateIP_ranges =~ 3 ]];then
     $ipsetpath add poofitee_bogons,privateIPs_cidr 192.168.0.0/16 &>/dev/null
     $ipsetpath del poofitee_static_trusted_cidr  192.168.0.0/16 &>/dev/null
fi
$greppath -i DHCPACK < /var/log/syslog|$awkpath '{for (i=1;i<NF;i++){if ($i=="from"){print $(i+1);next}}}'|$sortpath -V|$uniqpath|while read ipaddr;do $ipsetpath add poofitee_static_trusted $ipaddr comment "needed to acquire address via DHCP" &>/dev/null;done
}
advise_to_verify_persistency () {

# /usr/share/netfilter-persistent/plugins.d/14-poofitee-ip4tables
# $([[ -z "$iptabsavepath" ]] && printf "$netfiltperspath save" || printf "$iptabsavepath") >/dev/null  || $ipsetpath save > /etc/iptables/ipset.sets

showthis "\
<center>I AM FINISHED, BUT YOU ARE NOT.\
\n\n\
The present state and direction of the packet filtering packages providing \
persistency are inconsistent between distros and fluid, and thus are not \
predictable for the purposes of writing this installer.  PLEASE exercise \
due diligence in taking care of that aspect of \
this installation:\
\n\n\
You must next twice or thrice verify persistence...that is, functionality after reboots.  Especially \
check for iptables black and whitelist rules in $ipsetpath being persistent.  At a \
minimum, ipset and iptables rulesets both need to be made persistent by you.\
\n\n\
Note: if you need the pseudo-application layer firewalling, you'll next need to \
code the \"process_logfile_line\" script to your needs.  Then modify the iptables \
ruleset to log the packets with the log- prefix text that will trigger your \
script coding.  The expected technique is to echo the blacklisting command into \
'at now+min', delaying it enough minutes to allow log file entries to manifest.  \
The command scheduled with 'at' could include some type of log file coordination \
before blacklisting.  Don't forget to verify persistency afterwards.\
\n\n\
Thank you for using POOFITEE.  God loves you, pass it on.\
\n\n\
<center>The POOFITEE development team, Kenneth L. Anderson, lead developer" msgbox \
"IMPORTANT MESSAGE" "$globalbacktitle"
}
set_notinstalled_var () {
[[ -z "$inotifywaitpath" ]] && notinstalled+="inotify-tools\n"
[[ -z "$iptablespath" ]] && notinstalled+="iptables\n"
[[ -z "$netfiltperspath" ]] && notinstalled+="netfilter-persistent\n"
[[ -z "$stdbufpath" ]] && notinstalled+="coreutils\n"
[[ -z "$mailpath" ]] && notinstalled+="mailutils\n"
[[ -z "$crontabpath" ]] && notinstalled+="bcron\ncronie\n"
[[ -z "$datepath" ]] && notinstalled+="coreutils\n"
[[ -z "$bcpath" ]] && notinstalled+="bc\n"
[[ -z "$atpath" ]] && notinstalled+="at\n"
[[ -z "$nicepath" ]] && notinstalled+="coreutils\n"
[[ -z "$sendmail_works" ]] && [[ -z $postmappath ]] && notinstalled+="postmap\npostfix\n"
[[ -z "$ipsetpath" ]] && notinstalled+="ipset\n"
}
install_firewall_cronentries () {
#  Only need to confirm if there are entries in crontab
printf "."
date_for_cronentries_backup="poofitee_installer_$($datepath)"
printf "."
$crontabpath -u poofitee -l 2>/dev/null> "$poofitee_home_dir/cronentries.$date_for_cronentries_backup"
printf "."
# the next few lines not executed for when user poofitree is newly created this run
if [[ -z "$user_poofitee_created_this_run" ]];then
     if ! [[ $(($(echo "$?"))) -eq 0 ]] || ! [[ $(($(wc -l < "$poofitee_home_dir/cronentries.$date_for_cronentries_backup"))) -gt 0 ]];then
          printf "\n\nPOOFITEE's cron file isn't being saved right to\
\n$poofitee_home_dir/cronentries, or else it is totally void of entries.\
\nIf you are certain it is rightfully empty, press 'p' to proceed anyway,\
\notherwise press ctrl-c and troubleshoot the problem...\n"
          read -rsn1;read -rsn3 -t 0.001 discard
          ! [[ $REPLY =~ [Pp] ]] && return 1
     fi
fi
! [[ $($crontabpath -u poofitee -l 2>/dev/null|$greppath -E -v ^#|$greppath -v ^[[:space:]]*$|$wcpath -l) == "0" ]] && \
(printf "\n$($crontabpath -u poofitee -l 2>/dev/null|$greppath -E -v ^#|$greppath -v ^[[:space:]]*$|$wcpath -l) entries in crontab:\n\n$($crontabpath -u poofitee -l|$greppath -E -v ^#|$greppath -v ^[[:space:]]*$)\
\n\nConfirm you understand that the shell in POOFITEE's crontab is now getting\
\nchanged which might affect the above entries if they send values out, contain\
\nquotes, etc.\n"
read -n1 -s -p "You will need to verify proper operation of current entries after this.")
# NOTE -- BECAUSE OF THE COMPLEX QUOTING IN THE CRONTAB @REBOOT LINE BELOW, WE OPTED FOR READABILITY IN THIS SCRIPT AND DID NOT CREATE A VARIABLE WITH THAT AS ITS CONTENTS EVEN THOUGH IT IS ALSO NEEDED BY THE install_tail_f_lines_and_receiving_script FUNCTION
(cat << CRONTAB_ENTRIES_END
$($crontabpath -u poofitee -l 2>/dev/null|$greppath -v poofitee_fw|$greppath -v "tail -F -n 0 /var/log/kern.log"|$greppath -v "tail -F -n 0 /var/log/auth.log")

# lines below are from poofitee_fw
@reboot $sudopath $nicepath -n-15 $sudopath $tailpath -F -n 0 /var/log/kern.log|$greppath --line-buffer ' SRC='|$greppath --line-buffer -vE 'SRC=0\.0\.0\.0|SRC=127\.0\.0\.1|SRC=10\.|SRC=172\.1[6-9]\.|SRC=172\.2.\.|SRC=172\.3[01]\.|SRC=192\.168\.'|$stdbufpath -o0 $awkpath '{for (i=6;i<=NF;i++) {if (\$i ~ "^SRC=") {{gsub("SRC=","",\$i); printf \$i" \\""} printf "kern.log "\$1" "\$2" "\$3; for (j=i;j<=NF;j++) {if (\$j ~ "^PROTO=" || \$j ~ "^SPT=" || \$j ~ "^DPT"  || ((\$j ~ "^URGP") && (\$j !~ "^URGP=0$")) || \$j ~ "^SYN$" || \$j ~ "^ACK$" || \$j ~ "^FIN$" || \$j ~ "^PSH$" || \$j ~ "^RST$") {printf " "\$j}} printf "\\" \\""; for (j=6;j<i;j++) {printf " "\$j} print "\\"";i=NF+1}}}'|$xargspath -L 1 "$poofitee_home_dir/process_logfile_line"  &>/dev/null
# @reboot $sudopath $nicepath -n15 $sudopath $tailpath -F -n 0 /var/log/auth.log|$xargspath -L 1 "$poofitee_home_dir/process_logfile_line"  &>/dev/null

CRONTAB_ENTRIES_END
) |$crontabpath -u poofitee -
# output of a grep -c is numeric below.  Tested good
[[ $($crontabpath -u poofitee -l 2>/dev/null|$greppath -c "^SHELL=") -eq 0 ]] && \
printf "SHELL=$bashpath\n$($crontabpath -u poofitee -l 2>/dev/null)\n"|$crontabpath -u poofitee - || \
$crontabpath -u poofitee -l 2>/dev/null|$sedpath '/SHELL=/c\SHELL=/bin/bash'|$crontabpath -u poofitee -
#couldn't launch the process until receiving script and other files are there
if ! [[ -f "$poofitee_home_dir/process_logfile_line" ]];then
     echo;echo "$poofitee_home_dir/process_logfile_line did not get created.  It should have well before now."
     exit
fi
if ! ($sudopath -u poofitee ps u|$greppath -v grep|$greppath "$xargspath"|$greppath "$poofitee_home_dir/process_logfile_line" &>/dev/null && $sudopath -u poofitee $pspath u|$greppath "kern.log" &>/dev/null);then
	$sudopath -u poofitee mkdir /tmp/poofitee &>/dev/null
	(cat <<-SCRIPT_END

	#!/bin/bash
	nohup $sudopath $nicepath -n-15 $sudopath $tailpath -F -n 0 /var/log/kern.log|$greppath --line-buffer ' SRC='|$greppath --line-buffer -vE 'SRC=0\.0\.0\.0|SRC=127\.0\.0\.1|SRC=10\.|SRC=172\.1[6-9]\.|SRC=172\.2.\.|SRC=172\.3[01]\.|SRC=192\.168\.'|$stdbufpath -o0 $awkpath '{for (i=6;i<=NF;i++) {if (\$i ~ "^SRC=") {{gsub("SRC=","",\$i); printf \$i" \\""} printf "kern.log "\$1" "\$2" "\$3; for (j=i;j<=NF;j++) {if (\$j ~ "^PROTO=" || \$j ~ "^SPT=" || \$j ~ "^DPT" || ((\$j ~ "^URGP") && (\$j !~ "^URGP=0$")) || \$j ~ "^SYN$" || \$j ~ "^ACK$" || \$j ~ "^FIN$" || \$j ~ "^PSH$" || \$j ~ "^RST$") {printf " "\$j}} printf "\\" \\""; for (j=6;j<i;j++) {printf " "\$j} print "\\"";i=NF+1}}}'|$xargspath -L 1 "$poofitee_home_dir/process_logfile_line"  &>/dev/null &

	SCRIPT_END
	) > /tmp/fifos_and_temp_files_for_poofitee_installer/launch_complex_cron_line1
        chown poofitee /tmp/fifos_and_temp_files_for_poofitee_installer/launch_complex_cron_line1
	chmod 700 /tmp/fifos_and_temp_files_for_poofitee_installer/launch_complex_cron_line1
	# Cannot proceed until "$poofitee_home_dir/toemailadds" is created
      # mv toemailadds "$poofitee_home_dir/toemailadds"
      # chown poofitee "$poofitee_home_dir/toemailadds"
	$sudopath -u poofitee /tmp/fifos_and_temp_files_for_poofitee_installer/launch_complex_cron_line1
fi
if ! ($sudopath -u poofitee ps u|$greppath -v grep|$greppath "$xargspath"|$greppath "$poofitee_home_dir/process_logfile_line" &>/dev/null && $sudopath -u poofitee ps u|$greppath "auth.log" &>/dev/null);then
	$sudopath -u poofitee mkdir /tmp/poofitee &>/dev/null
	(cat <<-SCRIPT_END

	#!/bin/bash
#	nohup $sudopath $nicepath -n15 $sudopath $tailpath -F -n 0 /var/log/auth.log||$xargspath -L 1 "$poofitee_home_dir/process_logfile_line"  &>/dev/null &
	SCRIPT_END
	) > /tmp/fifos_and_temp_files_for_poofitee_installer/launch_complex_cron_line2
        chown poofitee /tmp/fifos_and_temp_files_for_poofitee_installer/launch_complex_cron_line2
	chmod 700 /tmp/fifos_and_temp_files_for_poofitee_installer/launch_complex_cron_line2
	# Cannot proceed until "$poofitee_home_dir/toemailadds" is created
      # mv toemailadds "$poofitee_home_dir/toemailadds"
      # chown poofitee "$poofitee_home_dir/toemailadds"
	$sudopath -u poofitee /tmp/fifos_and_temp_files_for_poofitee_installer/launch_complex_cron_line2
fi

printf "\ncrontab for user poofitee set up...Original can be found in $poofitee_home_dir/cronentries\n"
}

install_tail_f_lines_and_receiving_script () {
(cat <<SCRIPT_END
#!/bin/bash
# poofitee_home_dir="$poofitee_home_dir"
email_subjectline_front="POOFITEE "
recipient_list="\$(cat $poofitee_home_dir/toemailadds)"
#echo "\$($datepath) accepting \$1" >> "\$0.log"
save_iptables () {
if ($sudopath $iptablespath -w -nL INPUT|$greppath ESTABLISHED &>/dev/null) && ($sudopath $iptablespath -w -nL INPUT|$greppath poofitee_static_trusted &>/dev/null); then
     if [[ "\$($datepath|$awkpath '{print \$2" "\$3" "\$4}')" == "\$(echo "\$1"|$awkpath '{print \$1" "\$2" "\$3}')" ]] || [[ "\$($datepath -d 'now - 1 seconds'|$awkpath '{print \$2" "\$3" "\$4}')" == "\$(echo "\$1"|$awkpath '{print \$1" "\$2" "\$3}')" ]];then
          $sudopath $netfiltperspath save &>/dev/null
     fi
else
        (cat <<-EOF
	\$($sudopath $crontabpath -l -u poofitee|$sedpath '/*\/5 \* \* \* \* .*\/email_fetch_parse" >\/dev\/null 2>&1/d')
	*/5 * * * * "$poofitee_home_dir/email_fetch_parse" &>/dev/null
	EOF
        )|$sudopath $crontabpath -u poofitee -
        if ! [[ \$((\$($sudopath $crontabpath -l -u poofitee |$wcpath -l))) -gt \$((\$( [[ -f "$poofitee_home_dir/cronentries.bak" ]] && $wcpath -l < "$poofitee_home_dir/cronentries.bak" || printf ""|$wcpath -l ))) ]];then
            $sudopath cat "$poofitee_home_dir/cronentries.bak"|$sudopath $crontabpath -u poofitee  -
            echo "Ruleset lost normal rules and is receiving blacklistable hits. Restore ruleset from most recent backup? Return email would say \"restore ruleset\".  Also unable to cronjob the email retrieval, so hopefully knocking the email through will work."|$mailpath -s "\$email_subjectline_front""firewall ruleset lost" "\$recipient_list"
       else
            echo "Ruleset lost normal rules and is receiving blacklistable hits. Restore ruleset from most recent backup? Return email would say \"restore ruleset\".  No knock for it will be needed. "|$mailpath -s "\$email_subjectline_front""firewall ruleset lost" "\$recipient_list"
       fi
fi

}

add_to_set () { # arg 1 is set name for address to get added to.  arg 2 is ipaddress plus proto plus port as is appropriate for the set.  arg 3 is comment from the log entry's pertinent info
if ! [[ \$($sudopath $ipsetpath add \$1 \$2 comment "\$3"  1>/dev/null 2>"$poofitee_home_dir/ramdisk/returerr") ]]; then
     if [[ "\$(cat $poofitee_home_dir/ramdisk/returerr )" =~ is\ full ]];then # send the email notice out FIRST
          echo "Increasing the size of the \$1 set. Verify continued server operation NOW"|$mailpath -s "Increasing the size of the \$1 set. Verify continued server operation NOW" "\$(cat $poofitee_home_dir/toemailadds)"
# list too full, make a larger new one, then swap it out and destroy old
# This would be a good time to consolidate single-host addresses into cidr ranges: static_trusted could be that only one address opens the whole range, blacklist could be that a percentage of range hits may be needed, say 50%
          if [[ "\$1" =~ trust ]];then 
               cidrset="\$($sudopath $ipsetpath list -t|$greppath -o "\$1"_cidr || echo "poofitee_stat_trustd_sockt_cidr")"
               $sudopath $ipsetpath list \$1|$tailpath -n+8|while read ipaddtmp commenttmp;do
                    sock="\${ipaddtmp#*','}"
                    [[ \${#sock} -eq \${#ipaddtmp} ]] && sock="" || sock=",\$sock"
                    if [[ "\$($sudopath $ipsetpath test \$cidrset "\$ipaddtmp" 2>&1)" =~ NOT ]];then
                         testrange="\$(($sudopath $ipsetpath list \$cidrset;echo \${ipaddtmp%','*})|$tailpath -n+8|$sortpath -Vk1|$greppath -wB1 \${ipaddtmp%','*} >"$poofitee_home_dir/ramdisk/grepout";$headpath -n -1 <"$poofitee_home_dir/ramdisk/grepout"| $awkpath '{print substr(\$1,1,index(\$1,",")-1)}')"
                         if ! [[ -z "\$testrange" ]] && ($sudopath $ipsetpath create test_cidr hash:net maxelem 1&>/dev/null;$sudopath $ipsetpath f test_cidr;$sudopath $ipsetpath add test_cidr "\$testrange";$sudopath $ipsetpath test test_cidr \${ipaddtmp%','*} 2>&1|$greppath -v NOT  &>/dev/null);then
                              eval "$sudopath $ipsetpath add \$cidrset \$($headpath -n -1 <"$poofitee_home_dir/ramdisk/grepout"|$awkpath '{print substr(\$1,1,index(\$1,",")-1)}')\$sock \$commenttmp"
                              $sudopath $ipsetpath test \$cidrset \$ipaddtmp 2>&1|$greppath -v NOT &>/dev/null && eval "$sudopath $ipsetpath del \$1 \$ipaddtmp &>/dev/null"
                         else
                              $timeoutpath 3 whois \${ipaddtmp%','*} 2>/dev/null| \
                                    $greppath '[[:alnum:]].*:.*\([0-9]\{1,3\}\.\)\{1,3\}[0-9]\{1,3\}.*[-/].*[0-9]'| \
                                    $sedpath -e 's/^.*://1' \
                                        -e 's/[0-9]\{4,\}/ /g' \
                                        -e 's/[3-9][0-9][0-9]/ /g' \
                                        -e 's/2[6-9][0-9]/ /g' \
                                        -e 's/25[6-9]/ /g' \
                                        -e 's/[^0-9^\.^/^-]\+/  /g' \
                                        -e 's/[^0-9][0\.][0-9][^ ^-]\+-\?/ /g' \
                                        -e 's/[^0-9]\+\.[^ ]*/ /g' \
                                        -e 's/\ *\([-/]\) */ \1 /g' \
                                        -e 's/^.*$/ & /' \
                                        -e 's/\([^0-9^\.]\+\([0-9]\{1,3\}\.\)\{1,3\}\)\([^0-9]\)/\10\3/g' \
                                        -e 's/\([^0-9^\.]\+\([0-9]\{1,3\}\.\)\{1,2\}[0-9]\{1,3\}\)\([^0-9^\.]\)/\1.\3/g' \
                                        -e 's/\([^0-9^\.]\+\([0-9]\{1,3\}\.\)\{1,3\}\)\([^0-9]\)/\10\3/g' \
                                        -e 's/\([^0-9^\.]\+\([0-9]\{1,3\}\.\)\{1,2\}[0-9]\{1,3\}\)\([^0-9^\.]\)/\1.\3/g' \
                                        -e 's/\([^0-9^\.]\+\([0-9]\{1,3\}\.\)\{1,3\}\)\([^0-9]\)/\10\3/g' \
                                        -e 's/[[:space:]]\([-/]\)/\1/g' \
                                        -e 's/\([-/]\)[[:space:]]/\1/g' \
                                        -e 's/\([0-9]\)-\([0-9]\{1,2\}[^0-9^\.]\)/\1\/\2/g' \
                                        -e 's/^[^1-9]\+//g'| \
                                   $awkpath '{for (i=1;i<=NF;i++){print \$i}}'| \
                                   $greppath '\([0-9]\{1,3\}\.\)\{1,3\}[0-9]\{1,3\}.*[-/].*[0-9]'| \
                              while read cidrtmp;do
                                   eval "$sudopath $ipsetpath add \$cidrset \$cidrtmp\$sock \$commenttmp &>/dev/null"
                                   $sudopath $ipsetpath test \$cidrset \$ipaddtmp 2>&1|$greppath -v NOT &>/dev/null && eval "$sudopath $ipsetpath del \$1 \$ipaddtmp &>/dev/null"
                              done
                         fi
                    else
                         eval "$sudopath $ipsetpath del \$1 \$ipaddtmp &>/dev/null"
                    fi
               done
          fi
          $sudopath $ipsetpath create "\${1::-3}"tmp hash:ip comment maxelem \$($sudopath $ipsetpath list -t|$greppath -iA 3 "^name: \$1"|$tailpath -n1|$awkpath '{printf \$7+65536}') &>/dev/null
          $sudopath $ipsetpath list \$1|$tailpath -n+8|while read ipaddtmp commenttmp;do
               $sudopath $ipsetpath add \${1::-3}tmp "\$ipaddtmp \$commenttmp" &>/dev/null
          done
          $sudopath $ipsetpath w \$1 \${1::-3}tmp &>/dev/null && $sudopath $ipsetpath x \${1::-3}tmp &>/dev/null
          eval "$sudopath $ipsetpath add \$1 \$2 comment \$3"
     fi
fi
}

if ! [[ \$1 =~ ^((([1-9]|[1-9][0-9]|1[0-9])?[0-9]|2[0-4][0-9]|25[0-5])\.){3}(1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])((/[0-2]?[0-9])|(/3[0-2]))?$ ]];then #if more than a mere ip address was given in arg #1, skip this and go to else
     if ! [[ "\$1" =~ :.*\ poofitee ]];then
           exit
     elif [[ "\$1" =~ :.*\ poofitee.*blacklist.*IN=eth0\  ]];then
           ipadd=\$(echo "\$1"|$greppath -o 'SRC=.*'|$awkpath '{printf substr(\$1,5)}')
           if ( $sudopath $ipsetpath test poofitee_static_trusted \$ipadd 2>&1|$greppath NOT &>/dev/null && $sudopath $ipsetpath test poofitee_static_trusted_cidr \$ipadd 2>&1|$greppath NOT &>/dev/null);then #
           comment=\$(echo "\$1"|$awkpath '{for (i=6;i<=NF;i++) {if (\$i ~ "^DST=") {printf "kern.log "\$1" "\$2" "\$3; for (j=i;j<=NF;j++) {if (\$j ~ "^PROTO=" || \$j ~ "^SPT=" || \$j ~ "^DPT"  || \$j ~ "^ID" || ((\$j ~ "^URGP") && (\$j !~ "^URGP=0$")) || \$j ~ "^SYN$" || \$j ~ "^ACK$" || \$j ~ "^FIN$" || \$j ~ "^PSH$" || \$j ~ "^RST$") {printf " "\$j}} i=NF+1}}}';printf " ";printf "\$1"|$greppath -o '[^ ]\+eth0' || echo)
                sport=\$(echo "\$comment"|$greppath -o 'SPT=\S*'|$awkpath '{printf substr(\$1,5)}')
                if ( $sudopath $ipsetpath test poofitee_static_trusted_socket \$ipadd,\$sport 2>&1|$greppath NOT &>/dev/null && $sudopath $ipsetpath test poofitee_stat_trustd_cidr_sockt \$ipadd,\$sport  2>&1|$greppath NOT &>/dev/null);then
                     add_to_set poofitee_blacklist \$ipadd "\$comment"
                fi
           fi
     elif [[ "\$1" =~ :.*\ poofitee.*out.*trust ]] && [[  "\$1" =~ IN=eth1\ OUT=eth0\  ]];then
                ipadd=\$(echo "\$1"|$greppath -o 'DST=.*'|$awkpath '{printf substr(\$1,5)}')
                comment=\$(echo "\$1"|$awkpath '{for (i=6;i<=NF;i++) {if (\$i ~ "^DST=") {printf "kern.log "\$1" "\$2" "\$3; for (j=i;j<=NF;j++) {if (\$j ~ "^PROTO=" || \$j ~ "^SPT=" || \$j ~ "^DPT"  || \$j ~ "^ID" || ((\$j ~ "^URGP") && (\$j !~ "^URGP=0$")) || \$j ~ "^SYN$" || \$j ~ "^ACK$" || \$j ~ "^FIN$" || \$j ~ "^PSH$" || \$j ~ "^RST$") {printf " "\$j}} i=NF+1}}}';printf " ";printf "\$1"|$greppath -o '[^ ]\+eth0' || echo)
                dport=\$(echo "\$comment"|$greppath -o 'DPT=\S*'|$awkpath '{printf substr(\$1,5)}')
                add_to_set poofitee_static_trusted_socket "\$ipadd,\$dport" "\$comment"
                add_to_set poofitee_static_trusted_socket "\$ipadd,udp:\$dport" "\$comment"
                if [[ "\$dport" == "443" ]];then
                     dport=80
                     add_to_set poofitee_static_trusted_socket "\$ipadd,\$dport" "\$comment"
                     add_to_set poofitee_static_trusted_socket "\$ipadd,udp:\$dport" "\$comment"
                elif [[ "\$dport" == "80" ]];then
                     dport=443
                     add_to_set poofitee_static_trusted_socket "\$ipadd,\$dport" "\$comment"
                     add_to_set poofitee_static_trusted_socket "\$ipadd,udp:\$dport" "\$comment"
                fi
     elif [[ "\$1" =~ :.*\ poofitee.*whitelist.*IN=eth0\  ]];then
          ipadd=\$(echo "\$1"|$greppath -o 'SRC=.*'|$awkpath '{printf substr(\$1,5)}')
          comment=\$(echo "\$1"|$awkpath '{for (i=6;i<=NF;i++) {if (\$i ~ "^DST=") {printf "kern.log "\$1" "\$2" "\$3; for (j=i;j<=NF;j++) {if (\$j ~ "^PROTO=" || \$j ~ "^SPT=" || \$j ~ "^DPT"  || \$j ~ "^ID" || ((\$j ~ "^URGP") && (\$j !~ "^URGP=0$")) || \$j ~ "^SYN$" || \$j ~ "^ACK$" || \$j ~ "^FIN$" || \$j ~ "^PSH$" || \$j ~ "^RST$") {printf " "\$j}} i=NF+1}}}';printf " ";printf "\$1"|$greppath -o '[^ ]\+eth0' || echo)
          $poofitee_home_dir/openall.sh "\$ipadd" "\$comment"
     fi
#     $greppath --line-buf ' SRC='|$greppath --line-buf -vE 'SRC=0\.0\.0\.0|SRC=127\.0\.0\.1|SRC=10\.|SRC=172\.1[6-9]\.|SRC=172\.2.\.|SRC=172\.3[01]\.|SRC=192\.168\.'|$stdbufpath -o0 $awkpath '{for (i=6;i<=NF;i++) {if (\$i ~ "^SRC=") {{gsub("SRC=","",\$i); printf \$i" \""} printf "kern.log "\$1" "\$2" "\$3; for (j=i;j<=NF;j++) {if (\$j ~ "^PROTO=" || \$j ~ "^SPT=" || \$j ~ "^DPT"  || ((\$j ~ "^URGP") && (\$j !~ "^URGP=0$")) || \$j ~ "^SYN$" || \$j ~ "^ACK$" || \$j ~ "^FIN$" || \$j ~ "^PSH$" || \$j ~ "^RST$") {printf " "\$j}} printf "\" \""; for (j=6;j<i;j++) {printf " "\$j} print "\"";i=NF+1}}}'
else

if [[ -z "\$3" ]] || [[ "\$3" =~ blacklist ]] && ! ( [[ "\$2" =~ DPT=[45]\S\S\S\S\s ]] && ( [[ "\$2" =~ SPT=587\  ]] || [[ "\$2" =~ SPT=443\  ]] || [[ "\$2" =~ SPT=80\  ]] || [[ "\$2" =~ SPT=993\  ]] ));then
     if ($sudopath $ipsetpath test poofitee_static_trusted \$1 2>&1|$greppath NOT &>/dev/null && $sudopath $ipsetpath test poofitee_static_trusted_cidr \$1 2>&1|$greppath NOT &>/dev/null);then
         sport=\$(echo "\$2"|$greppath -o 'SPT=\S*\s'|$awkpath '{printf substr(\$1,5)}')
             if ( $sudopath $ipsetpath test poofitee_static_trusted_socket \$1,\$sport 2>&1|$greppath NOT &>/dev/null && $sudopath $ipsetpath test poofitee_stat_trustd_cidr_sockt \$1,\$sport  2>&1|$greppath NOT &>/dev/null);then
           if ! [[ \$($sudopath $ipsetpath add poofitee_blacklist \$1 comment "\$2"  2>$poofitee_home_dir/ramdisk/returerr) ]]; then
          if [[ "\$(cat $poofitee_home_dir/ramdisk/returerr )" =~ is\ full ]];then # send the email notice out FIRST
               echo "Increasing the size of the blacklist. Verify continued server operation NOW"|$mailpath -s "Increasing the size of the blacklist. Verify continued server operation NOW" "\$(cat $poofitee_home_dir/toemailadds)"
# list too full, make a larger new one, then swap it out and destroy old
               $sudopath $ipsetpath create poofitee_blacklisttmp hash:ip comment maxelem \$($ipsetpath list -t|$greppath -iA 3 "^name: poofitee_blacklist"|$tailpath -n1|$awkpath '{printf \$7+65536}')
               $sudopath $ipsetpath list poofitee_blacklist|$tailpath -n+8|while read ipadd comment;do
                   $sudopath $ipsetpath add poofitee_blacklisttmp "\$ipadd \$comment"
               done
               $sudopath $ipsetpath w poofitee_blacklist poofitee_blacklisttmp && $sudopath $ipsetpath x poofitee_blacklisttmp
          fi;fi
#          rm $poofitee_home_dir/ramdisk/returerr
      fi
     fi
fi
# amount_of_free_memory="\$($freepath -b|$awkpath '{if (\$1=="Mem:"){printf \$4;exit}}')"
ps > "$poofitee_home_dir/ramdisk/psout"
$greppath "^\$$" < "$poofitee_home_dir/ramdisk/psout"|$greppath -v grep|$sedpath -n 's/\S*\s*\S*\s*\S*\s*//p' > "$poofitee_home_dir/ramdisk/forpslinecount"
echo "\$$" > "$poofitee_home_dir/ramdisk/psnum"
#This test will allow CIDR-type consolidated IPv4 address ranges
if [[ \$1 =~ ^((([1-9]|[1-9][0-9]|1[0-9])?[0-9]|2[0-4][0-9]|25[0-5])\.){3}(1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])((/[0-2]?[0-9])|(/3[0-2]))?$ ]];then
     if [[ ! "\$3x" =~ whitelist ]] && [[ ! "\$3x" =~ knock ]] && [ "\$2x" != "-rx" ] && [ "\$3x" != "-rx" ] && [[ ! "\$3x" =~ public\ service\ after\ blacklis ]] ;then
           if [[ "\$3x" =~ fetch\ email ]];then
                nohup "$poofitee_home_dir/email_fetch_parse" &
           elif [[ "\$3x" =~ static_trust ]];then
                sport=\$(echo "\$2"|$greppath -o 'SPT=\S*\s'|$awkpath '{printf substr(\$1,5)}')
                $sudopath $ipsetpath add poofitee_static_trusted_socket \$1,\$sport comment "\$2" &>/dev/null
                $sudopath $ipsetpath add poofitee_static_trusted_socket \$1,udp:\$sport comment "\$2" &>/dev/null
                if [ \$sport == "443" ];then
                     sport=80
                     $sudopath $ipsetpath add poofitee_static_trusted_socket \$1,\$sport comment "\$2" &>/dev/null
                     $sudopath $ipsetpath add poofitee_static_trusted_socket \$1,udp:\$sport comment "\$2" &>/dev/null
                elif [ \$sport == "80" ];then
                     sport=443
                     $sudopath $ipsetpath add poofitee_static_trusted_socket \$1,\$sport comment "\$2" &>/dev/null
                     $sudopath $ipsetpath add poofitee_static_trusted_socket \$1,udp:\$sport comment "\$2" &>/dev/null
                fi
#                $sudopath $ipsetpath add poofitee_static_trusted \$1 comment "\$2" &>/dev/null
           fi
     else
          $sudopath $ipsetpath del poofitee_blacklist \$1 &>/dev/null
          if [[ "\$3x" =~ whitelist ]];then
                "$poofitee_home_dir/openall.sh" "\$1" "by knocking"
          elif [[ "\$3x" =~ knock ]] || [[ "\$3x" =~ public\ service\ after\ blacklis ]]; then
               echo "if [[ "\$($sudopath $ipsetpath test whitelist \$1 2>&1)" =~ NOT ]]; then $sudopath $ipsetpath add blacklist \$1 comment "\$2" >/dev/null 2>/dev/null;fi"|at now +3 minute
          elif [ "\$2x" == "-rx" ] || [ "\$3x" == "-rx" ];then
               $sudopath $ipsetpath del poofitee_blacklist "\$1"
          fi
     #  The lines below this are for detecting the knock and launching email fetch when the email-reader triggering port is knocked
     #  Notice that the email-reader triggering port is gotten from iptables INPUT chain rule with email-reader in its comment
     #  That rule will look like this:  LOG        tcp  --  eth0   *       0.0.0.0/0            0.0.0.0/0            tcp dpt:nnnnn /* This rule ensures email-reader port knock won't get ignored */ LOG flags 0 level 4
     #  The rule would be created with a command like this (change the 7 and nnnnn to fit you): iptables -wI INPUT 7 -i eth0 -p tcp --dport nnnnn -j LOG -m comment --comment "This rule ensures email-reader port knock won't get ignored"
#     [[ \$($greppath -c "#running" <($tailpath -n-1 "$poofitee_home_dir/email_fetch_parse")) -gt 0 ]] && exit #the user needed to send that email plenty early before knocking this
#     if [ \$(printf "\$3"|$greppath -c "fetch email") -gt 0 ];then
#             nohup "$poofitee_home_dir/email_fetch_parse" &
#     fi
#elif [[ "\$1"  =~ \ \$(hostname)\ .*:\ .+ ]];then
#     $ipsetpath remove blacklist \$1 >/dev/null 2>/dev/null
#     echo "\$1"|$mailpath -s "\$email_subjectline_front""auth.log entry" "\$recipient_list"
     fi
else
     $sudopath $ipsetpath del poofitee_blacklist \$1 &>/dev/null
     echo "This script requires a valid IP address besides the script name: \$1" >> "\$0.log"
fi
fi
save_iptables "\$1"
#echo "\$($datepath) Done with all processing file" >> "\$0.log"
SCRIPT_END
) > "$poofitee_home_dir/process_logfile_line"
printf "."
if ! [[ -f "$poofitee_home_dir/process_logfile_line" ]];then 
    echo;echo "$poofitee_home_dir/process_logfile_line did not get created just now"
    exit
fi
printf "."
chown poofitee "$poofitee_home_dir/process_logfile_line"
chmod 500 "$poofitee_home_dir/process_logfile_line"
printf "."
install_firewall_cronentries
}
back_up_iptables_ruleset () {
printf "\nPlease wait while your $1 iptables ruleset is backed up..."
while current_time="$($datepath)";[[ -f "$poofitee_home_dir/iptables_ruleset.$current_time" ]];do
     sleep 1
done
if ! [[ -z "$iptabsavepath""$netfiltperspath" ]];then
     $iptablespath-save > "$poofitee_home_dir/iptables_ruleset.$current_time" 2>/dev/null
     $([[ -z "$iptabsavepath" ]] && printf "$netfiltperspath save" || printf "$iptabsavepath") &>/dev/null 
     backup_result="$?"
     [[ "$backup_result" ]] && printf "\nA copy of your $1 iptables ruleset is backed up in\
\n\n$poofitee_home_dir/iptables_ruleset.$current_time\n"
fi
if [[ "$backup_result" ]] && ! [[ -z "$ipsetpath" ]] && "$ipsetpath list" &>/dev/null]];then
     "$ipsetpath save > /etc/iptables/ipset.sets" 2>/dev/null
     backup_result="$?"
fi
return $(($backup_result))
}
find_first_reference_to_internal_interface () {
if ! [[ -z "$likeliest_internal_net_interface" ]];then
     $iptablespath -w -N poofitee_knockerstest 2>/dev/null # ;echo "$?") == "0" ]] || printf "Failed"
     [[ $($iptablespath -w -F poofitee_knockerstest 2>/dev/null;echo "$?") == "0" ]] || printf "Failed to flush knockerstest chain rules"
     printf "\n"
     printf "" > /tmp/fifos_and_temp_files_for_poofitee_installer/internal_interfaces_referenced # won't include the default gateway
# test knock rules belonging in the INPUT chain need to be located just prior to any other reference to that private interface or any of the addresses associated with such interface
     echo "$internal_net_interfaces"|$awkpath '{print $1}' \
     |while read interface; do
          $iptablespath -w -nvL INPUT --line-number \
          |$awkpath 'NR>2 {print $1" "$7" "$9}' \
          |while read linenum_intfc_src_addr_in_input_chain; do
                    linenum_in_input_chain="${linenum_intfc_src_addr_in_input_chain%% *}"
                    intfc_src_addr_in_input_chain="${linenum_intfc_src_addr_in_input_chain#* }"
                    intfc_in_input_chain="${intfc_src_addr_in_input_chain% *}"   # echo "$src_addr_in_input_chain | $linenum_in_input_chain | $intfc_in_input_chain";
                    src_addr_in_input_chain="${intfc_src_addr_in_input_chain#* }"; src_addr_in_input_chain="${src_addr_in_input_chain%/*}"
            # the next search is to locate references of the internal interface under scrutiny in each line of chain in route table
                    if [[ $(($($ippath route show|$greppath $intfc_in_input_chain|$greppath -c default))) -eq 0 ]];
                    then echo "$linenum_in_input_chain $intfc_in_input_chain" >> /tmp/fifos_and_temp_files_for_poofitee_installer/internal_interfaces_referenced
                    elif ! [[ "$src_addr_in_input_chain" == "0.0.0.0" ]];then # we assume if finding by address, route tables are already set up
# determine address range[s] routed out that interface and check for input chain references to any of them 
#   using $ippath route show|$greppath $internal_net_interfaces|$awkpath '{print $1}' -> convert each line 
#   to binary which gives one or more lines of address ranges to match to ip addresses referenced in INPUT chain to, /32 = no / at all.  Abort operation if private interface is also default
# $ipsetpath n poofitee_internal_iface_ranges hash:net comment
# $ipsetpath test poofitee_internal_iface_ranges "$src_addr_in_input_chain"
# SEARCH FOR ADDRESSES EVEN IF INTERFACE REFERENCE IS FOUND SO CAN KNOW THE FIRST LINE EITHER ONE OCCURS IN.
                         $ippath route show|$greppath -v default|$greppath $interface \
                         |while read line; do 
                              line="${line%% *}/32"
                              range_start="${line%%/*}"
                         [[ $(printf "$range_start\n$src_addr_in_input_chain"|$sortpath -V|$tailpath -n1) == "$src_addr_in_input_chain" ]] || break
                         cidr_bits="${line#*/}"
                         cidr_bits="${line%%/*}"
                         src_addr_in_input_chain_seg1="${src_addr_in_input_chain%%.*}"
                         range_start_seg1="${range_start%%.*}"
                         src_addr_in_input_chain="${src_addr_in_input_chain#*.}"
                         range_start="${range_start#*.}"
                         src_addr_in_input_chain_seg2="${src_addr_in_input_chain%%.*}"
                         range_start_seg2="${range_start%%.*}"
                         src_addr_in_input_chain="${src_addr_in_input_chain#*.}"
                         range_start="${range_start#*.}"
                         src_addr_in_input_chain_seg3="${src_addr_in_input_chain%%.*}"
                         range_start_seg3="${range_start%%.*}"
                         src_addr_in_input_chain="${src_addr_in_input_chain#*.}"
                         range_start="${range_start#*.}"
                         src_addr_in_input_chain_seg4="${src_addr_in_input_chain%%.*}"
                         range_start_seg4="${range_start%%.*}"
                         doubler=1
                         for ((j=$((32 - $cidr_bits));j>0;j--)); do
                              doubler=$(( $doubler * 2 ))
                         done
                         range_end=$(( ($range_start_seg1 * 256 * 256 * 256) + ($range_start_seg2 * 256 * 256) + ($range_start_seg3 * 256) + $range_start_seg4 + $doubler -1 ))
                         src_addr_in_input_chain=$(( ($src_addr_in_input_chain_seg1 * 256 * 256 * 256) + ($src_addr_in_input_chain_seg2 * 256 * 256) + ($src_addr_in_input_chain_seg3 * 256) + $src_addr_in_input_chain_seg4 ))
                         if [[ "$(printf "$range_end\n$src_addr_in_input_chain"|$sortpath -n|$tailpath -n1)" == "$range_end" ]];then
                              #   echo "within range"
                              "$linenum_in_input_chain $intfc_in_input_chain" >> /tmp/fifos_and_temp_files_for_poofitee_installer/internal_interfaces_referenced
                         fi
                    done
               fi
          done
     done
     linenumber_for_inserting_before=$(($($sortpath -k1 < /tmp/fifos_and_temp_files_for_poofitee_installer/internal_interfaces_referenced|$awkpath '{if (NR==1) {print $1}}')))
     [[ "$linenumber_for_inserting_before" == "0" ]] && linenumber_for_inserting_before="1"
     if ! [[ -z "$($greppath ^Port /etc/ssh/sshd_config|$awkpath '{print $2}')" ]]; then
          [[ $($iptablespath -w -I INPUT $linenumber_for_inserting_before -i $likeliest_internal_net_interface -m comment --comment "poofitee_knock extract ssh for knock testg frm private side in ssh" -p tcp --dport $($greppath ^Port /etc/ssh/sshd_config|$awkpath '{print $2}') -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT 2>/dev/null;echo "$?") == "0" ]] && linenumber_for_inserting_before=$(( $linenumber_for_inserting_before + 1 )) || printf "Failed 14"
     fi
     line_number_for_authorized_rule=$linenumber_for_inserting_before
fi
}

get_operator_knock_choices () {
                 minimum_number_of_knocks="$([[ "x$1$2$3" =~ unique ]] && echo "4" || echo "2")"
                 $iptablespath -w -N poofitee_ruletestchain 2>/dev/null # This chain is merely a place to pre-test whether a rule will be accepted by iptables or not
                 $iptablespath -w -F poofitee_ruletestchain 2>/dev/null # This chain is merely a place to pre-test whether a rule will be accepted by iptables or not
                 i=1
                 while knockport[$i]="";printf "\n";read -e -p "Knock $i port:" knockport[$i];! [[ -z "${knockport[$i]}" ]] || [[ $(($i)) -le $(($minimum_number_of_knocks)) ]];do
                      [[ -z "${knockport[$i]}" ]] && printf " You need to specify at least $minimum_number_of_knocks knocks" && continue
                      if ! [[ "${knockport[$i]}" =~ ^[0-9]{1,5}$ ]] || ! [[ $(( ${knockport[$i]} )) -le 65536 ]] || [[ -z "${knockport[$i]}" ]] ;then continue;fi
                      if ! [[ -z "$likeliest_internal_net_interface" ]] && [[ -f "/etc/ssh/sshd_config" ]] && [[ "$($greppath ^Port /etc/ssh/sshd_config|$awkpath '{print $2}')" =~ [0-9] ]] && [[ " ${knockport[$i]} " =~ \ $($greppath ^Port /etc/ssh/sshd_config|$awkpath '{print $2}')\  ]];then
                         printf "You are advised against specifying your ssh port "$(printf "("$($greppath ^Port /etc/ssh/sshd_config|$awkpath \
'{printf $2}')")")" simply because it will\
\ninterfere with you testing your sequence through an ssh session.  Do you still\
\nwant to specify this port? (y/n) ";read  -rn1;read -rst 0.001 -n3 discard;! [[ $REPLY =~ [Yy] ]] && continue
                      fi
                      printf "\nKnock $i protocol (choose from \"all\" [any protocol is acceptable] or those listed\
\nin /etc/protocols.  TCP with SYN flag is defaulted below and will function if\
\nyou don\'t care to get any fancier.  You may include mask-flag spec or other\
\niptables matching options beyond this, if you know them, except the -j target,\
\n-g chain, -m recent, and -m comment iptables modules/options):\n\
\n";knockproto[$i]="-p tcp --syn ";read -eri "${knockproto[$i]}" knockproto[$i]
                      testtarget[$i]=" -j DROP"
                      if [[ "${knockproto[$i]}" =~ \ --tcp-flags\ .*ACK\ .*ACK ]] ; then
#                      if [[ "${knockproto[$i]}" =~ \ --tcp-flags\ *[^[:space:]g]*\ *ACK\  ]] ; then
                           until false; do
                                if ! [[ -z "$if_first_knock_is_ACK_message" ]] && [[ "$i" == "1" ]];then
                                     printf "$if_first_knock_is_ACK_message"
                                     read -rn 1;read -rst 0.001 -n3 discard
                                     [[ $REPLY =~ [Rr] ]] && continue 2
                                     ! [[ $REPLY =~ [Kk] ]] && break
                                else
                                     printf "You've specified a packet type that would generate a reply of some type from the\
\nserver in normal communications.  To help disguise the knock packet from packet\
\nsniffing hackers so it looks like a normal communication packet, do you want the\
\nserver to reply to this knock (with a REJECT$(! [[ -z "$if_first_knock_is_ACK_message" ]] && \
printf ", and of course only if the previous\nknocks in the sequence have been received correctly)" || printf ")")? (y/n): "
                                     read -rn 1;read -rst 0.001 -n3 discard
                                     if ! [[ $REPLY =~ [Yy] ]]; then
                                          [[ $REPLY =~ [Nn] ]] && break
                                          continue
                                     fi
                                fi
                                testtarget[$i]=" -j REJECT --reject-with tcp-reset"
                                break
                           done
                      fi
                      protovar="${knockproto[$i]}"
                      protovar="${protovar:1}"
                      knockproto[$i]="-${protovar%%-*} --dport ${knockport[$i]} -${protovar#*-}" #combines both never again to need port kept separate for rule-making
                      if ! [[ $($iptablespath -w -A poofitee_ruletestchain ${knockproto[$i]}${testtarget[$i]} ;echo "$?") == "0" ]];then
                          printf -- "Your ${knockproto[$i]} is not crafted well enough, try again\n"
                          continue
                      fi
                      if [[ "x$1$2$3" =~ unique ]] && ! [[ "$(i=1;while ! [[ -z "${knockproto[$i]}" ]];do printf -- "${knockproto[$i]}";printf "\n";i=$(($i + 1));done|$sortpath|$uniqpath -d|$wcpath -l)" == "0" ]];then
                          printf -- "\nYour ${knockproto[$i]} is required to be unique and is not, try again\n"
                          continue
                      fi
                      i=$(( $i+1 ));[[ $(( $i )) -gt 16 ]] && break
                 done
}
move_cursor_to_next_entry_in_list () {
line=""
echo
linesfrommaster="$toemailaddsmaster"
if ! [[ $(( $mstrlinenumber )) -gt $(( $mstrnumoflines )) ]];then
     if  [[ $(( $mstrlinenumber )) -lt 2 ]];then
          line="${linesfrommaster%%,*}" # set to next line in master
          printf "\r$line\033[K"
          return
     fi
     loopmstrptr=1
     until loopmstrptr="$(( $loopmstrptr  + 1 ))";linesfrommaster="${linesfrommaster#*,}";[[ -z "$linesfrommaster" ]] || [[ $(( $loopmstrptr  )) -gt $(( $mstrnumoflines )) ]];do
         [[ $(( $loopmstrptr  )) -lt $(( $mstrlinenumber )) ]] && continue
         entriesscratchpad="$(printf "$toemailadds"|$awkpath 1 ORS=',')"
         while ! [[ -z "$entriesscratchpad" ]] && ! [[ -z "${linesfrommaster%%,*}" ]] && ! [[ "${entriesscratchpad%%,*}" == "${linesfrommaster%%,*}" ]];do
             entriesscratchpad="${entriesscratchpad#*,}" # gets the next line from slave
         done
         [[ -z "$entriesscratchpad" ]] || [[ -z "${linesfrommaster%%,*}" ]] && break
         [[ "${entriesscratchpad%%,*}" == "${linesfrommaster%%,*}" ]] && ( linesfrommaster="${linesfrommaster#*,}";continue )
     done
     line="${linesfrommaster%%,*}" # set to next line in master
     [[ "${entriesscratchpad%%,*}" == "${linesfrommaster%%,*}" ]] && line=""
      printf "\r$line\033[K"
else
      printf "\033[K"
fi
}
get_sendto_emailadds () {  # can take one optional arg, "onlyneed1" which will change behavior from taking numerous entries, storing them in variable toemailadds to either taking one entry or selecting one entry from previous list and storing it in variable mailadd
     [[ -z "$poofitee_home_dir" ]] && poofitee_home_dir="$( [[ -f poofitee_home_dir ]] && cat poofitee_home_dir || printf "$poofitee_home_dir")"
#or check user poofitee home directory
     line=""
     if [[ -f "$poofitee_home_dir/toemailadds" ]];then
           line="$(cat "$poofitee_home_dir/toemailadds")"
     elif [[ -f "./toemailadds" ]];then
           line="$(cat "./toemailadds")"
     elif ! [[ -z $mailadd ]];then
           line="$mailadd"
     fi
     toemailaddsmaster="$line"
     mstrlinenumber=1
     mstrnumoflines=$( echo "$toemailaddsmaster"|$sedpath 's/,/\n/g'|$wcpath -l )
     line="${line%%,*}"         # not real sure where the best place is for these lines.  Prior to while loop maybe?
     ! [[ -z "$line" ]] && printf "$(echo "$toemailaddsmaster"|$sedpath 's/,/\n/g')\n\033["$mstrnumoflines"A\r$line\033[K"
     toemailadds=""

     while IFS= read -s -n1 -r char;do # [[ -z "$char" ]] && break
          if [[ "$(printf "%d" "'$char")" == "27" ]];then # 'escape or extended key has been detected, single quote is important
                     if [[ $(read -rst 0.001 -n1;echo $REPLY) == "[" ]];then
                           read -rst 0.001 -n1;read -rst 0.001 -n1 discard
                           if [[ "$REPLY" == "B" ]] && ! [[ $(( $mstrlinenumber )) -gt $(( $mstrnumoflines )) ]];then #down-arrow pressed
                                mstrlinenumber="$(( $mstrlinenumber + 1 ))"
                                move_cursor_to_next_entry_in_list
                           elif [[ "$REPLY" == "A" ]] && [[ $(( $mstrlinenumber )) -gt 1 ]];then #up-arrow pressed
                                printf "\033[2A"
                                mstrlinenumber="$(( $mstrlinenumber - 1 ))"
                                move_cursor_to_next_entry_in_list
                           fi
                     else
                         read -rst 0.001 -n2 # read & discard 2nd extended key field, timeout if real escape
                     fi
          elif [[ -z "$char" ]] || [[ "$char" == " " ]];then
                      if [[ -z "$line" ]] && [[ $(( $mstrlinenumber )) -lt $(( $mstrnumoflines )) ]];then
# Shift and display next from master on this line 
                           linesfrommaster="$toemailaddsmaster"
                           mstrlinenumber="$(( $mstrlinenumber + 1 ))"
                           loopmstrptr=1
                           until loopmstrptr="$(( $loopmstrptr  + 1 ))";linesfrommaster="${linesfrommaster#*,}";[[ -z "$linesfrommaster" ]] || [[ $(( $loopmstrptr  )) -gt $(( $mstrnumoflines )) ]];do
                               [[ $(( $loopmstrptr  )) -lt $(( $mstrlinenumber )) ]] && continue
                               entriesscratchpad="$(printf "$toemailadds"|$awkpath 1 ORS=',')"
                               while ! [[ -z "$entriesscratchpad" ]] && ! [[ -z "${linesfrommaster%%,*}" ]] && ! [[ "${entriesscratchpad%%,*}" == "${linesfrommaster%%,*}" ]];do
                                   entriesscratchpad="${entriesscratchpad#*,}" # gets the next line from slave
                               done
                               [[ -z "$entriesscratchpad" ]] || [[ -z "${linesfrommaster%%,*}" ]] && break
                               [[ "${entriesscratchpad%%,*}" == "${linesfrommaster%%,*}" ]] && ( linesfrommaster="${linesfrommaster#*,}";continue )
                           done
                           line="${linesfrommaster%%,*}" # set to next line in master that is not duplicated in slave var
                           [[ "${entriesscratchpad%%,*}" == "${linesfrommaster%%,*}" ]] && line=""
                           printf "\r$line\033[K"
                      elif ! [[ -z "$line" ]];then
                          if ! [[ "$line" =~ ^(([-a-zA-Z0-9\!#\$%\&\'*+/=?^_\`{\|}~]+|(\"([][,:;<>\&@a-zA-Z0-9\!#\$%\&\'*+/=?^_\`{\|}~-]|(\\\\[\\ \"]))+\"))\.)*([-a-zA-Z0-9\!#\$%\&\'*+/=?^_\`{\|}~]+|(\"([][,:;<>\&@a-zA-Z0-9\!#\$%\&\'*+/=?^_\`{\|}~-]|(\\\\[\\ \"]))+\"))+@[A-Za-z0-9.-]+\.[A-Za-z]{2,4}$ ]];then
                              printf " checked bad, use backspace to correct\r$line"
                          else #this is the place where operator installing has entered an email address and pressed enter or space
                              if [[ "$1" == "onlyneed1" ]];then mailadd="$line";for ((i=$(( $mstrlinenumber ));i<=$(( $mstrnumoflines ));i++));do printf "\r\033[B\033[K";done;for ((i=1;i<=$(( $mstrnumoflines ));i++));do printf "\r\033[A\033[K";done;return;fi
                              toemailadds+="$line\n"
                              mstrlinenumber="$(( $mstrlinenumber + 1 ))"
                              move_cursor_to_next_entry_in_list
                          fi
                      elif [[ -z "$1" ]] || [[ "$2" == "optional" ]];then
#                          printf "\033[K"  # if ever needed
                          break
                      fi
          elif [[ "$(printf "%d" "'$char")" == "127" ]];then # ' backspace pressed
                     if ! [[ -z "$line" ]];then
                         line="${line:0: -1}" # handles the backspace character
                         printf "\r$line\033[K" # needed b/c when several keys are pressed simultaneously only first gets silented
                     fi
          else
                          printf "$char";
                          line+="$char"
          fi
     done
     if ! [[ -z $toemailadds ]] && [[ -z "$1" ]];then
         poofitee_home_dir="$( cat poofitee_home_dir )"
         toemailaddsforfiling="$(printf "$toemailadds"|$awkpath 1 ORS=',')"
         [[ "${toemailaddsforfiling: -1}" == "," ]] && toemailaddsforfiling="${toemailaddsforfiling:: -1}"
         printf "$(printf "$toemailaddsforfiling\n")" > "$poofitee_home_dir/toemailadds"
         break
     fi

}
install_port_knocking () {
            REPLY=""
            until [[ "$REPLY" =~ [yn] ]]; do
               printf "\nThe OTP feature is not yet finished.  Read how it will work and code it yourself\
\nif you want to..."
               read -e -r -n1 -p "\nUse OTPs (One-Time-Passwords)? (y, n, or ? for help) Client side is not free:"
               REPLY="${REPLY,}"
               [[ "$REPLY" =~ \? ]] && ( \
printf "\n  Client configuration is available under different licensing terms if you need\
\nus to do it for you.  Thank you...\
\n  Using One-Time-Passwords (OTPs) thwarts record-and-replay security attacks.\
\nIf hackers record your port knocks, their attempts to replay the knock sequence\
\nwith a previously used password (or wrong one or none at all) will, instead of\
\ngiving them access to your system, broadcast an email &/or SMS alert for you. An\
\ninvalid OTP submitted after successful port knocking positively identifies\
\npurposeful targeted contact.  Non-knocking firewall configurations, such as\
\nsimple SPA, lack this definity and may also be more vulnerable to memory\
\nexhaustion under DoS attack.  Your peace of mind from knowing if hacking at that\
\nlevel of sophistication is ever even attempted is priceless & worth the packets.\
\n  You create an OTP list of single-use passwords and supply it to the trusting\
\ndevice (this server) and to trusted devices and/or persons using some form of\
\nout-of-band communication (private connection, email, thumbdrive, etc.).  The\
\nOTP list can have not just one, but multiple OTPs for each label, so the trusted\
\nknockers can choose or be assigned unique and different security access levels.\
\nWhen the list of OTPs gets used up or nearly so, a notification email is sent to\
\nremind you to distribute a new OTP list.  The old OTP list just recirculates\
\nuntil replaced...used OTPs will get used again until you get time to generate a\
\nnew OTP list and give everyone a copy of it. Thus, it will be YOUR\
\nresponsibility to enforce a single-use-only policy on OTPs, if you really need\
\nthat extreme level of security.  With the encryption depth and options allowed,\
\nyou may elect to let an OTP list be used more than once without serious risk of\
\ncompromise, especially with unrecognizable OTPs.";press_a_key;\
printf "\n  The OTP list is a non-encrypted text file: the first line is simply the month-\
\nyear number pair (includes the dash) the OTP list is created, a <comma> or\
\n<comma><space>, followed by a <comma> or <comma><space> delimited list of\
\nencryption methods and keys to rotate through, one per month.  TCP and UDP\
\nencryptions are allowed, as are multiple encryptions.\
\n  The template for each line after line 1 is:\
\n\nlabel<space>class n password<space>class n+1 password, etc.\
\n\n  Over- or under-encrypted OTPs are suggested to mask actual encryption level,\
\nor just use randomized character strings.\
\n  The server will initiate encryption handshaking only with a successful\
\nclient knocker.  Handshaking is as follows:  The server tells each successful\
\nknocker (client) what month-year their communication is taking place in.  Both\
\nends then negotiate the \"encryption of the month\".  The server then challenges\
\nthe client with a packet containing a label it chooses from the OTP list.  The\
\nclient must reply with the OTP associated with both that label and the access\
\nlevel they expect.  Sharing the set of OTPs between multiple devices is thus\
\naccommodated, as is security level assignment.\
\n  To make under-encrypted OTPs, run decryption on each non-encrypted OTP.  To\
\nover-encrypt, use OTPs that you've encrypted extra times beyond what your OTP\
\nlist specifies.";\
                   press_a_key;\
printf "\n\
\n\n  You may arrange for purchase and installation of client-side scripts (Linux/\
\nMac), programs (Linux/Mac/MS Windows/Android/iPhone), and OTP lists via email:\
\n\n                       kenlovesjesus at gmail dot com\
\n\n  Please allow for the possibility of some coding being done to order rather\
\nthan being ready made.  Most common payment forms welcome, and we will work\
\nwithin any reasonable purchasing protocol you need us to.  We try hard to speak\
\nto you on your level, novice to expert.\
\n  Developers: we encourage you to to create your own OTPs or client scripts and\
\nprograms.  We have tried to provide you with enough information to enable you to\
\ndo so, but if you need more, just ask us.  Be aware that actual client-side code\
\nis licensed under different terms and is charged for.\
\n  Homeowners: this project is being done with your Internet access, automation,\
\nsurveillance, and remote access needs in mind, so we welcome you! \n";\
continue)\
               || [[ "$REPLY" =~ n ]] \
               || ( [[ "$REPLY" =~ y ]] && (
#                      echo "Selected OTPs"
# Set up alert emails if not done already TODO: Make function, integrate better for answer scenarios
                   until [[ -f "$REPLY" ]];do
                        printf "\nEnter the name including absolute path of the OTP text file you're providing:\n"
#                   echo "Sorry, this feature is not yet finished..."
#                   press_a_key
                        read 
                        ! [[ -f "$REPLY" ]] && continue
                   done
                   cp "$REPLY" "$poofitee_home_dir"
                   continue
                   conf_postfix
                     )
                 )
            done
<<-HOLD_UNTIL_ABLE
\n  We can provide OTP lists to you for a nominal fee.  You just change/re-order\
\nthe labels, if you wish, to ensure your security.  Better yet for you, get\
\nthem yourself for FREE from online sources that advertise themselves as \"Ultra\
\nHigh Security Password Generator\"s.  Thank you...";
HOLD_UNTIL_ABLE
            until [[ "$REPLY" =~ [ls] ]]; do
             printf "Use loose (l) or strict (s) port knocking rules? (? for help) ";read -e -r -n1
             REPLY="${REPLY,}"
             [[ "$REPLY" == \? ]] && \
( printf "\
\n   Select 2-16 port-protocol combinations that you are demanding be \"knocked\" to\
\nestablish communication to this server.  The blacklist aspect of POOFITEE's\
\nfirewall records port-protocols that hackers probe your server with. Avoid those\
\n   l) loose knock rules are when you are permitting knocks to arrive here out of\
\nsequence or not arrive at all, given at least 4 valid port-protocol knocks, all\
\nunique from each other, do arrive.  Of course, to select this, you'll have to\
\nspecify a minimum of 4 port-protocol combinations, all unique from each other.\
\nThis option can reduce frustration for you if you consider yourself a low-value\
\ntarget for hackers and are taking all the other reasonable security measures\
\nanyway.  The order which you specify the port-protocol knocks in the sequence\
\nwill be irrelevant, and the 4 knocks must arrive in a total time frame of 12\
\nseconds times the total number of port-protocol combinations you specify. Knocks\
\non other ports during the knocking authentication period WILL BE ALLOWED.  The\
\nsource IP address sending the knocks will be indefintely authenticated in the\
\niptables whitelist until you manually remove it.\
\n   s) strict knock rules are conventional port knock rules where every port-\
\nprotocol knock must arrive in sequence with none missed.  NO OTHER PORT-PROTOCOL\
\nCOMBINATION ATTEMPTS MAY OCCUR DURING THE STRICT KNOCK-AUTHENTICATION PROCESS,\
\nbut you\'ll be allowed to specify non-unique port-protocols, even consecutively.\
\nSeven seconds maximum is allowed between each knock.  After the knock sequence\
\nis completed successfully, the knocking computer will be given only 17 seconds\
\nin which to establish valid communication, and the knock sequence must be\
\nrepeated for each future session.  ";press_a_key )
            done
            printf "\n\nSetting up port knocking.\
\nTip: For added obfuscation against packet-sniffing eavesdroppers, you can\
\nspecify any knock packet or packets to be disguised as an established connection\
\npacket rather than a knocking packet by replacing \"--syn\" with \"--tcp-flags ACK\
\nACK\".  Ideally, it would carry data you would craft that appears to be part of\
\nestablished-connection communication to help disguise it as a normal packet.\
\nYou could go so far as to require that specific byte string to be required in\
\nthat knock, but to generate such specialty knock packets will for sure require\
\nthe knocking client to use a packet-crafting tool.  Exactly for that scenario,\
\nthese rules will configure to reply to such a knock packet with a TCP RST packet\
\nto make the obfuscation less obvious.  (If you intend for your server to be\
\ninvisible, however, you probably don't want to require such a packet as the\
\nfirst knock because not only can and will your system be visible, its first\
\nknock port will also be giving itself away.  ACK knocks as described will only\
\nproduce server replies if the knocking computer is correctly knocking through\
\nthe sequence up to that point in the sequence.)  If you want to require ACK\
\nknocks but you don't want this server to reply to them at all, modify the iptables\
\nruleset accordingly after installation.\
\nTo specify the data you might require in a knock packet, include the following\
\nin the protocol:\
\n\n-m string --algo=bm --string \"bm-encrypted normal-looking data\"\n\n"

#write rules to iptables rule set
            if [[ $REPLY == "l" ]];then
                 if_first_knock_is_ACK_message=""
                 get_operator_knock_choices unique
                 for (( j=1;j<i;j++ )); do
                      printf "$iptablespath -w -A poofitee_knockstage$j${knockproto[$j]}\n"
                 done
printf "\n\nYour current iptables ruleset is about to be changed to reflect your knock\
\nentries just made.  The following changes are about to be made:\
\n\n  -- All INPUT chain rules will be removed that contain the string\
\n        \"poofitee_knock\" in their comment\
\n\n  -- INPUT chain will receive all new knock rules that belong there, being\
\n        placed adjacent and prior to current non-knock rules referencing the\
\n        respective interface\
\n\n  -- Poofitee chains knock_check, knock_new_knock, knock_portcustomexit,\
\n        and others will be created new\
\n\n  -- Poofitee chains knockerreap, knockersort, knockers, and all knockstages\
\n        will be de-referenced and abandoned without flushing.  They are only\
\n        used in the strict knock ruleset\
\n\nOnly continue if you are sure about making the changes.  To keep your current\
\niptables rules as they are, quit now by pressing ctl-c.  Otherwise, make the\
\nqueued changes by pressing any other key....\n";read -rsn 1;read -rst 0.001 -n3
                 j=$(($($iptablespath -w -nvL INPUT --line-number|$awkpath 'END {print $1}')))
                 for ((;j>0;j--)); do
                      [[ $($iptablespath -w -nvL INPUT $j 2>/dev/null) =~ poofitee_knock ]] && ([[ $($iptablespath -w -D INPUT $j 2>/dev/null;echo "$?") == "0" ]] && echo "Removed INPUT chain rule $j assuming it was from the previous, obsolete poofitee knock ruleset" || printf "Failed 5")
                 done
                 [[ $($iptablespath -w -N poofitee_knock_check 2>/dev/null;echo "$?") == "0" ]] || $iptablespath -w -F poofitee_knock_check 2>/dev/null
                 [[ $($iptablespath -w -N poofitee_knock_new_knock 2>/dev/null;echo "$?") == "0" ]] || $iptablespath -w -F poofitee_knock_new_knock 2>/dev/null
                 [[ $($iptablespath -w -N poofitee_knock_authorize 2>/dev/null;echo "$?") == "0" ]] || $iptablespath -w -F poofitee_knock_authorize 2>/dev/null
                 [[ $($iptablespath -w -N poofitee_knock_seniorize 2>/dev/null;echo "$?") == "0" ]] || $iptablespath -w -F poofitee_knock_seniorize 2>/dev/null
                 [[ $($iptablespath -w -N poofitee_knock_juniorize 2>/dev/null;echo "$?") == "0" ]] || $iptablespath -w -F poofitee_knock_juniorize 2>/dev/null
                 [[ $($iptablespath -w -N poofitee_knock_sophomorize 2>/dev/null;echo "$?") == "0" ]] || $iptablespath -w -F poofitee_knock_sophomorize 2>/dev/null
                 [[ $($iptablespath -w -N poofitee_knock_customexit 2>/dev/null;echo "$?") == "0" ]] || $iptablespath -w -F poofitee_knock_customexit 2>/dev/null
                 j=0
                 while ! [[ -z "${knockproto[$(($j + 1))]}" ]];do
                      j=$(( $j + 1 ))
                      [[ $($iptablespath -w -A poofitee_knock_check ${knockproto[$j]} -m recent --name poofitee_knock_port$j --rcheck -j RETURN;echo "$?") == "0" ]] || printf "Failed 1"
                 done
                 j=0
                 while ! [[ -z "${knockproto[$(($j + 1))]}" ]];do
                      j=$(( $j + 1 ))
                      [[ $($iptablespath -w -A poofitee_knock_check ${knockproto[$j]} -m recent --name poofitee_knock_port$j --set -j poofitee_knock_new_knock;echo "$?") == "0" ]] || printf "Failed 2"
                      [[ $($iptablespath -w -A poofitee_knock_customexit ${knockproto[$j]} ${testtarget[$j]};echo "$?") == "0" ]] || printf "Failed 3"
                 done
                 [[ $($iptablespath -w -A poofitee_knock_new_knock -m recent --name poofitee_knock_senior --rcheck --seconds $(( $j * 12 )) --reap -j poofitee_knock_authorize 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 7"
                 [[ $($iptablespath -w -A poofitee_knock_new_knock -m recent --name poofitee_knock_junior --rcheck --seconds $(( $j * 12 )) --reap -j poofitee_knock_seniorize 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 8"
                 [[ $($iptablespath -w -A poofitee_knock_new_knock -m recent --name poofitee_knock_sophomore --rcheck --seconds $(( $j * 12 )) --reap -j poofitee_knock_juniorize 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 9"
                 [[ $($iptablespath -w -A poofitee_knock_new_knock -m recent --name poofitee_knock_freshman --rcheck --seconds $(( $j * 12 )) --reap -j poofitee_knock_sophomorize 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 10"
                 [[ $($iptablespath -w -A poofitee_knock_new_knock -m comment --comment "poofitee_knock:This will schedule its blacklisting for couple mins from now" -m recent --name poofitee_knock_freshman --set -j LOG --log-prefix "poofitee knock freshman " 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 11"
                 [[ $($iptablespath -w -A poofitee_knock_new_knock -j poofitee_knock_customexit 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 12"
                 [[ $($iptablespath -w -A poofitee_knock_authorize -m recent --name poofitee_knock_authorized --set -j LOG --log-prefix "poofitee knock authorized whitelist" 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 13"
                 [[ $($iptablespath -w -A poofitee_knock_authorize -j poofitee_knock_customexit 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 14"
                 [[ $($iptablespath -w -A poofitee_knock_seniorize -m comment --comment "poofitee_knock" -m recent --name poofitee_knock_senior --set -j LOG --log-prefix "poofitee knock senior " 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 15"
                 [[ $($iptablespath -w -A poofitee_knock_seniorize -j poofitee_knock_customexit 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 16"
                 [[ $($iptablespath -w -A poofitee_knock_juniorize -m comment --comment "poofitee_knock" -m recent --name poofitee_knock_junior --set -j LOG --log-prefix "poofitee knock junior " 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 17"
                 [[ $($iptablespath -w -A poofitee_knock_juniorize -j poofitee_knock_customexit 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 18"
                 [[ $($iptablespath -w -A poofitee_knock_sophomorize -m comment --comment "poofitee_knock" -m recent --name poofitee_knock_sophomore --set -j LOG --log-prefix "poofitee knock sophomore " 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 19"
                 [[ $($iptablespath -w -A poofitee_knock_sophomorize -j poofitee_knock_customexit 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 20"
                 find_first_reference_to_internal_interface
                 if ! [[ -z "$likeliest_internal_net_interface" ]];then
                      [[ $($iptablespath -w -I INPUT $linenumber_for_inserting_before -i $likeliest_internal_net_interface -j poofitee_knock_check 2>/dev/null;echo "$?") == "0" ]] && linenumber_for_inserting_before=$(($linenumber_for_inserting_before + 1)) || printf "Failed 22"
                 fi
                 if [[ -z "$linenumber_for_inserting_before" ]];then
                      linenumber_for_inserting_before="1" #even though we may never use this var again
                      line_number_for_authorized_rule="1"
                 fi
                 [[ $($iptablespath -w -I INPUT $line_number_for_authorized_rule -m comment --comment "poofitee_knock loose rule" -m recent --name poofitee_authorized --rcheck --mask 255.255.255.255 -j ACCEPT 2>/dev/null;echo "$?") == "0" ]] && linenumber_for_inserting_before=$(( $linenumber_for_inserting_before + 1 )) || printf "Failed 19"
                 back_up_iptables_ruleset new && \
                      printf "Note that the file name is different than the one saved before" || \
                      ( printf "Your new iptables ruleset did NOT get backed up correctly.  You should\"
\ntroubleshoot the problem, correct it, and start this install over again.\n"; exit )
                 install_openall
                 install_firewall_cronentries
                 conf_postfix
            else
                 echo "Setting strict rules here"
                 if_first_knock_is_ACK_message="If you intend for your server to be invisible to the world, at least beyond the\
\nnext router, the best way to disguise a TCP ACK packet on the first knock is for\
\nthis server not to reply with the otherwise suggested tcp-reset rejection\
\nresponse, mostly because your system will forever be visible on that port to the\
\nworld, but also because its first port knock will be giving itself away.  Or you\
\nmay turn off the disguising tcp-reset reject reply for this knock only.  Press\
\n\'r\' to re-enter entire knock, or \'k\' to keep the reject response anyway (not\
\nadvised for minimum visibility). Any other key will turn off the reject response\
\nto this knock: (r/k/...)"
                 get_operator_knock_choices
                 for (( j=1;j<i;j++ )); do
                      printf "$iptablespath -w -A poofitee_knockstage$j${knockproto[$j]}\n"
                 done
                 printf "\n\nYour current iptables ruleset is about to be changed to reflect your knock\
\nentries just made.  The following changes are about to be made:\
\n\n  -- All INPUT chain rules will be removed that contain the string\
\n        \"poofitee_knock\" in their comment\
\n\n  -- INPUT chain will receive all new knock rules that belong there, being\
\n        placed adjacent and prior to current non-knock rules referencing the\
\n        respective interface\
\n\n  -- Poofitee chains knockerreap, knockersort, knockers, and all knockstages\
\n        will be created new\
\n\n  -- Poofitee chains knock_check, knock_new_knock, knock_portcustomexit,\
\n        and others will be de-referenced and abandoned.  They are only\
\n        used in the loose knock ruleset\
\n\nOnly continue if you are sure about making the changes.  To keep your current\
\niptables rules as they are, quit now by pressing ctl-c.  Otherwise, make the\
\nqueued changes by pressing any other key....\n";read -rsn 1;read -rst 0.001 -n3
                 $iptablespath -w -N poofitee_knockerreap 2>/dev/null # ;echo "$?") == "0" ]] || printf "Failed 1"
                 [[ $($iptablespath -w -F poofitee_knockerreap 2>/dev/null;echo "$?") == "0" ]] || (printf "Failed to flush poofitee_knockerreap chain rules";break)
                 $iptablespath -w -N poofitee_knockersort 2>/dev/null # ;echo "$?") == "0" ]] || printf "Failed 3"
                 [[ $($iptablespath -w -F poofitee_knockersort 2>/dev/null;echo "$?") == "0" ]] || (printf "Failed to flush poofitee_knockersort chain rules";break)
                 j=$(($($iptablespath -w -nvL INPUT --line-number|$awkpath 'END {print $1}')))
                 for ((;j>0;j--)); do
                      [[ "$($iptablespath -w -nvL INPUT $j 2>/dev/null)" =~ poofitee_knock ]] && ([[ $($iptablespath -w -D INPUT $j 2>/dev/null;echo "$?") == "0" ]] && echo "Removed INPUT chain rule $j assuming it was from the previous, obsolete poofitee knock ruleset"|| printf "Failed 5")
                 done
                 j=16  # here is the limit on number of knocks we can handle, just won't clear old ones above this
                 while [[ -z "${knockport[$j]}" ]];do
                      $iptablespath -w -F poofitee_knockstage$j 2>/dev/null
                      j=$(( $j-1 ))
                 done
                 j=0
                 while ! [[ -z "${knockport[$(($j + 1))]}" ]];do
                      j=$(( $j+1 ))
                      $iptablespath -w -N poofitee_knockstage$j 2>/dev/null # ;echo "$?") == "0" ]] || printf "Failed 6"
                      [[ $($iptablespath -w -F poofitee_knockstage$j 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 7"
                      if ! [[ "$j" == "1" ]];then
                           [[ $($iptablespath -w -A poofitee_knockersort ${knockproto[$j]} -m comment --comment "knock to stage $j successful" -m recent --name poofitee_knockstage$j --rcheck --seconds 12 -j poofitee_knockstage$j  2>/dev/null;echo "$?") == "0" ]] || printf "Failed 7.5"
                      fi
                      [[ $($iptablespath -w -I poofitee_knockstage$j -j poofitee_knockerreap;echo "$?") == "0" ]] || printf "Failed 9"
                      [[ $($iptablespath -w -I poofitee_knockstage$j 2 -m comment --comment "Entry in log makes blacklisting get delayed until after knocking time window expires" -m recent --name poofitee_knockstage$(( $j + 1 )) --set -j LOG --log-prefix "knocked: Stage$j ";echo "$?") == "0" ]] || printf "Failed 10"
#Here we put the right DROP or REJECT target in the third rule under this chain
                      [[ $($iptablespath -w -A poofitee_knockstage$j ${testtarget[$j]} ;echo "$?") == "0" ]] || printf "Failed 11"
                 done
                 i=$(( $j + 1 ))
                 while [[ $($iptablespath -w -F poofitee_knockstage$i 2>/dev/null;echo "$?") == "0" ]];do
                      i=$(( $i+1 ))
                 done
# start making rules here
                 $iptablespath -w -N poofitee_knockers 2>/dev/null # ;echo "$?") == "0" ]] || printf "Failed"
                 [[ $($iptablespath -w -F poofitee_knockers 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 12"
# for persistent whitelisting only
#                 [[ $($iptablespath -w -R poofitee_knockstage$j 2 -j LOG --log-prefix "whitelist " -m comment --comment "Entry in log to delay blacklisting until knocking time window expires" 2>/dev/null;echo "$?") == "0" ]] || printf "Failed"
                 [[ $($iptablespath -w -R poofitee_knockstage$j 2 -m comment --comment "allows 1 time-limited attempt to establish a dialog" -m recent --name poofitee_authorized --set -j LOG --log-prefix "knock full success whitelist" 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 12.5"
                 inchainoffset=0
                 find_first_reference_to_internal_interface
                 if ! [[ -z "$likeliest_internal_net_interface" ]];then
                      [[ $($iptablespath -w -I INPUT $linenumber_for_inserting_before -i $likeliest_internal_net_interface -m comment --comment "poofitee_knock" -m recent --name poofitee_knocker --seconds 60 --rcheck -j poofitee_knockerstest 2>/dev/null;echo "$?") == "0" ]] && linenumber_for_inserting_before=$(( $linenumber_for_inserting_before + 1 )) || printf "Failed 15"
                      [[ $($iptablespath -w -I INPUT $linenumber_for_inserting_before -i $likeliest_internal_net_interface ${knockproto[1]} -m comment --comment "poofitee_knock, 1st port" -m recent --set --name poofitee_knocker -j poofitee_knockstage1 2>/dev/null;echo "$?") == "0" ]] && linenumber_for_inserting_before=$(( $linenumber_for_inserting_before + 1 )) || printf "Failed 16"
#                      [[ $($iptablespath -w -I INPUT $linenumber_for_inserting_before -i $likeliest_internal_net_interface -j ACCEPT -m comment --comment "allow all from private side" 2>/dev/null;echo "$?") == "0" ]] && linenumber_for_inserting_before=$(( $linenumber_for_inserting_before + 1 )) || printf "Failed 17"
                      $iptablespath -w -A poofitee_knockerstest -j poofitee_knockersort
                      $iptablespath -w -A poofitee_knockerstest -j LOG --log-prefix "poofitee_knockertest fail "
                      $iptablespath -w -A poofitee_knockerstest -m recent --rcheck --seconds 200 --reap --name poofitee_knocker --mask 255.255.255.255 --rsource
                      $iptablespath -w -A poofitee_knockerstest -m recent --remove --name poofitee_knocker --mask 255.255.255.255 --rsource
                      $iptablespath -w -A poofitee_knockerstest -j poofitee_knockerreap
                      $iptablespath -w -A poofitee_knockerstest -j DROP
                 fi
                 if [[ -z "$linenumber_for_inserting_before" ]];then
                      linenumber_for_inserting_before="1"
                      line_number_for_authorized_rule="1"
                 fi
                 [[ $($iptablespath -w -I INPUT $line_number_for_authorized_rule -m comment --comment "poofitee_knock 1-packet pass: 1 chance to establish or then knock higher" -m recent --remove --name poofitee_authorized --mask 255.255.255.255 --rsource  -m conntrack --ctstate NEW -j ACCEPT 2>/dev/null;echo "$?") == "0" ]] && linenumber_for_inserting_before=$(( $linenumber_for_inserting_before + 1 )) || printf "Failed 19"
                 [[ $($iptablespath -w -I INPUT $linenumber_for_inserting_before -i $external_net_interface -m comment --comment "poofitee_knock" -m recent --name poofitee_knocker --seconds 200 --rcheck  -m conntrack --ctstate NEW -j poofitee_knockers 2>/dev/null;echo "$?") == "0" ]] && linenumber_for_inserting_before=$(( $linenumber_for_inserting_before + 1 )) || printf "Failed 18"
                 [[ $($iptablespath -w -I INPUT $linenumber_for_inserting_before -i $external_net_interface -m comment --comment "poofitee_knock, 1st port" -m conntrack --ctstate NEW ${knockproto[1]} -m recent --set --name poofitee_knocker -j poofitee_knockstage1 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 20"
                 [[ $($iptablespath -w -A poofitee_knockers -m conntrack ! --ctstate NEW -j poofitee_knockerreap -m comment --comment "poofitee_knock for port knock capability" 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 21"
                 [[ $($iptablespath -w -A poofitee_knockers -m conntrack --ctstate NEW -j poofitee_knockersort -m comment --comment "poofitee_knock for port knock capability" 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 22"
                 [[ $($iptablespath -w -A poofitee_knockers -j LOG --log-prefix "pktfail:knock|late|ctstate " 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 23"
                 [[ $($iptablespath -w -A poofitee_knockers -m recent --name poofitee_knocker --rcheck --reap --seconds 200 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 24"
                 [[ $($iptablespath -w -A poofitee_knockers -m recent --name poofitee_knocker --remove 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 25"
                 [[ $($iptablespath -w -A poofitee_knockers -j poofitee_knockerreap 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 26"
                 [[ $($iptablespath -w -A poofitee_knockers -j DROP 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 27"

                 [[ $($iptablespath -w -A poofitee_knockerreap -m recent --name poofitee_knocker --rcheck --reap --seconds 200 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 28"
                 for ((j=1;j<=i;j++));do
                      [[ $($iptablespath -w -A poofitee_knockerreap -m recent --name poofitee_knockstage$j --set  2>/dev/null;echo "$?") == "0" ]] || printf "Failed 29"
                 done
                 for ((j=1;j<=i;j++));do
                      [[ $($iptablespath -w -A poofitee_knockerreap -m recent --name poofitee_knockstage$j --rcheck  --reap --seconds 12 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 30"
                 done
                 for ((j=1;j<=i;j++));do
                      [[ $($iptablespath -w -A poofitee_knockerreap -m recent --name poofitee_knockstage$j --remove 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 31"
                 done
                 ################### HERE WOULD BE A DIFFERENT INSTALL AND LAUNCH THE CRON LINE, UNIQUE TO STRICT RULES B/C NO WHITELIST AND EMAIL FAILED AUTHS

            fi
printf "\nServer-side port knocking installed.\n"
#Now install the cron script line and the shell script it launches.
echo "$postfix_already_conf";exit
install_rc
get_sendto_emailadds
install_buildiptablessh
install_firewall_cronentries
} 
       install_buildiptablessh () {
#ipset list error on stderr when ipset not working due to?: ipset v6.29: Kernel error received: Invalid argument
printf "." # insert friendly progress indicators
if ! [ -d /etc/iptables ];then
     mkdir /etc/iptables
     chmod 755 /etc/iptables
fi
printf "." # insert friendly progress indicators
if [ -d /usr/share/netfilter-persistent/plugins.d ];then
     printf "." # insert friendly progress indicators
     (cat <<-EOF
#!/bin/sh

set -e

rc=0

load_rules()
{
        if [ ! -f /etc/iptables/ipset.sets ]; then
                echo "Warning: skipping IPv4 (no rules to load)"
        else
           # load rules made with ipset
           $ipsetpath restore -f /etc/iptables/ipset.sets 1>/tmp/fifos_and_temp_files_for_poofitee_installer/restor 2>/tmp/fifos_and_temp_files_for_poofitee_installer/restorerr 2>&1 ||  grep "already exists" < /tmp/fifos_and_temp_files_for_poofitee_installer/restorerr ||  grep "already exists" < /tmp/fifos_and_temp_files_for_poofitee_installer/restor
		if [ \$? -ne 0 ]; then
			rc=1
		fi
        fi
}

save_rules()
{
        # save rules made with ipset
        $ipsetpath save -f /etc/iptables/ipset.sets &>/dev/null
		if [ \$? -ne 0 ]; then
			rc=1
		fi
}

case "\$1" in
start|restart|reload|force-reload)
	load_rules
	;;
save)
	save_rules
	;;
esac

exit \$rc
	EOF
     ) > /usr/share/netfilter-persistent/plugins.d/14-poofitee-ip4tables
     printf "." # insert friendly progress indicators
     chmod 711 /usr/share/netfilter-persistent/plugins.d/14-poofitee-ip4tables
     printf "." # insert friendly progress indicators
# verify the following line inserts into correct location[s]
     if ! ($greppath ^pre-down\ /etc/init.d/netfilter-persistent\ save < /etc/network/interfaces &>/dev/null );then
          echo "pre-down /etc/init.d/netfilter-persistent save" >> /etc/network/interfaces
     fi
else
:
# here is where to configure persistence for iptables-persistent only
fi
printf "." # insert friendly progress indicators
REPLY=""
printf "." # insert friendly progress indicators
if ! [[ -z "$likeliest_internal_net_interface" ]] && [[ "$($greppath -c ^net.ipv4.ip_forward=1 </etc/sysctl.conf)" == "0" ]];then
printf "\n"
     cat <<-EOF
	This server is capable of being a firewall for an internal network, but you
	haven't enabled the forwarding feature needed in Linux, at least persisently.
	If you'd like, that $( [[ $iptables_masquerading == false ]] && printf "and the iptables MASQUERADE ")can be easily enough done for
	you right now, but IP address, routing tables, and DNAT in iptables POSTROUTING
	nat table configurations are left completely to you at this stage of POOFITEE
	development.

	Would you like to enable IP forwarding persistently and have iptables masquerade
	your internal network so it has Internet access? y/n:
	EOF
     read -rn1;read -rsn3 -t 0.001 discard
     printf "." # insert friendly progress indicators
     if [[ $REPLY =~ [Yy] ]];then
          printf "." # insert friendly progress indicators
          echo 1 > /proc/sys/net/ipv4/ip_forward
          printf "." # insert friendly progress indicators
          $sedpath -i 's/^#*net.ipv4.ip_forward=.*/net.ipv4.ip_forward=1/g' /etc/sysctl.conf
          printf "." # insert friendly progress indicators
          [[ "$($greppath -c ^net.ipv4.ip_forward=1 </etc/sysctl.conf)" == "0" ]] && echo "net.ipv4.ip_forward=1" >> /etc/sysctl.conf
          printf "." # insert friendly progress indicators
          [[ $iptables_masquerading == false ]] && ([[ "$($iptablespath -w -t nat -I POSTROUTING 1  -o $external_net_interface  -p all -j MASQUERADE -m comment --comment "poofitee_fw by installer request during installation";echo $?)" == "0" ]] || printf "\n\nUnable to make the change in iptables")
          printf "." # insert friendly progress indicators
     fi
     printf "." # insert friendly progress indicators
fi
printf "." # insert friendly progress indicators
$ipsetpath create poofitee_blacklist hash:ip comment &>/dev/null
printf "." # insert friendly progress indicators
$ipsetpath create poofitee_whitelist hash:ip comment &>/dev/null
printf "." # insert friendly progress indicators
$ipsetpath create poofitee_static_trusted hash:ip comment &>/dev/null
printf "." # insert friendly progress indicators
$ipsetpath create poofitee_static_trusted_cidr hash:net comment &>/dev/null
printf "." # insert friendly progress indicators
$ipsetpath create poofitee_stat_trustd_cidr_sockt hash:net,port comment &>/dev/null
printf "." # insert friendly progress indicators
$ipsetpath create poofitee_blacklist_cidr hash:net comment &>/dev/null
printf "." # insert friendly progress indicators
$ipsetpath create poofitee_full_bogons_cidr hash:net comment &>/dev/null
printf "." # insert friendly progress indicators
$ipsetpath create poofitee_bogons,privateIPs_cidr hash:net maxelem 13 hashsize 64 &>/dev/null
printf "." # insert friendly progress indicators
$ipsetpath create poofitee_publicports6000-7999  bitmap:port range 6000-7999 comment &>/dev/null # for servers hosting irc, servers not hosting irc won't have the log file
printf "." # insert friendly progress indicators
$iptablespath -w -P OUTPUT ACCEPT
printf "." # insert friendly progress indicators

	# These will all go after any and all existing rules, so the order will be totally unpredictable if only some of these get installed, or if there are existing non-poofitee rules
	#  TODO:  warn installer in that case
#  preload default router and dns name server, etc into ipset poofitee_static_trusted, all addresses that show up in ip route output, /etc/resolv.conf, /etc/network/interfaces, etc, etc.
($ippath route;cat /etc/resolv.conf /etc/network/interfaces)|\
     $greppath -Eo '((([1-9]|[1-9][0-9]|1[0-9])?[0-9]|2[0-4][0-9]|25[0-5])\.){3}(1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])((/[0-2]?[0-9])|(/3[0-2]))?'|\
     while read ipadd;do
           if [[ $ipadd =~ / ]];then
                ipset add poofitee_static_trusted_cidr $ipadd comment "$(date) installer detected as trusted" &>/dev/null
           else
                ipset add poofitee_static_trusted $ipadd comment "$(date) installer detected as trusted" &>/dev/null
           fi
     done
#	! [ -z "$likeliest_internal_net_interface" ] && ! ($iptablespath -w -nvL INPUT|$greppath -- " ACCEPT     all  --  $likeliest_internal_net_interface"                                  |$greppath "poofitee_fw") >/dev/null && ($iptablespath -w -A INPUT -i $likeliest_internal_net_interface -j ACCEPT -m comment --comment "poofitee_fw"  >/dev/null 2>/dev/null || printf "Failed a")
! [ -z "$likeliest_internal_net_interface" ] && ! ($iptablespath -w -nvL INPUT|$greppath -- " ACCEPT     all  --  $likeliest_internal_net_interface"                                         |$greppath "poofitee_fw") >/dev/null && ($iptablespath -w -A INPUT -i $likeliest_internal_net_interface -j ACCEPT -m comment --comment "poofitee_fw" &>/dev/null || printf "Failed a")
printf "." # insert friendly progress indicators
! ($iptablespath -w -nvL INPUT                         |$greppath -- " ACCEPT     all  --  lo  "                                                                                                                     ) >/dev/null && ($iptablespath -w -A INPUT -i lo -m comment --comment "poofitee_fw we really have to trust localhost at this level" -j ACCEPT &>/dev/null || printf "Failed b")
printf "." # insert friendly progress indicators
! ($iptablespath -w -nvL INPUT                         |$greppath -- " ACCEPT     all  --  "                                                             |$greppath -- " RELATED,ESTABLISHED"|$greppath "poofitee_fw") >/dev/null && ($iptablespath -w -A INPUT -m comment --comment "poofitee_fw existing dialogs traffic presumed trusted" -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT &>/dev/null || printf "Failed c")
printf "." # insert friendly progress indicators
! ($iptablespath -w -nvL INPUT                         |$greppath -- " ACCEPT     all  --  $external_net_interface"                    |$greppath -- " match-set poofitee_static_trusted src"|$greppath "poofitee_fw") >/dev/null && ($iptablespath -w -A INPUT -i $external_net_interface -m comment --comment "poofitee_fw" -m set --match-set poofitee_static_trusted src -j ACCEPT &>/dev/null || printf "Failed d")
printf "." # insert friendly progress indicators
! ($iptablespath -w -nvL INPUT                         |$greppath -- " ACCEPT     all  --  $external_net_interface"               |$greppath -- " match-set poofitee_static_trusted_cidr src"|$greppath "poofitee_fw") >/dev/null && ($iptablespath -w -A INPUT -i $external_net_interface -m comment --comment "poofitee_fw" -m set --match-set poofitee_static_trusted_cidr src -j ACCEPT &>/dev/null || printf "Failed d")
printf "." # insert friendly progress indicators
! ($iptablespath -w -nvL INPUT                         |$greppath -- " ACCEPT     all  --  $external_net_interface"                         |$greppath -- " match-set poofitee_whitelist src"|$greppath "poofitee_fw") >/dev/null && ($iptablespath -w -A INPUT -i $external_net_interface -m comment --comment "poofitee_fw" -m set --match-set poofitee_whitelist src -j ACCEPT &>/dev/null || printf "Failed e")
printf "." # insert friendly progress indicators
# raw tables target should never be ACCEPT because nat will be thwarted.  Make it RETURN instead.
! ($iptablespath -w -nvL PREROUTING -t raw             |$greppath -- " RETURN     all  --  \*"                                                           |$greppath -- " RELATED,ESTABLISHED"|$greppath "poofitee_fw") >/dev/null && ($iptablespath -w -A PREROUTING -t raw -j RETURN -m comment --comment "poofitee_fw" -m conntrack --ctstate RELATED,ESTABLISHED &>/dev/null || printf "Failed e1")
printf "." # insert friendly progress indicators
! ($iptablespath -w -nvL PREROUTING -t raw             |$greppath -- " DROP       all  --  $external_net_interface"            |$greppath -- " match-set poofitee_bogons,privateIPs_cidr src"|$greppath "poofitee_fw") >/dev/null && ($iptablespath -w -A PREROUTING -t raw -i $external_net_interface -m comment --comment "poofitee_fw" -m set --match-set poofitee_bogons,privateIPs_cidr src -j DROP &>/dev/null || printf "Failed f")
printf "." # insert friendly progress indicators
! ($iptablespath -w -nvL PREROUTING -t raw             |$greppath -- " DROP       all  --  $external_net_interface"                  |$greppath -- " match-set poofitee_full_bogons_cidr src"|$greppath "poofitee_fw") >/dev/null && ($iptablespath -w -A PREROUTING -t raw -i $external_net_interface -m comment --comment "poofitee_fw" -m set --match-set poofitee_full_bogons_cidr src -j DROP &>/dev/null || printf "Failed f1")
printf "." # insert friendly progress indicators
! ($iptablespath -w -nvL PREROUTING -t raw             |$greppath -- " DROP       all  --  $external_net_interface"                    |$greppath -- " match-set poofitee_blacklist_cidr src"|$greppath "poofitee_fw") >/dev/null && ($iptablespath -w -A PREROUTING -t raw -i $external_net_interface -m comment --comment "poofitee_fw" -m set --match-set poofitee_blacklist_cidr src -j DROP &>/dev/null || printf "Failed g")
printf "." # insert friendly progress indicators
! ($iptablespath -w -nvL PREROUTING -t raw             |$greppath -- " DROP       all  --  $external_net_interface"                         |$greppath -- " match-set poofitee_blacklist src"|$greppath "poofitee_fw") >/dev/null && ($iptablespath -w -A PREROUTING -t raw -i $external_net_interface -m comment --comment "poofitee_fw" -m set --match-set poofitee_blacklist src -j DROP &>/dev/null || printf "Failed g1")
printf "." # insert friendly progress indicators
! ($iptablespath -w -nvL INPUT                         |$greppath -- " LOG        all  --  "                           |$greppath -- " --log-level 4 --log-prefix \"poofitee_fw blacklist\""|$greppath "poofitee_fw") >/dev/null && ($iptablespath -w -A INPUT -i $external_net_interface -m comment --comment "poofitee_fw" -j LOG --log-level 4 --log-prefix "poofitee_fw blacklist " &>/dev/null || printf "Failed h")
printf "." # insert friendly progress indicators
! ($iptablespath -w -nvL INPUT                         |$greppath -- " DROP       all  --  "                                                                      |$greppath -v " match-set "|$greppath "poofitee_fw") >/dev/null && ($iptablespath -w -A INPUT -i $external_net_interface -m comment --comment "poofitee_fw" -j DROP &>/dev/null || printf "Failed i")
printf "." # insert friendly progress indicators
#The below lines are for templates the owner/admin can copy techjnique
$ipsetpath add poofitee_static_trusted_cidr 91.189.88.0/21 comment "Canonical" &>/dev/null
printf "." # insert friendly progress indicators
$ipsetpath add poofitee_static_trusted 199.102.46.70 comment "local time server hosted by Monticello" &>/dev/null
printf "." # insert friendly progress indicators

! ($iptablespath -w -nvL OUTPUT                        |$greppath -- " ACCEPT     all  --  "                                                             |$greppath -- " RELATED,ESTABLISHED"|$greppath "poofitee_fw") >/dev/null && ($iptablespath -w -A OUTPUT -m comment --comment "poofitee_fw existing dialogs traffic presumed trusted" -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT &>/dev/null || printf "Failed j")
printf "." # insert friendly progress indicators
! ($iptablespath -w -nvL OUTPUT                        |$greppath -- " ACCEPT     all  --  "                                           |$greppath -- " match-set poofitee_static_trusted dst"|$greppath "poofitee_fw") >/dev/null && ($iptablespath -w -A OUTPUT -m comment --comment "poofitee_fw" -m set --match-set poofitee_static_trusted dst -j ACCEPT &>/dev/null || printf "Failed k")
printf "." # insert friendly progress indicators
! ($iptablespath -w -nvL INPUT                         |$greppath -- " ACCEPT     all  --  "                                      |$greppath -- " match-set poofitee_static_trusted_cidr dst"|$greppath "poofitee_fw") >/dev/null && ($iptablespath -w -A OUTPUT -m comment --comment "poofitee_fw" -m set --match-set poofitee_static_trusted_cidr dst -j ACCEPT &>/dev/null || printf "Failed l")
printf "." # insert friendly progress indicators
! ($iptablespath -w -nvL OUTPUT                        |$greppath -- " ACCEPT     all  --  "                                                |$greppath -- " match-set poofitee_whitelist dst"|$greppath "poofitee_fw") >/dev/null && ($iptablespath -w -A OUTPUT -m comment --comment "poofitee_fw" -m set --match-set poofitee_whitelist dst -j ACCEPT &>/dev/null || printf "Failed l1")
printf "." # insert friendly progress indicators
! ($iptablespath -w -nvL OUTPUT                        |$greppath -- " DROP       all  --  "                                                |$greppath -- " match-set poofitee_blacklist dst"|$greppath "poofitee_fw") >/dev/null && ($iptablespath -w -A OUTPUT -m comment --comment "poofitee_fw" -m set --match-set poofitee_blacklist dst -j DROP &>/dev/null || printf "Failed m")
printf "." # insert friendly progress indicators
! ($iptablespath -w -nvL OUTPUT                        |$greppath -- " DROP       all  --  "                                           |$greppath -- " match-set poofitee_blacklist_cidr dst"|$greppath "poofitee_fw") >/dev/null && ($iptablespath -w -A OUTPUT -m comment --comment "poofitee_fw" -m set --match-set poofitee_blacklist dst -j DROP &>/dev/null || printf "Failed m1")
printf "." # insert friendly progress indicators
! ($iptablespath -w -nvL OUTPUT                        |$greppath -- " DROP       all  --  \*      $external_net_interface"    |$greppath -- " match-set poofitee_bogons,privateIPs_cidr dst"|$greppath "poofitee_fw") >/dev/null && ($iptablespath -w -A OUTPUT -o $external_net_interface -m comment --comment "poofitee_fw" -m set --match-set poofitee_bogons,privateIPs_cidr dst -j DROP &>/dev/null || printf "Failed n")
printf "." # insert friendly progress indicators
! ($iptablespath -w -nvL OUTPUT                        |$greppath -- " DROP       all  --  \*            $external_net_interface"    |$greppath -- " match-set poofitee_full_bogons_cidr dst"|$greppath "poofitee_fw") >/dev/null && ($iptablespath -w -A OUTPUT -o $external_net_interface -m comment --comment "poofitee_fw" -m set --match-set poofitee_full_bogons_cidr dst -j DROP &>/dev/null || printf "Failed n1")
printf "." # insert friendly progress indicators
read -n3 -t 0.001 discard
printf "." # insert friendly progress indicators
if ! [[ -z $likeliest_internal_net_interface ]] && [[ $(cat /proc/sys/net/ipv4/ip_forward) == "1" ]] && ! [[ $iptables_masquerading == false ]];then
     printf "." # insert friendly progress indicators
     # TODO:  get next line working instead of line above
     #if ! [[ -z $likeliest_internal_net_interface ]] && [[ $(cat /proc/sys/net/ipv4/ip_forward) == "1" ]] && [[ $ifconfigpath == ]] && ! [[ $iptables_masquerading == false ]];then

     # TODO:  get next commented section working
     # if [[ $REPLY =~ [Yy] ]] || [[ "$(hostname -I)" =~ \  ]] #has more than one ip address, ask about enabling routing
     # "$(hostname -I|$sedpath 's/\ /\n/g')" see if any are private range
     #  hostname -I enumerates and outs space-delimited list of all configured addresses of all network interfaces
     #    $iptablespath -w -t nat -I POSTROUTING 1  -o $external_net_interface  -p all -j MASQUERADE -m comment --comment "poofitee_fw"

     #remove masquerading statement above
     #get the ip address of $likeliest_internal_net_interface from ip route or ifconfig or ipconfig to see which ones need masquerading.  Either way, routing tables may need to be set up as well as ....
     #     [[ "$($iptablespath -w -nvL POSTROUTING -t nat)" =~ MASQUERADE.*$external_net_interface ]] && \
     #          iptables_masquerading=true \ 
     #          || iptables_masquerading=false
     #  TODO: First we should remove already existing poofitee_fw rules as line below is supposed to do
     #$iptablespath -w -nvL FORWARD --line-number|$greppath poofitee|$awkpath '{print $1}'|$sortpath -r|while read linenum;do $iptablespath -w -D FORWARD $linenum;done
     # using ipsets without spec-ing the interface has not been tested
     printf "." # insert friendly progress indicators
     ! ($iptablespath -w -nvL FORWARD                       |$greppath -- " ACCEPT     all  --  "                                  |$greppath -- " match-set poofitee_static_trusted src,dst"|$greppath "poofitee_fw") >/dev/null && ($iptablespath -w -A FORWARD -m comment --comment "poofitee_fw" -m set --match-set poofitee_static_trusted src,dst -j ACCEPT &>/dev/null || printf "Failed")
     #! ($iptablespath -w -nvL FORWARD                       |$greppath -- " ACCEPT     all  --  $external_net_interface"                    |$greppath -- " match-set whitelist src"|$greppath "poofitee_fw") && ($iptablespath -w -A FORWARD -i $external_net_interface -m comment --comment "poofitee_fw" -m set --match-set poofite_whitelist src -j ACCEPT &>/dev/null || printf "Failed")
     printf "." # insert friendly progress indicators
     ! ($iptablespath -w -nvL FORWARD                       |$greppath -- " ACCEPT     all  --  "                                       |$greppath -- " match-set poofitee_whitelist src,dst"|$greppath "poofitee_fw") >/dev/null && ($iptablespath -w -A FORWARD -m comment --comment "poofitee_fw" -m set --match-set poofitee_whitelist src,dst -j ACCEPT &>/dev/null || printf "Failed")
     printf "." # insert friendly progress indicators
     ! ($iptablespath -w -nvL FORWARD                       |$greppath -- " DROP       all  --  $external_net_interface"                   |$greppath -- " match-set poofitee_bogons,privateIPs_cidr src"|$greppath "poofitee_fw") >/dev/null && ($iptablespath -w -A FORWARD -i $external_net_interface -m comment --comment "poofitee_fw" -m set --match-set poofitee_bogons,privateIPs_cidr src -j DROP &>/dev/null || printf "Failed")
     printf "." # insert friendly progress indicators
     ! ($iptablespath -w -nvL FORWARD                       |$greppath -- " DROP       all  --  \*      $external_net_interface"           |$greppath -- " match-set poofitee_bogons,privateIPs_cidr dst"|$greppath "poofitee_fw") >/dev/null && ($iptablespath -w -A FORWARD -o $external_net_interface -m comment --comment "poofitee_fw" -m set --match-set poofitee_bogons,privateIPs_cidr dst -j DROP &>/dev/null || printf "Failed")
     printf "." # insert friendly progress indicators
     ! ($iptablespath -w -nvL FORWARD                       |$greppath -- " DROP       all  --  \*      \*"                             |$greppath -- " match-set poofitee_blacklist src,dst"|$greppath "poofitee_fw") >/dev/null && ($iptablespath -w -A FORWARD -m comment --comment "poofitee_fw" -m set --match-set poofitee_blacklist src,dst -j DROP &>/dev/null || printf "Failed")
     printf "." # insert friendly progress indicators
     ! ($iptablespath -w -nvL FORWARD                       |$greppath -- " DROP       all  --  \*      \*"                             |$greppath -- " match-set poofitee_blacklist_cidr src,dst"|$greppath "poofitee_fw") >/dev/null && ($iptablespath -w -A FORWARD -m comment --comment "poofitee_fw" -m set --match-set poofitee_blacklist_cidr src,dst -j DROP &>/dev/null || printf "Failed")
     printf "." # insert friendly progress indicators
     ! ($iptablespath -w -nvL FORWARD                       |$greppath -- " LOG        all  --  "              |$greppath -- " --log-level 4 --log-prefix \"FORWARD chain termed \""|$greppath "poofitee_fw") >/dev/null && ($iptablespath -w -A FORWARD -m comment --comment "poofitee_fw" -j LOG --log-level 4 --log-prefix "FORWARD chain termed " &>/dev/null || printf "Failed")
     printf "." # insert friendly progress indicators
     ! ($iptablespath -w -nvL FORWARD                       |$greppath -- " DROP       all  --  "                                                        |$greppath -v " match-set "|$greppath "poofitee_fw") >/dev/null && ($iptablespath -w -A INPUT -j DROP -m comment --comment "poofitee_fw" &>/dev/null || printf "Failed")
     printf "." # insert friendly progress indicators
fi
printf "." # insert friendly progress indicators
adjust_for_private_ip
printf "." # insert friendly progress indicators
$ipsetpath add poofitee_bogons,privateIPs_cidr 0.0.0.0/8 &>/dev/null
printf "." # insert friendly progress indicators
$ipsetpath add poofitee_bogons,privateIPs_cidr 100.64.0.0/10 &>/dev/null
printf "." # insert friendly progress indicators
$ipsetpath add poofitee_bogons,privateIPs_cidr 127.0.0.0/8 &>/dev/null
printf "." # insert friendly progress indicators
$ipsetpath add poofitee_bogons,privateIPs_cidr 169.254.0.0/16 &>/dev/null
printf "." # insert friendly progress indicators
$ipsetpath add poofitee_bogons,privateIPs_cidr 192.0.0.0/24 &>/dev/null
printf "." # insert friendly progress indicators
$ipsetpath add poofitee_bogons,privateIPs_cidr 192.0.2.0/24 &>/dev/null
printf "." # insert friendly progress indicators
$ipsetpath add poofitee_bogons,privateIPs_cidr 198.18.0.0/15 &>/dev/null
printf "." # insert friendly progress indicators
$ipsetpath add poofitee_bogons,privateIPs_cidr 198.51.100.0/24 &>/dev/null
printf "." # insert friendly progress indicators
$ipsetpath add poofitee_bogons,privateIPs_cidr 203.0.113.0/24 &>/dev/null
printf "." # insert friendly progress indicators
$ipsetpath add poofitee_bogons,privateIPs_cidr 224.0.0.0/4 &>/dev/null
printf "." # insert friendly progress indicators
$ipsetpath add poofitee_bogons,privateIPs_cidr 240.0.0.0/4 &>/dev/null
printf "." # insert friendly progress indicators
<<-EOF
CIDRs to blacklist in some fashion on a specific interface in most, but not all, scenarios.
0.0.0.0/8
100.64.0.0/10
127.0.0.0/8
169.254.0.0/16
192.0.0.0/24
192.0.2.0/24
198.18.0.0/15
198.51.100.0/24
203.0.113.0/24
224.0.0.0/4
240.0.0.0/4

a bogon test file updated often : http://www.team-cymru.org/Services/Bogons/fullbogons-ipv4.txt, but private ip range[s] must be removed if the external-facing interface is a private ip

EOF

#echo
#  TODO: assist-load current ACCEPT lines list here
#  TODO:  script a tool to allow owners to specify ports for public services.  Rate Limit those users 3-5/min connect attempts, I guess
<<SANDBOX
$iptablespath -w -N poofitee_fw_publics
$iptablespath -w -A poofitee_fw_publics -p all -j poofitee_fw_s_reallybad
$iptablespath -w -A poofitee_fw_publics -p all -j poofitee_fw_d_reallybad
$iptablespath -w -A poofitee_fw_publics -p tcp --dport 20:22 -j poofitee_fw_publics
$iptablespath -w -A poofitee_fw_publics -p all --dport 6660:7020 -j poofitee_fw_publics
$iptablespath -w -A poofitee_fw_publics -p all --dport 9996:9999 -j poofitee_fw_publics
$iptablespath -w -A poofitee_fw_publics -p tcp -m multiport --dports 23,80,17855,8080,443,465,993,995,25,110 -j poofitee_fw_publics
established user of public services
first-timer of public services must not be in either blacklist,  source address be put in recent list to bypass general blacklist check (allow quicker access for authentication)
--blacklisting command will be scheduled for now+x minutes, (scheduled command includes check for inclusion in specific whitelist) and
--successful entrants will be whitelisted for that service and not have to get checked for blacklist presence
--failures will get blacklisted in which blacklist?  General one is fine as long as they are removed from recent list?  How to remove via script from recent list?  Must do so through file system? /proc/net/xt_recent
if fw_publics traffic is blacklisted generally, make it unable to get whitelisted
How acceptable source IP addresses are determined:

technique to identify authorized sources:
   legitimate traffic must be characterized by initiator (should be an inside source address), packet frequency (higher means time window is right to assume authorized person is attempting to communicate)
   when initiator is on the outside and could be from anywhere, just make sure they don't hit ANY other ports than they should or they get banished forever, but their source address must also get whitelisted within x minutes by some log file activity
HTTP TCP 80
IRCD TCP/UDP 6660-7020  unreal
OpenSSL TCP/UDP 9996-9999
Router-Access TCP 8080
HTTPS TCP 443
SMTPS TCP 465 postfix
IMAPS TCP 993
POP3S TCP 995
SMTP TCP 25, from 25 as well! the same for some others of these ports
POP3 TCP 110
206.174.118.125
kodiak - owner-only ssh+
nickserv
anope
SANDBOX
}
       conf_postfix () {
! [[ -z "$postfix_already_conf" ]] && return
# See https://www.linode.com/docs/email/postfix/postfix-smtp-debian7
while true;do
     clear;printf "$( [[ -z $sendmail_works ]] && echo "Three" || echo "Two more" ) emailing functions need email addresses.  Provide at least one email\
\naddress now.  The address[es] asked for now is/are the one or more that will\
\nreceive the various notifications sent out by this system.  Commonly, this would\
\nbe at least two addresses - one for a text message to a cell phone, the other an\
\nemail account from which you'll read the FULL content of the notification, since\
\ncell phone carriers often limit the length of email-to-texting conversion,\
\ncutting short the longer texts."
     printf "\n\nAddress[es] where to send notifications to (enter an empty line to end):\n\n"
     get_sendto_emailadds
done
if [[ -z $sendmail_works ]];then
              printf "\nNow, a single email address with its password is needed for an outgoing email\
\nserver somewhere to authenticate the outgoing email traffic (it's come to this\
\nbecause of spammers).  Enter now the email account name to use for an outgoing\
\nemail server based on its ability to accept sign-on through this scripting\
\nyou're installing.  Preferably not too strict accepting sign-on because this\
\nscript uses the mid-tier security of standard smtp protocol (your email\
\ncredentials, including password, are stored in this scripting and sent encrypted\
\nbut via standard smtp protocol) rather than upper-tier security (\"OAuth 2.0\" -\
\ncredentials entered on a web page that only a real human can reliably determine\
\nwhere on the screen to enter the credentials today, which may be different from\
\nyesterday.  It also includes a sort of dynamic security key exchange not\
\navailable via standard smtp protocol).  NOTE - this email account may be the\
\nsame or different from the one that the notices get sent to.  We can test and\
\ncompare suitability repeatedly, so you may select from all your accounts which\
\none this scripting is most able to sign into (use up/down arrow keys, or enter a\
\nnew name entirely).  SUGGESTION: If reading this has made you suspicious to give\
\nyour real email password to this script ( hopefully so! ), create a NEW account\
\nwith a provider such as gmail that will allow logins from \"less secure apps\" on\
\na per-account basis (gmail does), set it up to allow such logins.  (You'll use\
\nthat NEW account for this script's outgoing email authentication needs.)  Then\
\nresume here and enter that account name and password.  That same account could\
\nalso be dedicated for this scripting to read commands emailed from you for it to\
\nbe remote controlled:\n"
create_tmp_timeouttry_script
while true;do  #this loop allows user to change the email account for outbound server & builds connect.txt file
     while true; do #this loop forces an address to be chosen from the bunch, then goes through all connections found for it
          [[ -z "$outemailadd" ]] && outemailadd=$(cat "$poofitee_home_dir/outemailadd" 2>/dev/null)
          bunch=""
          ! [[ -z "$outemailadd" ]] && bunch="$outemailadd"
          (! [[ -z "$bunch" ]] && ! [[ "${bunch,, -2}" == "\n" ]] && ! [[ -z "$toemailadds" ]]) && bunch+="\n"
          ! [[ -z "$toemailadds" ]] && bunch+="$toemailadds"
          (! [[ -z "$bunch" ]] && ! [[ "${bunch,, -2}" == "\n" ]] && ! [[ -z "$inemailadd" ]]) && bunch+="\n"
          ! [[ -z "$inemailadd" ]] && bunch+="$inemailadd"
          get_1_addr_from_bunch "$bunch"
          outemailadd="$emailadd";outemailacct="$emailacct";outemaildomain="$emaildomain";outtopdomain="$topdomain";outemailprovider="$emailprovider";outemailpw="$emailpw"
          printf "determining best option for outgoing email server login.  You should be doing\
\nthis step from the Internet location of final operation if you have/want your\
\nlocal ISP-provided email account considered for your outgoing email server...\n"
          [[ -f "$poofitee_home_dir/$outemailprovider.outconnects.txt" ]] \
             && rm "$poofitee_home_dir/$outemailprovider.outconnects.txt" 2>/dev/null
          printf  "\rYou selected address $outemailadd \033[K\nPlease wait for analysis of the best port and protocol setting...\n"
          ensure_connection
          for MAIL_PROT in smtp mail;do
               for port in 587 25 2587 26 2525 25025 2526 3325 465 995 110 993 143;do
                    printf "\rChecking $MAIL_PROT.$outemailprovider:$port\033[K";
                    (/tmp/fifos_and_temp_files_for_poofitee_installer/timeouttry.sh -t 2 "exec 5>&-;exec 5<>/dev/tcp/$MAIL_PROT.$outemailprovider/$port;read -u 5 HELO;! [[ -z \$HELO ]] && echo \"$MAIL_PROT:$port\" >> \"$poofitee_home_dir/$outemailprovider.outconnects.txt\";printf \"quit\" >&5;read -t 2 -u 5 QUIT;exec 5>&-")
               done  2> /dev/null
          done
          if [[ -f "$poofitee_home_dir/$outemailprovider.outconnects.txt" ]];then
               printf "\rThe possibilities are\033[K\n$(<"$poofitee_home_dir/$outemailprovider.outconnects.txt")\
\nplease wait...\n"
               break
          else
               printf "\r\033[K\033[1ASelected email provider doesn't allow logins.  Enter a different account...\n"
          fi
     done
     while read -u 3 -r line;do #? this while loop iterates once for each port that accepted a smtp connection for outgoing email
          chmod 644 /etc/postfix/main.cf
          [[ "$($greppath -c ^myhostname </etc/postfix/main.cf)" == "0" ]] \
              && printf "myhostname = ""$(hostname)" >> /etc/postfix/main.cf \
              || $sedpath -i 's/^myhostname.*/myhostname = '"$(hostname)"'/g' /etc/postfix/main.cf
          [[ "$($greppath -c ^relayhost </etc/postfix/main.cf)" == "0" ]] \
              && printf "relayhost = ["${line%:*}"."$outemailprovider"]:"${line#*:} >> /etc/postfix/main.cf \
              || $sedpath -i 's/^relayhost.*/relayhost = ['"${line%:*}.$outemailprovider]:${line#*:}"'/g' /etc/postfix/main.cf
          [[ "$($greppath -c ^mech_list: cram-md5 </etc/postfix/sasl/smtpd.conf)" == "0" ]] \
              && printf "mech_list: cram-md5" >> /etc/postfix/sasl/smtpd.conf
          [[ "$($greppath -c ^smtp_sasl_auth_enable </etc/postfix/main.cf)" == "0" ]] \
              && printf "smtp_sasl_auth_enable = yes" >> /etc/postfix/main.cf \
              || $sedpath -i 's/^smtp_sasl_auth_enable.*/smtp_sasl_auth_enable = yes/g' /etc/postfix/main.cf
          [[ "$($greppath -c ^smtp_sasl_security_options </etc/postfix/main.cf)" == "0" ]] \
              && printf "smtp_sasl_security_options = noanonymous" >> /etc/postfix/main.cf \
              || $sedpath -i 's/^smtp_sasl_security_options.*/smtp_sasl_security_options = noanonymous/g' /etc/postfix/main.cf
          [[ "$($greppath -c ^smtp_sasl_password_maps </etc/postfix/main.cf)" == "0" ]] \
              && printf "smtp_sasl_password_maps = hash:/etc/postfix/sasl_passwd" >> /etc/postfix/main.cf \
              || $sedpath -i 's/^smtp_sasl_password_maps.*/smtp_sasl_password_maps = hash:\/etc\/postfix\/sasl_passwd/g' /etc/postfix/main.cf
          [[ "$($greppath -c ^smtp_tls_security_level </etc/postfix/main.cf)" == "0" ]] \
              && printf "smtp_tls_security_level = encrypt" >> /etc/postfix/main.cf \
              || $sedpath -i 's/^smtp_tls_security_level.*/smtp_tls_security_level = encrypt/g' /etc/postfix/main.cf
          [[ "$($greppath -c ^smtp_tls_CAfile </etc/postfix/main.cf)" == "0" ]] \
              && printf "smtp_tls_CAfile = /etc/postfix/cacert.pem" >> /etc/postfix/main.cf \
              || $sedpath -i 's/^smtp_tls_CAfile.*/smtp_tls_CAfile = \/etc\/postfix\/cacert.pem/g' /etc/postfix/main.cf
          [[ "$($greppath -c ^[[]"${line%:*}"".""$outemailprovider""]:""${line#*:}" </etc/postfix/sasl_passwd)" == "0" ]] \
              && printf "[""${line%:*}"".""$outemailprovider""]:""${line#*:}""    $outemailadd":"$outemailpw" >> /etc/postfix/sasl_passwd \
              || $sedpath -i 's/^[[]'"${line%:*}.$outemailprovider]:${line#*:}"'.*/'"[${line%:*}.$outemailprovider]:${line#*:}     $outemailadd:$outemailpw"'/g' /etc/postfix/sasl_passwd
          [[ "$($greppath -c ^smtp_generic_maps </etc/postfix/main.cf)" == "0" ]] \
              && printf "smtp_generic_maps = hash:/etc/postfix/generic" >> /etc/postfix/main.cf \
              || $sedpath -i 's/^smtp_generic_maps.*/smtp_generic_maps = hash:\/etc\/postfix\/generic/g' /etc/postfix/main.cf
          [[ "$($greppath -c ^root@$(hostname) </etc/postfix/generic)" == "0" ]] \
              && printf "root@$(hostname)           $outemailadd" >> /etc/postfix/generic \
              || $sedpath -i 's/^'"root@$(hostname)"'.*/'"root@$(hostname)           $outemailadd"'/g' /etc/postfix/generic
          chown postfix /etc/postfix
          chown postfix /etc/postfix/generic
          chmod 600 /etc/postfix/sasl_passwd
          eval "$postmappath /etc/postfix/sasl_passwd"
          eval "$postmappath /etc/postfix/generic"
          chown root:root /etc/postfix/sasl_passwd /etc/postfix/sasl_passwd.db
          chmod 600 /etc/postfix/sasl_passwd.db
          chmod 644 /etc/postfix/cacert.pem
          chmod 644 /etc/postfix/master.cf
          cat /etc/ssl/certs/Thawte_Premium_Server_CA.pem | tee -a /etc/postfix/cacert.pem 1&>/dev/null
          chown postfix /etc/postfix/sasl_passwd*

          [[ $(/etc/init.d/postfix reload >/dev/null;echo $?) == "0" ]] || /etc/systemctl restart postfix

          if ! [[ "$( $postqueuepath -p )" == *is\ empty* ]];then
               printf "\nFor the next step, the mail queue needs to be flushed.  You will lose the\
\nfollowing emails that haven't been sent.  Press a key to acknowledge..."
               printf "$( $postqueuepath -p )"
               read -rsn 1;read -rst 0.001 -n3
               printf "$( $postqueuepath -f )"
          fi
          printf "\nNext, suitability test notifications will be sent out to all email addresses you\
\nindicated should receive notifications.  Press a key to send them..."
          read -rsn 1;read -rst 0.001 -n3
          printf "\n"
          notemsg=""
          [[ $answer =~ f ]] && notemsg+="Firewalling\n"
          [[ $answer =~ e ]] && notemsg+="Email remote control\n"
          [[ $answer =~ d ]] && notemsg+="Dynamic IP address change notifier\n"
          [[ $answer =~ p ]] && notemsg+="Port knocking\n"
          printf "Test using "${line%:*}"".""$outemailprovider"":""${line#*:}" \
\nas outgoing email server from firewall/dynamic IP notifier \
\nItems being installed:\n$( printf "${notemsg:: -2}" ), at $($datepath)"|$mailpath -s "Test notification from firewall install script" "$(echo "${toemailadds:: -2}"|$sedpath 's/\\n/,/g')"
#          cat \
<< See
If error: “SASL authentication failed; server smtp.gmail.com”,
you need to unlock the captcha by visiting this page \
https://www.google.com/accounts/DisplayUnlockCaptcha
See
#          sleep 2
           [[ "$( $postqueuepath -p )" == *is\ empty* ]] \
            && printf "All emails sent just fine.  Have they all been received in a timely manner?  If\
\nany were delayed, a different outgoing email server may do a better job." \
            || printf "Judging by the email queue not getting emptied quickly, a different outgoing\
\nemail server may do a better job.\n$($tailpath /var/log/syslog|$greppath postfix|$greppath ${line%:*}.$outemailprovider|$greppath -m 1 \]:${line#*:}|$sedpath 's/^.*status=//g')"
# \nemail server may do a better job.\n$($tailpath /var/log/syslog|$greppath postfix|$greppath ${line%:*}.$outemailprovider|$greppath -m 1 \]:${line#*:}|$sedpath 's/^.*status=//g')"
          printf "\nNote that not all email providers keep a record of your emails sent from this\
\ntype of connection.  If it is meaningful to you that these notification emails\
\nremain in the sent folder of this email address, be sure to check for that\
\nfeature before accepting this outgoing email server.  Press ENTER key to accept\
\nthis outgoing email server, any other key to see if another one can be tested..."
          [[ "$(until IFS= read -s -n1 -t .1 domore;[[ "$?" == "0" ]] && echo ${#domore};do :;done)" -eq 0 ]] && break 2
          printf "\nTrying next connection port.  Please wait..."
     done 3<"$poofitee_home_dir/$outemailprovider.outconnects.txt"  2> /dev/null #if needed to for chosen email account, this loop iterates through lines in outconnects.txt 
# user wants a to re-select an email address
             printf "Select a different email address for its outgoing email server:"
done #this loop goes through the email provider outbound servers & builds connect.txt files until user selects one
echo "$outemailadd" > "$poofitee_home_dir/outemailadd"
chown poofitee "$poofitee_home_dir/outemailadd"
chmod 600 "$poofitee_home_dir/outemailadd"
fi
postfix_already_conf=True # set this to True or just anything non-empty
          }

          install_rc () {
poofitee_home_dir="$( cat poofitee_home_dir )"
# "$($sedpath 's/,/\n/g' <"$poofitee_home_dir/toemailadds")"
inemailadd=""
inemailadd="$( [[ -f "$poofitee_home_dir/inemailadd" ]] && cat "$poofitee_home_dir/inemailadd" 2>/dev/null)"
#WORKING ON: nice selector from "$poofitee_home_dir/successlogins"

#inemailacct="${inemailadd%@*}";inemailprovider="${inemailadd#*@}";inemaildomain="${inemailprovider%.*}";intopdomain="${inemailprovider#*.}";inemailsubdomain="pop";
# rm "$poofitee_home_dir/successlogins" 2>/dev/null
create_tmp_timeouttry_script
clear
while true;do
     printf "(Be advised - The next configuration will determine the optimal port of an email\
\nserver to connect to when retrieving emailed instructions.  You should now\
\nensure that your Internet connection is the same one that will be used in final\
\noperation if your email account will be hosted by your local ISP.  The email\
\naccount, that is, that this server will read instructions out of.)\
\n\n  Enter the email address now from which this system will retrieve instructions\
\nto itself that you or others will send:\n"
#     printf -- "$line"
     bunch=""
     ! [[ -z "$inemailadd" ]] && bunch="$inemailadd"
     (! [[ -z "$bunch" ]] && ! [[ "${bunch,, -2}" == "\n" ]] && ! [[ -z "$outemailadd" ]]) && bunch+="\n"
     ! [[ -z "$outemailadd" ]] && bunch+="$outemailadd"
     (! [[ -z "$bunch" ]] && ! [[ "${bunch,, -2}" == "\n" ]] && ! [[ -z "$toemailadds" ]]) && bunch+="\n"
     ! [[ -z "$toemailadds" ]] && bunch+="$toemailadds"
     get_1_addr_from_bunch "$bunch"
          inemailadd="$emailadd";inemailacct="$emailacct";inemaildomain="$emaildomain";intopdomain="$topdomain";inemailprovider="$emailprovider";inemailpw="$emailpw"
         if ! [[ -z "$inemailadd" ]];then
             inemailaddforfiling="$(printf "$inemailadd"|$awkpath 1 ORS=',')"
             [[ "${inemailaddforfiling: -1}" == "," ]] && inemailaddforfiling="${inemailaddforfiling:: -1}"
             printf "$(printf "$inemailaddforfiling\n")" > "$poofitee_home_dir/inemailadd"
             break
         fi

              printf "Configuring for that email account.  Remember, you should be doing\
\nthis step from the Internet location of final operation if you have/want your\
\nlocal ISP-provided email account considered for this...\n"
              [[ -f "$poofitee_home_dir/$inemailprovider.inconnects.txt" ]] \
                 && rm "$poofitee_home_dir/$inemailprovider.inconnects.txt" 2>/dev/null
              printf  "\rYou selected address $inemailadd \033[K\nPlease wait for connection port checking...\n"
              ensure_connection
              while ! [[ -f "$poofitee_home_dir/$inemailprovider.inconnects.txt" ]];do # this loop re-tries if no connection file is created in the loop
                  exec 5>&-
                  for MAIL_PROT in pop pop3 mail;do
                       for port in 465 995 110 993;do
                            printf "\rChecking $MAIL_PROT.$inemailprovider:$port\033[K"
                            (/tmp/fifos_and_temp_files_for_poofitee_installer/timeouttry.sh -t 2 "exec 5>&-;exec 5<>/dev/tcp/$MAIL_PROT.$inemailprovider/$port;read -u 5 HELO;! [[ -z \$HELO ]] && echo \"$MAIL_PROT:$port\" >> \"$poofitee_home_dir/$inemailprovider.inconnects.txt\";printf \"quit\" >&5;read -t 2 -u 5 QUIT;exec 5>&-")
                       done  2> /dev/null
                  done
                  if [[ -f "$poofitee_home_dir/$inemailprovider.inconnects.txt" ]];then
                       printf "\rThe possibilities are\033[K\n$(<"$poofitee_home_dir/$inemailprovider.inconnects.txt")"
                  else
                       printf "\r\033[K\033[2ASelected email provider isn't allowing an initial connection right now or maybe\
\nthe Internet connection is faulty.  Press Ctrl-c to abort retries...\n"
# We need a better way to interrupt this
                       continue
                  fi
              done
# echo;printf "Address is\n\n$inemailacct"@"$inemaildomain"."$intopdomain"
          rcpw="";rcpw1=""
          while printf "\nPassword for that email account:";read -s rcpw;do # This loop is for when a password is under question
              printf "\n\033[KRe-type password:"
              read -s rcpw1
              printf "\r\033[K\033[1A\033[K"
              [[ -z "$rcpw$rcpw1" ]] && break 2
              ! [[ "$rcpw" == "$rcpw1" ]] && continue
              rm fifo 2>/dev/null
# mkfifo /tmp/fifos_and_temp_files_for_poofitee_installer/fifo doesn't function ideally
              while read -u 3 -r line;do #? this while loop iterates once for each port that accepted a pop connection ${line%:*}"."$outemailprovider"]:"${line#*:}
                  while true;do # This loop for exact settings retry
                      exec 5>&-
                      exec 5<>/dev/tcp/"${line%:*}.$inemailprovider/${line#*:}"
                      printf "\rExecuted the connect of ${line%:*}.$inemailprovider/${line#*:}, now communicating with it for user $inemailacct...\033[K"
                      read -t 2 -u 5 HELO 
                      printf "$HELO" >> /tmp/fifos_and_temp_files_for_poofitee_installer/fifo 
# printf "\n$HELO"
                      msgnumber=0
                      for msg in "user $inemailacct\r" "pass $rcpw\r" stat list;do
                           msgnumber=$(( msgnumber+=1 ))
                           printf "\r\033[KSending ${msg%'pass '*}\n"
                           printf "$msg" >&5
                         #  while true;do # this loop stores server responses for a configuration
# using 'cat <&5' would probably timeout on most single-line reads
                           while (read -u 5 replyline
                                  printf "\r\033[K$replyline\n"
                                  echo "$replyline" >> /tmp/fifos_and_temp_files_for_poofitee_installer/fifo 
                                  ! [[ "${replyline:0:1}" == "+" ]] && break # ! [[ "${replyline:0:1}" == "+" ]] && break
                                 ) &
                                pid="$!"
                           do
                                sleep 2 &
                                sid="$!"
                                until ! [[ $(kill -0 "$pid";echo "$?") == "0" ]] || ! [[ $(kill -0 "$sid";echo "$?") == "0" ]]; do
                                :
                                done
                                if [[ $(kill -0 "$pid";echo "$?") == "0" ]];then
                                    kill "$pid" >/dev/null
                                    break
                                else
                                    break
                                fi
                           done 2>/dev/null
                      done
                      printf "quit\r" >&5 
                      read -t 2 -u 5 BYE
#                      printf "$BYE" >> /tmp/fifos_and_temp_files_for_poofitee_installer/fifo 
                      exec 5>&-
                      if ! [[ "$( replystart="$($tailpath -n 1 /tmp/fifos_and_temp_files_for_poofitee_installer/fifo)";echo "${replystart::1}")" == "+" ]];then # present this choice with every error
                         printf "Unsuccessful sign-in of $inemailacct to ${line%:*}.$inemailprovider/${line#*:}" # with this error:\n$($tailpath -n 1 /tmp/fifos_and_temp_files_for_poofitee_installer/fifo)"
                         printf "quit\r" >&5
                         read -t 2 -u 5 BYE
#                          printf "$BYE" >> /tmp/fifos_and_temp_files_for_poofitee_installer/fifo 
                         exec 5>&-
                         printf "If you're sure about the password, and there are more port options for this\
\nemail account, option 'N' would make the most sense.  Try a new email Address, a\
\nnew Password, the Next possibility, same Everything, or Quit\
\n(A, P, N, E, or Q)..."
                         read -n1 retryansw # 4 does new pw, 0,1 goes into new pw
                         loops="A3P2N1E0Q4";loops="${loops#*${retryansw^}}"
                         echo
                         ! [[ "${loops::1}" == "0" ]] && continue "${loops::1}"
                      else
                         printf "$inemailacct ${line%:*}.$inemailprovider/${line#*:}" >> "$poofitee_home_dir/successlogins"
                         break
                      fi
                  done # This loop for exact settings retry
              done 3<"$poofitee_home_dir/$inemailprovider.inconnects.txt" 2> /dev/null
            # if we have even a single success, break
                     [ -f "$poofitee_home_dir/successlogins" ] && break 2
          done # This loop is for when a password is under question
done # This loop is to change the account
if [[ -f "$poofitee_home_dir/toemailadds" ]];then
     toemailadds="$(cat "$poofitee_home_dir/toemailadds")"
elif [[ -f "./toemailadds" ]];then
     toemailadds="$(cat "./toemailadds")"
fi
until ! [[ -z $toemailadds ]];do
     get_sendto_emailadds
done
#     printf "\n\nLet's look at the results:\n"
#     cat /tmp/fifos_and_temp_files_for_poofitee_installer/fifo
#     rm /tmp/fifos_and_temp_files_for_poofitee_installer/fifo 2>/dev/null
(cat <<EOF
#!/bin/bash
# THIS SCRIPT ALLOWS FOR CONTROL VIA EMAIL
# I suggest it be launched with a special port
# knock logged in kern.log by virtue of an
# iptables rule in the INPUT chain that
# identifies itself with the term "email-reader"
# in its comments. The script searching for that
# port-match and launching this script is called
# process_logfile_line.  By maintaining a dynamic
# blacklist for a while you'll better be able
# to determine a good port for you.

# The controlling email should be already sent
# before knocking said port because this
# script has no way of knowing for sure that
# an email will come in a timely manner.

# Numerous grep commands are contained herein
# that could be refined to use separate text
# files to hold the search terms/keywords. I did
# not so refine them simply to minimize the
# number of files in this project since I am
# targeting users who might get lost in
# an excessive number of files.  I would
# encourage you to modify those grep commands
# yourself if you value the finer points of
# programming.

# Example: (roughly, please don't criticize imperfection between the lists)
#     echo "\$(grep -e "Content-Type: text/plain; charset=UTF-8" -iwe "remove" -e "undo" -e "delete" -e "whitelist" -e "permit" -e "let" -e "on" -e "open" -e "allow" -e "blacklist" -e "off" -e "stop" -e "block" -e "recent" -e "report" -e "shut" -e "close" -e "prevent" -e "recent" -e "me" -e "report" -e "what" -e "who" -e "whoami" -e "kern" -e "kernlog" -e "kern.log" <(echo "\$mailcontentline"))" >> /home/poofitee/mailcontent
#
# becomes (except the email content header line becomes case-insensitive along with everything else):

#     cat *.keywords > allwords.tmp; echo "\$(grep -wif allwords.tmp <(echo "\$mailcontentline"))" >> /home/poofitee/mailcontent;rm allwords.tmp
#       -the grep -f flag is what does it
#
# given the following files exist in the appropriate directory, and
# there are no empty lines in the files, including the last ones:

#    'emailbegins.keywords' having the following contents: (case becomes insensitive if following the example given)
#       Content-Type: text/plain; charset=UTF-8

#    'blacklistlog.keywords' having the following contents:
#       log
#       logging

#    'tailkernlog&emailresults.keywords' having the following contents:
#       recent
#       report
#       kern
#       kernlog
#       kern.log
#       tail
#       who
#       whoami
#       what
#       me

#    'deleting.keywords' having the following contents:
#       remove
#       undo
#       delete
#       end
#       stop

#    'blacklisting.keywords' having the following contents:
#       blacklist
#       off
#       block
#       shut
#       close
#       prevent

#    'whitelisting.keywords' having the following contents:
#       whitelist
#       permit
#       let
#       on
#       open
#       allow
[ \$(( \$($tailpath -n-2 \$0|$greppath -c "^#running"))) -gt 0 ] && exit
until [ \$(( \$($tailpath -n-2 \$0|$greppath -c "^#running"))) -gt 0 ];do
      echo "#running" >> \$0
      sleep 1
done
trap "$sedpath -i '/^\#running/d' \$0" EXIT
[[ "\$-" =~ i ]] && echo "Connecting to email...."
port=110;MAIL_PROT="pop3"
#echo "\${2//[0-9]}"
[ ! -z \$2 ] && [ -z "\${2//[0-9]}" ] && [ \$2 -ge 0 ] && [ \$2 -le 65536 ] &&  port=\$2
[ ! -z \${3,S} ] && [ \${3,S} == "s" ] && MAIL_PROT="smtp"
[ ! -z \${3,S} ] && [ \${3,I} == "i" ] && MAIL_PROT="imap"
#echo \$port
#echo "<\$MAIL_PROT>"
#echo "\$inemailadd"
accountname=\$(echo "\$inemailadd" | $awkpath -F@ '{print \$1}');domainname=\$(echo  "\$inemailadd" | $awkpath -F@ '{print \$2}')
#echo "\$accountname and \$MAIL_PROT.\$domainname"
#echo "/dev/tcp/\$MAIL_PROT.\$domainname/\$port"
exec 5>&-;wait
exec 5<>/dev/tcp/\$MAIL_PROT"."\$domainname/\$port
if [[ "\$?" == "1" ]];then # failed to get through to email server
     while true;do
          # possibilities include that the iptables ruleset has lost permitting chains or another scenario repairable by this script
          printf "Failure to connect to pop3 email server \$(date).  Checking iptables ruleset...\n" >> "\$0.log"
#          [[ "\$-" =~ i ]] && printf "Failure to connect to pop3 email server \$(date).  Checking iptables ruleset...\n"
#          if [[ \$(( \$($greppath "I s_static_trusted" < buildiptables.sh|$wcpath -l) )) -gt \$(( \$($iptablespath -w -nvL s_static_trusted --line-numbers|$tailpath -n1|$awkpath '{print \$1}') )) ]];then
#              printf "iptables ruleset in s_static_trusted chain has fewer rules than found in backup repair script.  Repairing...\n" >> "\$0.log"
#              [[ "\$-" =~ i ]] && printf "iptables ruleset in s_static_trusted chain has fewer rules than found in backup repair script.  Repairing...\n"
#              echo "#!/bin/bash" > "\$0.repair"
#              $greppath "I s_static_trusted" < buildiptables.sh >> "\$0.repair"
#              chmod 700 "\$0.repair"
#              "\$0.repair"
#              printf "Repair attempted.  Now re-trying connection to email server...\n" >> "\$0.log"
#              [[ "\$-" =~ i ]] && printf "Repair attempted.  Now re-trying connection to email server...\n"
#              exec 5<>/dev/tcp/\$MAIL_PROT"."\$domainname/\$port
#              if [[ "\$?" == "1" ]];then
#                  printf "Failed again to connect to pop3 email server \$(date).\n" >> "\$0.log"
#                  [[ "\$-" =~ i ]] && printf "Failed again to connect to pop3 email server \$(date).\n"
#              else
#                   break
#              fi
#          else
#              printf "iptables ruleset in s_static_trusted chain has at least as many rules as found in backup repair script.  Making no repair...\n" >> "\$0.log"
#              [[ "\$-" =~ i ]] && printf "iptables ruleset in s_static_trusted chain has at least as many rules as found in backup repair script.  Making no repair...\n"
#          fi
#          if [[ \$(( \$($greppath "I d_static_trusted" < buildiptables.sh|wc -l) )) -gt \$(( \$($iptablespath -w -nvL d_static_trusted --line-numbers|$tailpath -n1|$awkpath '{print \$1}') )) ]];then
#              printf "iptables ruleset in d_static_trusted chain has fewer rules than found in backup repair script.  Repairing...\n" >> "\$0.log"
#              [[ "\$-" =~ i ]] && printf "iptables ruleset in d_static_trusted chain has fewer rules than found in backup repair script.  Repairing...\n"
#              echo "#!/bin/bash" > "\$0.repair"
#              $greppath "I d_static_trusted" < buildiptables.sh >> "\$0.repair"
#              chmod 700 "\$0.repair"
#              "\$0.repair"
#              printf "Repair attempted.  Now re-trying connection to email server...\n" >> "\$0.log"
#              [[ "\$-" =~ i ]] && printf "Repair attempted.  Now re-trying connection to email server...\n"
#              exec 5<>/dev/tcp/\$MAIL_PROT"."\$domainname/\$port
#              if [[ "\$?" == "1" ]];then
#                  printf "Failed again to connect to pop3 email server \$(date).\n" >> "\$0.log"
#                  [[ "\$-" =~ i ]] && printf "Failed again to connect to pop3 email server \$(date).\n"
#              fi
#          else
#              printf "iptables ruleset in d_static_trusted chain has at least as many rules as found in backup repair script.  Making no repair...\n" >> "\$0.log"
#              [[ "\$-" =~ i ]] && printf "iptables ruleset in d_static_trusted chain has at least as many rules as found in backup repair script.  Making no repair...\n"
#          fi
          break
     done
fi
[[ "\$-" =~ i ]] && echo "Executed the connect, now trying to read..."
read -t 2 -u 5 HELO # <&5
[ x\$1 == "x-v" ] && echo -e "GOT: \n\$HELO"
[ x\$1 == "x-v" ] && echo "SENDING: username"
echo -e "user \$accountname\r" >&5
#wait
read -t 2 -u 5 sendyourpassword # <&5
[ x\$1 == "x-v" ] && echo "\$sendyourpassword"
[ x\$1 == "x-v" ] && echo "SENDING: password"
echo -e "pass \$rcpw\r" >&5
#wait
read -t 2 -u 5  maildroplockedandready # <&5
[ x\$1 == "x-v" ] && echo "\$maildroplockedandready"
[ x\$1 == "x-v" ] && echo "SENDING: list"
echo -e "list\r" >&5
[ -f "\$directoryforscripts/mailcontent" ] && rm "\$directoryforscripts/mailcontent"
numofemails=-1
while read  -t 2 -u 5 emailtitle; do
    [ \$(( \${#emailtitle} )) -lt 3 ] && break
    if [ \$(( \${#emailtitle} )) -lt 20 ]; then
         #add to array of emailtitlnums
         numofemails=\$(( \$numofemails + 1 ))
         [ x\$1 == "x-v" ] && echo "\$numofemails"
         emailtitlenums[ \$((numofemails)) ]=\${emailtitle% *}
    fi
done

if [ \$((numofemails)) -gt -1 ]; then
    [[ "\$-" =~ i ]] && echo "Retrieving \$numofemails email[s]..."
    for i in \`seq 0 \$((numofemails))\`;do
         echo -e "RETR \${emailtitlenums[i]}\r" >&5
          boundary=""
          while read  -t 2 -u 5 mailcontentline;do
             [ \$(( \${#mailcontentline} )) -lt 2 ] && continue
             mailcontentline="\${mailcontentline:: -1} " #strip the linefeed and put space there instead
              [[ "\$-" =~ i ]] && echo "\$mailcontentline" #
              if [ -z "\$boundary" ];then [ \$(echo "\$mailcontentline"|$greppath -e "^Content-Type: "|$greppath -c "; boundary=") -gt 0 ] && boundary="\$(echo "\$mailcontentline"|$greppath -e "^Content-Type: " -e "; boundary="|$awkpath -F= '{print \$2}')" && boundarymarker=1
              else
                  echo "\$($greppath -iwe "remove" -e "undo" -e "delete" -e "whitelist" -e "permit" -e "let" -e "on" -e "open" -e "allow" -e "blacklist" -e "off" -e "stop" -e "block" -e "recent" -e "report" -e "shut" -e "close" -e "prevent" -e "recent" -e "me" -e "report" -e "what" -e "who" -e "whoami" -e "kern" -e "kernlog" -e "kern.log" -e "log" -e "end" -e "logging" <(echo "\$mailcontentline"))"|while read line;do [ \$(( \${#line} )) -gt 1 ] && echo "\$line" >> "\$directoryforscripts/mailcontent";done
                  [ \$(bc <<<"\${#mailcontentline} - \${#boundary}") -eq 2 ] && [ "\${mailcontentline:2: -1}" == "\${boundary:: -1}" ] && [ \$(( ++boundarymarker )) -gt 2 ] && (read  -t 2 -u 5 mailcontentline;read -t 2 -u 5  mailcontentline;read  -t 2 -u 5 mailcontentline;read -t 2 -u 5 mailcontentline) && break # && echo "Retrieved one message" && break
              fi
          done
    done
    for i in \`seq 0 \$((numofemails))\`;do
         if [[ "\$-" =~ i ]] || [ x\$1 == "x-v" ];then echo "Deleting email \${emailtitlenums[i]}";fi
         echo -e "DELE \${emailtitlenums[i]}\r" >&5
         while read -t 2 -u 5 deleteresponse;do
               if [[ "\$-" =~ i ]] || [ x\$1 == "x-v" ];then echo "\$deleteresponse";fi
               [ \$(( \${#deleteresponse} )) -lt 1 ] && break
         done
    done
     [ -f "\$directoryforscripts/valid_instructions_from_email" ] && rm "\$directoryforscripts/valid_instructions_from_email"
#This will give us the subject line of first email: head -n+\$(( \$($greppath -m 1 --line-number "Content-Type: text/plain; charset=UTF-8" < mailcontent|$awkpath -F: '{print \$1}') - 1)) mailcontent|$greppath -E '^Subject'
#This will start us at content of first email: tail -n+\$(( 2 + \$($greppath -m 1 --line-number "Content-Type: text/plain; charset=UTF-8" < mailcontent|$awkpath -F: '{print \$1}'))) mailcontent
     cat "\$directoryforscripts/mailcontent" |while read line; do line1="\$(echo "\$line "|$greppath -E -o "\b((1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\.){3}(1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])( |/[1-2]?[0-9] |/3[0-2] )")" && ( echo "\$line1"|while read ipadd;do echo "\$ipadd \$line" >> "\$directoryforscripts/valid_instructions_from_email"; done ) || (line1="\$(echo "\$line"|$greppath -wie "recent" -e "me" -e "report" -e "what" -e "who" -e "whoami" -e "kern" -e "kernlog" -e "kern.log" -e "tail" -e "log" -e "send" -e "return" -e "otp")" && ( echo "\$line1" >> "\$directoryforscripts/valid_instructions_from_email" ));done
     cat "\$directoryforscripts/valid_instructions_from_email" |while read line
     do option=""
          [ \$($greppath -cwie "undo" -e "remove" -e "delete" -e "end" -e "stop" <(echo "\$line")) -gt 0 ] && option="-r"
          if [ \$($greppath -cwie "report" -e "send" -e "return" <(echo "\$line")) -gt 0 ] && [ \$($greppath -cwi "whitelist" <(echo "\$line")) -gt 0 ];then
              script="echo \"\$($sudopath $ipsetpath list whitelist|$awkpath 'NR>7 {print \$1}')\"|$mailpath -s \"As you requested\" \"\$recipient_list\""
          elif [ \$($greppath -cwie "recent" -e "report" -e "kern" -e "kernlog" -e "kern.log" -e "tail" -e "who" -e "whoami" -e "what" -e "me" <(echo "\$line")) -gt 0 ];then
              script="echo \"\$($tailpath /var/log/kern.log)\"|$mailpath -s \"As you requested\" \"\$recipient_list\""
          elif [ \$($greppath -cwie "permit" -e "let" -e "on" -e "open" -e "allow" -e "whitelist" <(echo "\$line")) -gt 0 ]; then
              script="\$directoryforscripts/openall.sh \$(echo \"\$line\"|$awkpath '{print \$1}') \$option \"via email \$(date)\""
          elif [ \$($greppath -cwie "log" -e "logging" <\$(echo "\$line")) -gt 0 ];then
              if [ \$(( \${#option} )) -eq 0 ];then
                    script="($sudopath $iptablespath -w -nL INPUT|$greppath \"remove when not needed\") || ($sudopath $iptablespath -w -I INPUT \$($sudopath $iptablespath -w -nL INPUT --line-numbers|$greppath \"privateIPs \"|$awkpath '{print \$1 + 1}') -m comment --comment \"via email \$(date) - remove when not needed\" -j LOG"
                    script+=";echo \"$sudopath $iptablespath -w -D INPUT \$($sudopath $iptablespath -w -nL INPUT --line-numbers|$greppath -m 1 \"remove when not needed\"|$awkpath '{print \$1}')\ >/dev/null 2>/dev/null\"|at now +15 min)"
              elif ($sudopath $iptablespath -w -nL INPUT|$greppath "remove when not needed") ;then
                    script="($sudopath $iptablespath -w -nL INPUT|$greppath \"remove when not needed\") && $sudopath $iptablespath -w -D INPUT \$($sudopath $iptablespath -w -nL INPUT --line-numbers|$greppath -m 1 \"remove when not needed\"|$awkpath '{print \$1}')"
              else
                    script=""
              fi
#              [ \$(( \${#script} )) -ne 0 ] && echo "\$script" >> "\$directoryforscripts/buildiptables.sh"
          elif [ \$($greppath -cwi "restore ruleset" <(echo "\$line")) -gt 0 ];then
                if [[ \$((\$(ls -s /etc/iptables/rules.v4|$awkpath '{print \$1}'))) -lt 4 ]];then
                      cp "\$(ls -slt \$directoryforscripts/preparedness/rules*|$awkpath '{if (\$1>4) {print \$NF;exit}}')" "/etc/iptables/rules.v4"
                fi
                $sudopath $netfiltperspath restore
                $crontabpath -l|$sedpath '/*\/5 \* \* \* \* .*\/email_fetch_parse >\/dev\/null 2>&1/d' > "\$directoryforscripts/cronentries"
                [[ \$((\$($wcpath -l < "\$directoryforscripts/cronentries"))) -gt 1 ]] && $sudopath cat "\$directoryforscripts/cronentries"|$crontabpath -
          else
              script="\$directoryforscripts/process_logfile_line \$(echo \$line|$awkpath '{print \$1}') \$option \"via email \$(date)\""
          fi
          echo "email_fetch_parse is sending the following command to be executed:" >> "\$0.log"
          echo "\$script"  >> "\$0.log"
          [ \$(( \${#script} )) -ne 0 ] && eval "\$script"
     done
else
     if [[ "\$-" =~ i ]] || [ x\$1 == "x-v" ];then echo "No emails were in the inbox";fi
fi
#wait
#exec 5>&-
if [[ "\$-" =~ i ]] || [ x\$1 == "x-v" ];then echo "SENDING: QUIT";fi
echo -e "QUIT\r" >&5
wait
exec 5>&-
EOF
) > "$poofitee_home_dir/email_fetch_parse"
chown poofitee "$poofitee_home_dir/email_fetch_parse"
chmod 700 "$poofitee_home_dir/email_fetch_parse"
# TODO: iptables entry to log port knock for email reader
# belongs inserted just before both whitelist and blacklist - use the lower line number of them both
until read -erp "Enter a port number you will knock to initiate email to be read: " emailport; [[ "$emailport" =~ ^[0-9]{1,5}$ ]] && [[ $(( $emailport )) -le 65536 ]];do
    printf "\nThe port number must be a number between 0 and 65535 inclusive,\
\nbut 0 can be deemed by security-conscious routers to be invalid to traverse\
\nthe Internet.\n"
done
emailproto="tcp"
if [ -f "/etc/protocols" ];then
     until read -eri "$emailproto" -p "Enter the protocol you will use in that knock: " emailproto; [[ "$($awkpath '{print $1" "$2" "$3}' < "/etc/protocols"|$greppath -wcm 1 "$emailproto")" == "1" ]];do
         printf "\nThe protocol must be available in /etc/protocols\n"
     done
else
:
fi
until ! ($iptablespath -w -nL PREROUTING -t raw             |$greppath -- "^LOG     "|$greppath -- " dpt:" |$greppath -- "fetch email "|$greppath "This rule ensures email-reader port knock won't get ignored") >/dev/null ;do
    $iptablespath -w -D PREROUTING $($iptablespath -w -nL PREROUTING -t raw --line-numb      |$greppath -- "^.....LOG     "|$greppath -- "fetch email " |$greppath -- " dpt:"|$greppath "This rule ensures email-reader port knock won't get ignored"|$awkpath '{printf $1;exit}') -t raw &>/dev/null
done
[[ $($iptablespath -w -I PREROUTING 1 -t raw -m comment --comment "This rule ensures email-reader port knock won't get ignored" -p $emailproto --dport $emailport -j LOG --log-prefix "fetch email " &>/dev/null;echo "$?") == "0" ]] || printf "Failed 22"
}

install_dynIPch () {
#dhcp_lease_path
# mac=ipconfig getpacket (interface name)
#dhcp_message_type (uint8): ACK 0x5
#server_identifier (ip): 192.168.0.1
#lease_time (uint32): 0xf20
#subnet_mask (ip): 255.255.255.0
#router (ip_mult): {192.168.0.1}
#domain_name_server (ip_mult): {116.1.12.4, 116.1.12.5}
#end (none): 
#dhclient:
#Listening on LPF/$external_net_interface:avahi/00:26:b9:ef:57:dd
#Sending on   LPF/$external_net_interface:avahi/00:26:b9:ef:57:dd
#Listening on LPF/wlan0/5c:ac:4c:29:53:d0
#Sending on   LPF/wlan0/5c:ac:4c:29:53:d0
#Listening on LPF/$external_net_interface/00:26:b9:ef:57:dd
#Sending on   LPF/$external_net_interface/00:26:b9:ef:57:dd
#Sending on   Socket/fallback
#DHCPDISCOVER on $external_net_interface:avahi to 255.255.255.255 port 67 interval 3 (xid=0xde511649)
#DHCPREQUEST of 10.100.100.173 on wlan0 to 255.255.255.255 port 67 (xid=0x275b221c)
#DHCPDISCOVER on $external_net_interface to 255.255.255.255 port 67 interval 3 (xid=0x2727213c)
#DHCPACK of 10.100.100.173 from 172.22.0.5
#RTNETLINK answers: File exists
#bound to 10.100.100.173 -- renewal in 9225 seconds.
#
#read /etc/network/interfaces
#OS X=/Library/Preferences/SystemConfiguration/preferences.plist
# centos: 
# udhcpc: /var/lib/misc/udhcpc-$external_net_interface.leases or /var/cache/udhcpc-$external_net_interface.lease, not really clear for embedded linux's.  This is an important one to get right
# dhcpcd: /etc/dhcpc/dhcpcd-$external_net_interface.info
# pump: in memory alone, need to parse ps uax output
# dhclient: /var/lib/NetworkManager/*.lease*, or /var/lib/dhcp/dhclient. or on FreeBSD /var/db/*lease*
# /var/lib/dhcp3/dhclient.%iface%.leases
#if [[ $(( cat $(ls /var/lib/dhclient/*.lease* /var/lib/dhcp/*.lease* /var/lib/dhcp3/*.lease* /var/lib/NetworkManager/*.lease* /var/lib/dhcpcd/*$external_net_interface* /var/db/*lease* 2>/dev/null|$greppath -w "$external_net_interface")|$greppath -w $($ippath -o route get 8.8.8.8|$awkpath '{ print $7 }')|$wcpath -l )) -eq 0 ]] && \
#[[ $(( cat $(ls /var/lib/dhclient/*.lease* /var/lib/dhcp/*.lease* /var/lib/dhcp3/*.lease* /var/lib/NetworkManager/*.lease* /var/db/*lease* 2>/dev/null|$greppath -vw "$likeliest_internal_net_interface")|$greppath -wC 3 $($ippath -o route get 8.8.8.8|$awkpath '{ print $5 }')|$greppath -w $($ippath -o route get 8.8.8.8|$awkpath '{ print $7 }')|$wcpath -l  )) -eq 0 ]];then
#[[ $(( dhclient -v $external_net_interface|$wcpath -l 2>/dev/null )) -gt 0 ]]
# get the ip address of $external_net_interface from ip route or ifconfig or ipconfig
#   /etc/network/interfaces, grep for lines tno starting w/# and referencing googleinterface that say 'static' orf 'dhcp'
# static int dhcp_up(interface_defn *ifd, execfn *exec) {
# {
#   if (!execute("[[ifconfig %iface% hw %hwaddress%]]", ifd, exec)) return 0;
# }
# if ( execable("/sbin/dhclient3") ) {
# if (!execute("dhclient3 -pf /var/run/dhclient.%iface%.pid -lf /var/lib/dhcp3/dhclient.%iface%.leases %iface%", ifd, exec)) return 0;
# }
# else if ( execable("/sbin/dhclient") ) {
# if (!execute("dhclient -v -pf /var/run/dhclient.%iface%.pid -lf /var/lib/dhcp/dhclient.%iface%.leases %iface%", ifd, exec)) return 0;
# }
# else if ( execable("/sbin/pump") && mylinuxver() >= mylinux(2,1,100) ) {
# if (!execute("pump -i %iface% [[-h %hostname%]] [[-l %leasehours%]]", ifd, exec)) return 0;
# }
# else if ( execable("/sbin/udhcpc") && mylinuxver() >= mylinux(2,2,0) ) {
#   if (!execute("udhcpc -n -p /var/run/udhcpc.%iface%.pid -i %iface% [[-H %hostname%]]            [[-c %client%]]", ifd, exec)) return 0;
# }
# else if ( execable("/sbin/dhcpcd") ) {
# if (!execute("dhcpcd [[-h %hostname%]] [[-i %vendor%]] [[-I %client%]]            [[-l %leasetime%]] %iface%", ifd, exec)) return 0;
# }
# 
#FIRST: LOOK FOR PS AUX OUTPUT THAT EVIDENCES THAT IFACE IS SERVED BY ONE OF THE DHCP CLIENTS, IF NEED BE THEN ENSURE NO 'STATIC' IN /etc/network/interfaces FOR THAT IFACE as in:
# /sbin/dhclient -d -sf /usr/lib/NetworkManager/nm-dhcp-client.action -pf /run/sendsigs.omit.d/network-manager.dhclient-wlan0.pid -lf /var/lib/NetworkManager/dhclient-58a215d6-1342-4ce9-8da8-e75dab5b68c3-wlan0.lease -cf /var/lib/NetworkManager/dhclient-wlan0.conf wlan0
poofitee_home_dir="$( cat poofitee_home_dir )"
dhcpclientpath=""
for dhcpclientpkg in "pump -i $external_net_interface --status" "udhcpc -i $external_net_interface" "dhcpcd $external_net_interface" "ipconfig getpacket $external_net_interface" "dhclient -v $external_net_interface";do
    dhcpclientpath="$($whereispath $binaryflag ${dhcpclientpkg%% *})"
    dhcpclientpath="${dhcpclientpath##*:}"
    [[ -z "$dhcpclientpath" ]] && continue
    dhcpclientpath="${dhcpclientpath# }"
    dhcpclientpath="${dhcpclientpath%% *}"
    echo "Executing <$dhcpclientpath ${dhcpclientpkg#* }>"
    $($dhcpclientpath ${dhcpclientpkg#* } | $greppath -i renew ) # |$greppath  # since there could be several dhcp clients installed we know only one will be working, eliminate non-working ones
done
if [[ -z "$dhcpclientpath" ]];then
    printf "Unable to verify that the Internet-pointing interface is a DHCP client.  If said\
\ninterface is not using DHCP as a DHCP client, there is no point in installing\
\nthis feature.  If it IS a dhcp client, then the finding of this script is in\
\nerror, and you'll have to modify this script to so it learns how to detect and\
\nmonitor for DHCP changes specific to your system.  Exiting now..."
    exit
fi

if ! [[ -z "$toemailaddsIP" ]];then
     echo "$(echo "${toemailaddsIP:: -2}"|$sedpath 's/\\n/,/g')" > "$poofitee_home_dir/toemailaddsIP"
     break
fi
# "$poofitee_home_dir/newdynip.sh"
printf "The notification email you'd receive should refer to this computer by what name?"
pcname=$(while read -eri "$(hostname)" sysname;do if ! [[ -z "$sysname" ]];then echo "$sysname";break;fi;done)
echo
if [[ "$($curlpath http://ipecho.net/plain)" =~ ^((1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\.){3}(1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])$ ]];then 
     printf "To learn any new IP address gotten, this computer will interrogate a public\nservice, \
default is shown below.  Press enter to keep it; otherwise, change it\nto suit you:"
else 
     printf "To learn any new IP address gotten, this computer will interrogate a public\nservice, \
default is shown below, but is NOT WORKING now.  Change it to suit you:"
fi
#The following line is not yet tested after changing from dig to curl
resolver="$(while read -ei "$curlpath http://ipecho.net/plain" resolver;do 
     echo "$resolver";break;
done)"

#Is the following duplicated?
printf "\n\nEmail address[es] where to send IP change notifications to:\n\n"
toemailaddsIP="$($sedpath 's/,/\n/g' <"$poofitee_home_dir/toemailaddsIP")"
scratchpad="${toemailaddsIP##*'\n'}"
line="${toemailaddsIP##*'\n'}";printf -- "$line"
toemailaddsIPid=1
              while IFS= read  -rsn1 char;do
                   if [[ "$(printf "%d" "'$char")" == "27" ]];then # '
                         char1="";char2="";char3=""
                         read -rst 0.001 -n1 char1
                         read -rst 0.001 -n1 char2
                         read -rst 0.001 -n1 char3
                         if [[ "$char1$char2$char3" == "[A" ]] || [[ "$char1$char2$char3" == "[B" ]];then
                              if [[ "$char1$char2$char3" == "[A" ]];then
                                   toemailaddsIPid=$(( $toemailaddsIPid - 1 ))
                              else
                                   toemailaddsIPid=$(( $toemailaddsIPid + 1 ))
                              fi
                              if [[ $(( $toemailaddsIPid )) -lt 1 ]];then
                                    toemailaddsIPid=$(( $toemailaddsIPid + 1 ))
                                    continue
                              fi
                              scratchpad="$toemailaddsIP"
                              for i in `seq 2 $(( $toemailaddsIPid ))`;do
                                   ! [[ -z "${scratchpad#*'\n'}" ]] \
                                       && scratchpad="${scratchpad#*'\n'}" \
                                       || toemailaddsIPid=$(( $toemailaddsIPid - 1 ))
                              done
                              scratchpad="${scratchpad%%'\n'*}"
                              printf "\r${scratchpad}\033[K"
                              horizptr="$(( ${#scratchpad} ))"
                         elif [[ "$char1$char2$char3" == "[C" ]];then
                              if [[ $(( ${horizptr} )) -lt $(( ${#scratchpad} )) ]];then
                                    horizptr="$(( ${horizptr} + 1 ))"
                                    printf "\033[1C"
                              fi
                         elif [[ "$char1$char2$char3" == "[D" ]];then
                              if [[ $(( ${horizptr} )) -gt 0 ]];then
                                    horizptr="$(( ${horizptr} - 1 ))"
                                    printf "\033[1D"
                              fi
                         elif [[ "$char1$char2$char3" == "OF" ]];then
                              horizptr="$(( ${#scratchpad} ))"
                              printf "\r\033[${#scratchpad}C"
                         elif [[ "$char1$char2$char3" == "OH" ]];then
                              horizptr="0"
                              printf "\r"
                         elif [[ "$char1$char2$char3" == "[3~" ]];then
                              if [[ $(( ${horizptr} )) -lt $(( ${#scratchpad} )) ]];then
                                   scratchpad="${scratchpad:0:horizptr}${scratchpad:horizptr+1}" # handles the delete character
                                   printf "${scratchpad:horizptr}\033[K\r${scratchpad:0:horizptr}"
                              fi
                         fi
                   elif [[ "$(printf "%d" "'$char")" == "127" ]];then # '
                     if ! [[ $(( ${horizptr} )) -eq 0 ]];then # exit
                         horizptr="$(( ${horizptr} - 1 ))"
                         scratchpad="${scratchpad:0:horizptr}${scratchpad:horizptr+1}" # handles the backspace character
                         printf "\033[1D${scratchpad:horizptr}\033[K\r${scratchpad:0:horizptr}"
                     fi
                   elif [[ -z "$char" ]];then
                         break
                   else
                        horizptr="$(( ${horizptr} + 1 ))"
                        scratchpad="${scratchpad:0:horizptr-1}$char${scratchpad:horizptr-1}"
                        printf "$char${scratchpad:horizptr}\033[K\r${scratchpad:0:horizptr}"
                   fi
              done
              outemailadd="${scratchpad%%'\n'*}"
              outemailacct="${outemailadd%@*}";outemailprovider="${outemailadd#*@}"
              outemaildomain="${outemailprovider%.*}"
              outtopdomain="${outemailprovider##*.}"
              if ! [[ "$outemailadd" == "$outemailacct"@"$outemaildomain"."$outtopdomain" ]] || [[ -z "$outemaildomain" ]] || [[ -z "$outtopdomain" ]];then
                  printf "\nEmail address not in correct format.  Re-enter it...\033[1A\r$scratchpad";horizptr="${#scratchpad}"
                  continue
              fi
          ! [[ -z "$outemailadd" ]] && break
# echo;printf "Addresses are\n\n${toemailadds:: -2}"
printf "In the email that will inform those recipients who you specified of the new IP\
\naddress listed as one or a series of link[s] formatted as any browser would\
\naccept in the address bar, enter the protocol, subdirectories and options, and\
\nport that the address will begin and end with, in as many combinations as you'd\
\nlike displayed in the email.\
\nExample: Suppose your computer serves two web pages, one as http and the other\
\nas https, two camera video streams, wifi modem administration, ssh, and a remote\
\ncontrol channel, so you could want all 7 links sent in the new IP address\
\nnotification email, along with reminder links of those 7 services with their\
\ninside (private) IP addresses for access to them when you are home, like this,\
\nsome port numbers fictitious:\
\n\nhttp://<new IP address>/sub/dir[s]:80\
\nhttps://<new IP address>/sub/dir[s]:443\
\nrtsp://<new IP address>/sub/dir[s] and options:15541\
\nrtsp://<new IP address>/sub/dir[s] and options:15542\
\nhttp://<new IP address>/sub/dir[s]:801\
\nssh homeowner@<new IP address>:122\
\nxmpp://<new IP address>/sub/dir[s] and options:121\
\n"
IFS=. read -r -a ip_from_internal_interface <<< "$($ifconfigpath|$greppath -A4 ^$likeliest_internal_net_interface|$greppath -m 1 "inet addr:"|$awkpath '{print substr($2,6)}')"
(cat <<EOF
#!/bin/bash
# arg 1 is file name of modified file in same directory as leases
# verify ending type is lease or leases
# then parse backwards making sure no private ip range is referenced
! [[ "\${1##*.}" == "lease" ]] && ! [[ "\${1##*.}" == "leases" ]] && ! [[ "\$1" =~ /etc/dhcpc/dhcpcd*.info ]] && ! [[ \"$1" =~ /usr/share/udhcpc/default.script ]] && ! [[ -z "\$1" ]] && exit
#site-specific variables:
webpageprotocol=https
emailsubjectline="New IP address for \$(hostname): "
file_to_store_ip="$poofitee_home_dir/oldip"
#The following line is not yet tested after changing from dig to curl
resolver="$curlpath http://ipecho.net/plain"
ip_from_resolver="\$(\$resolver)"
if [[ \$ip_from_resolver =~ ^((1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\\.){3}(1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])$ ]];
then
    if ( [ -f \$file_to_store_ip ] );
    then
        if [[ \$(< \$file_to_store_ip) =~ ^((1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\\.){3}(1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])$ ]] && [[ \$ip_from_resolver == \$(< \$file_to_store_ip) ]];
        then
echo "IP address is <\$ip_from_resolver> and not new, old ip = <\$(cat \$file_to_store_ip)>"
            exit
        fi
    else
        : #first run
    fi
else
echo "IP address is <\$ip_from_resolver> and not acceptable"
    exit
fi
#modify the here-doc section below to produce your desired email notification
(cat <<EOM
\$webpageprotocol://$ip_from_resolver
\$($sudopath $iptablespath -w -nL PREROUTING -t nat|$awkpath '{if (\$1=="DNAT") {for (i=6;i<=NF;i++) if (\$i ~ "^dport") {printf \$(i+1)} else if (\$i ~ "^dpt") {printf substr(\$i,5,length(\$i)-4)}}print ""}')
ssh user@\$ip_from_resolver
hping3 -V -S -c 1 -n -p port_number[s]  \$ip_from_resolver
#adjust the protocol to the targeted service
http://"${ip_from_internal_interface[0]}"."${ip_from_internal_interface[1]}"."${ip_from_internal_interface[2]}"."\$((${ip_from_internal_interface[0]}+1))"
ssh user@$ip_from_internal_interface
EOM
) | $mailpath -s "\$emailsubjectline" \$emaildestination

echo \$ip_from_resolver > \$file_to_store_ip
echo "IP address is <\$ip_from_resolver>"
EOF
) > "$poofitee_home_dir/newdynip.sh"
chown poofitee "$poofitee_home_dir/newdynip.sh"
chmod 700 "$poofitee_home_dir/newdynip.sh"
#  Only need to confirm if there are entries in crontab
! [[ "$(eval $crontabpath -u poofitee -l 2>/dev/null|$greppath -E -v ^#|$greppath -v ^[[:space:]]*$|$wcpath -l)" == "0" ]] && \
     (printf -- "\n$(eval $crontabpath -u poofitee -l 2>/dev/null|$greppath -E -v ^#|$greppath -v ^[[:space:]]*$|$wcpath -l) entries in crontab:\n\n$(eval "$crontabpath -u poofitee -l|$greppath -E -v ^#|$greppath -v ^[[:space:]]*$")\n"
      echo "Confirm you understand that your crontab shell is now getting changed which"
      read -n1 -s -p "might affect the above entries if they send values on, contain quotes, etc.: ")
(cat << CRONTAB_ENTRIES_END
$($crontabpath -u poofitee -l 2>/dev/null)
# line below is from poofitee_DynAddChangeNotify
@reboot "$poofitee_home_dir/newdynip.sh" &>/dev/null
##The following lines are from poofitee_DynAddChangeNotify and intentionally redundant to allow owner/sysadmin to change dhcp client package and still get notified of dhcp change
@reboot $sudopath $nicepath -n19 $inotifywaitpath --format \\%w\\%f --quiet --monitor --event modify /var/lib/dhcp/dhclient.$external_net_interface.leases|while read filename;do "$poofitee_home_dir/newdynip.sh" "\$filename";done &>/dev/null
@reboot $sudopath $nicepath -n19 $inotifywaitpath --format \\%w\\%f --quiet --monitor --event modify /etc/dhcpc/|while read filename;do "$poofitee_home_dir/newdynip.sh" "\$filename";done &>/dev/null # dhcpcd*.info        DO MONITOR, make separate entry for each file found
@reboot $sudopath $nicepath -n19 $inotifywaitpath --format \\%w\\%f --quiet --monitor --event access /usr/share/udhcpc/default.script|while read filename;do "$poofitee_home_dir/newdynip.sh";done &>/dev/null # NEED TO INOTIFYWAIT MONITOR FOR "ACCESS" THE SCRIPT FILE THAT GETS EXECUTED ON CHANGE
@reboot $sudopath $nicepath -n19 $inotifywaitpath --format \\%w\\%f --quiet --monitor --event modify /var/db/|while read filename;do "$poofitee_home_dir/newdynip.sh" "\$filename";done &>/dev/null # *lease*
@reboot $sudopath $nicepath -n19 $inotifywaitpath --format \\%w\\%f --quiet --monitor --event modify /var/lib/dhcp/|while read filename;do "$poofitee_home_dir/newdynip.sh" "\$filename";done &>/dev/null # dhclient*.lease*
@reboot $sudopath $nicepath -n19 $inotifywaitpath --format \\%w\\%f --quiet --monitor --event modify /var/lib/dhcp/|while read filename;do "$poofitee_home_dir/newdynip.sh" "\$filename";done &>/dev/null # *.lease*
@reboot $sudopath $nicepath -n19 $inotifywaitpath --format \\%w\\%f --quiet --monitor --event modify /var/lib/dhcpd/|while read filename;do "$poofitee_home_dir/newdynip.sh" "\$filename";done &>/dev/null # dhcpd.lease*
@reboot $sudopath $nicepath -n19 $inotifywaitpath --format \\%w\\%f --quiet --monitor --event modify /var/lib/dhcp3/|while read filename;do "$poofitee_home_dir/newdynip.sh" "\$filename";done &>/dev/null # *.lease*
@reboot $sudopath $nicepath -n19 $inotifywaitpath --format \\%w\\%f --quiet --monitor --event modify /var/lib/dhcp3/|while read filename;do "$poofitee_home_dir/newdynip.sh" "\$filename";done &>/dev/null # dhclient*.lease*
@reboot $sudopath $nicepath -n19 $inotifywaitpath --format \\%w\\%f --quiet --monitor --event modify /var/lib/dhcp3/|while read filename;do "$poofitee_home_dir/newdynip.sh" "\$filename";done &>/dev/null # *.lease*
@reboot $sudopath $nicepath -n19 $inotifywaitpath --format \\%w\\%f --quiet --monitor --event modify /var/lib/dhcpcd/|while read filename;do "$poofitee_home_dir/newdynip.sh" "\$filename";done &>/dev/null # *.*
@reboot $sudopath $nicepath -n19 $inotifywaitpath --format \\%w\\%f --quiet --monitor --event modify /var/lib/dhclient/|while read filename;do "$poofitee_home_dir/newdynip.sh" "\$filename";done &>/dev/null # *.lease*
@reboot $sudopath $nicepath -n19 $inotifywaitpath --format \\%w\\%f --quiet --monitor --event modify /var/lib/misc/|while read filename;do "$poofitee_home_dir/newdynip.sh" "\$filename";done &>/dev/null # udhcpc*.lease*
@reboot $sudopath $nicepath -n19 $inotifywaitpath --format \\%w\\%f --quiet --monitor --event modify /var/lib/NetworkManager/|while read filename;do "$poofitee_home_dir/newdynip.sh" "\$filename";done &>/dev/null # *.lease*
CRONTAB_ENTRIES_END
) |$crontabpath -u poofitee -
[[ "$(eval "$crontabpath -u poofitee -l 2>/dev/null|$greppath -c \"SHELL=\"")" == "0" ]] && \
  printf "SHELL=/bin/bash\n$($crontabpath -u poofitee -l 2>/dev/null)"|$crontabpath -u poofitee - || \
  eval "$crontabpath -u poofitee -l|$sedpath \"/SHELL=/c\SHELL=/bin/bash\"|$crontabpath -u poofitee -"
echo "crontab set up..."
}

outemail_warnings () {
         printf "This installation script is about to make changes to this computer that can\
\nprofoundly change the way it SENDS OUT email.  No accommodation will be given\
\nfor any email sending capability that you might already have set up.  PLEASE do\
\nNOT expect this scripting to give any OUTBOUND emailing consideration for email\
\nprograms you have previously installed.  Only proceed if you agree with this\
\nnotion.  In contrast, INBOUND emailing is not expected to be affected because\
\nthis scripting does not rely on, nor change the settings of, any email client\
\nprogram for inbound email.  "
}

end_warnings () {
         printf "Remember always this fact of life:  Email providers do make unpredictable\
\nchanges to their email service!  The same holds true for ISPs.  Blame that on any\
\nnumber of different reasons...technical, social, and otherwise.  Be aware that\
\nthe settings you just created may need to be adjusted in the future in response\
\nto changes that others WILL make to affect your Internet experience, even\
\nchanges expressly designed to limit the usefulness of this fine enhancement\
\nyou've made to your Internet connectivity!  Though let's hope they'll have\
\nbetter reason for doing so than merely to be that way."
}
get_1_addr_from_bunch() {
#one arg: a bunch of newline delimited email addresses, except no newline following last entry
          emailadds="$1"
          scratchpad="${emailadds%%'\n'*}"
          emailaddid=1 ;horizptr="${#scratchpad}"
          printf "\n(up/down-arrows will scroll, or edit into an entirely different account name)\n$scratchpad"
          while true;do #this loop get a new email account or one chosen from bunch with password
              while IFS= read  -rsn1 char;do
                   if [[ "$(printf "%d" "'$char")" == "27" ]];then # '
                         char1="";char2="";char3=""
                         read -rst 0.001 -n1 char1
                         read -rst 0.001 -n1 char2
                         read -rst 0.001 -n1 char3
                         if [[ "$char1$char2$char3" == "[A" ]] || [[ "$char1$char2$char3" == "[B" ]];then
                              if [[ "$char1$char2$char3" == "[A" ]];then
                                   emailaddid=$(( $emailaddid - 1 ))
                              else
                                   emailaddid=$(( $emailaddid + 1 ))
                              fi
                              if [[ $(( $emailaddid )) -lt 1 ]];then
                                    emailaddid=$(( $emailaddid + 1 ))
                                    continue
                              fi
                              scratchpad="$emailadds"
                              for i in `seq 2 $(( $emailaddid ))`;do
                                   ! [[ -z "${scratchpad#*'\n'}" ]] \
                                       && scratchpad="${scratchpad#*'\n'}" \
                                       || emailaddid=$(( $emailaddid - 1 ))
                              done
                              scratchpad="${scratchpad%%'\n'*}"
                              printf "\r${scratchpad}\033[K"
                              horizptr="$(( ${#scratchpad} ))"
                         elif [[ "$char1$char2$char3" == "[C" ]];then
                              if [[ $(( ${horizptr} )) -lt $(( ${#scratchpad} )) ]];then
                                    horizptr="$(( ${horizptr} + 1 ))"
                                    printf "\033[1C"
                              fi
                         elif [[ "$char1$char2$char3" == "[D" ]];then
                              if [[ $(( ${horizptr} )) -gt 0 ]];then
                                    horizptr="$(( ${horizptr} - 1 ))"
                                    printf "\033[1D"
                              fi
                         elif [[ "$char1$char2$char3" == "OF" ]];then
                              horizptr="$(( ${#scratchpad} ))"
                              printf "\r\033[${#scratchpad}C"
                         elif [[ "$char1$char2$char3" == "OH" ]];then
                              horizptr="0"
                              printf "\r"
                         elif [[ "$char1$char2$char3" == "[3~" ]];then
                              if [[ $(( ${horizptr} )) -lt $(( ${#scratchpad} )) ]];then
                                   scratchpad="${scratchpad:0:horizptr}${scratchpad:horizptr+1}" # handles the delete character
                                   printf "${scratchpad:horizptr}\033[K\r${scratchpad:0:horizptr}"
                              fi
                         fi
                   elif [[ "$(printf "%d" "'$char")" == "127" ]];then # '
                     if ! [[ $(( ${horizptr} )) -eq 0 ]];then # exit
                         horizptr="$(( ${horizptr} - 1 ))"
                         scratchpad="${scratchpad:0:horizptr}${scratchpad:horizptr+1}" # handles the backspace character
                         printf "\033[1D${scratchpad:horizptr}\033[K\r${scratchpad:0:horizptr}"
                     fi
                   elif [[ -z "$char" ]];then
                         break
                   else
                        horizptr="$(( ${horizptr} + 1 ))"
                        scratchpad="${scratchpad:0:horizptr-1}$char${scratchpad:horizptr-1}"
                        printf "$char${scratchpad:horizptr}\033[K\r${scratchpad:0:horizptr}"
                   fi
              done
              emailadd="${scratchpad%%'\n'*}"
# printf  "\n\nSelected address is $emailadd\n"
              emailacct="${emailadd%@*}";emailprovider="${emailadd#*@}"
              emaildomain="${emailprovider%.*}"
              topdomain="${emailprovider##*.}"
              if ! [[ "$emailadd" =~ ^(([-a-zA-Z0-9\!#\$%\&\'*+/=?^_\`{\|}~]+|(\"([][,:;<>\&@a-zA-Z0-9\!#\$%\&\'*+/=?^_\`{\|}~-]|(\\\\[\\ \"]))+\"))\.)*([-a-zA-Z0-9\!#\$%\&\'*+/=?^_\`{\|}~]+|(\"([][,:;<>\&@a-zA-Z0-9\!#\$%\&\'*+/=?^_\`{\|}~-]|(\\\\[\\ \"]))+\"))+@[A-Za-z0-9.-]+\.[A-Za-z]{2,4}$ ]];then
                  printf "\nEmail address not in correct format.  Re-enter it...\033[1A\r$scratchpad";horizptr="${#scratchpad}"
                  continue
              fi
              printf "\n\033[K"
              emailpw1="";emailpw=""
              until [[ "$emailpw1" == "$emailpw" ]] && ! [[ -z "$emailpw1""$emailpw" ]];do
                  read -s -p "Password for account $emailadd: " emailpw1
                  [[ -z "$emailpw1" ]] && exit || echo
                  read -s -p "Re-type same password: " emailpw
                  if ! [[ "$emailpw1" == "$emailpw" ]];then
                      printf "\nPassword not entered consistently."
                  else
                      echo
                  fi
              done
          ! [[ -z "$emailadd" ]] && ! [[ -z "$emailpw" ]] && break
          done
}
press_a_key () {
printf "press $(! [[ -z "$1$2" ]] && printf "$1/$2" || printf "any key"), Ctrl-c aborts..."
read -rsn 1;read -rst 0.001 -n4 discard
[[ "$REPLY" == "$1" ]] && return 0 || return 1
}

#logo outer badge shape (eyebrows, face) fills left side of screen, then each line gets repeated backwards just to right side of screen
logo="\
......................................................................................................@...\
\n......................................................................................................@...\
\n......................................................................................................@...\
\n....................@@@@..............................................................................@...\
\n.................@@@@..@@@@@@@@@@@@@@................................................................@@...\
\n.............@@@@@..................@@@@@@@@@@@@@@...................................................@....\
\n.............@@..................................@@@@@@@.............................................@....\
\n..............@........................................@@@@@........................................@@....\
\n..............@@...........................................@@@@@....................................@@....\
\n...............@...............................................@@@@.................................@.....\
\n...............@..................................................@@@@@............................@@.....\
\n..............@@...........................yyy........................@@@@@........................@@.....\
\n.............@@.....................**.**TT...TT**........................@@@@@...................@@......\
\n.............@..................*.*................**.*.......................@@@@@@.............@@.......\
\n............@@................*...*.................*....*.........................@@@@....@@@@@@.........\
\n...........@@..............*......].................*......*..........................@@@@@@..............\
\n.........@@........................*.............../........*.............................................\
\n.......@@@..........................\..............*.........*............................................\
\n..@@@@@.......................................*.*.............*...........................................\
\n@@@.......................................................................................................\
\n@.........................................................................................................\
\n@.........................................................................................................\
\n@.........................................................................................................\
\n@.........................................................................................................\
\n@.........................................................................................................\
\n@@........................................................................................................\
\n.@........................................................................................................\
\n.@@.......................................................................................................\
\n..@.......................................................................................................\
\n..@.......................................................................................................\
\n..@@......................................................................................................\
\n...@......................................................................................................\
\n...@@.....................................................................................................\
\n...@@.....................................................................................................\
\n....@.....................................................................................................\
\n.....@....................................................................................................\
\n.....@....................................................................................................\
\n.....@@...................................................................................................\
\n......@@..................................................................................................\
\n.......@..................................................................................................\
\n........@................................................................................................."
layitout () {
            printf -- "$1\n"| \
            while IFS= read -r line;do
                if [[ -z "$screen_line" ]]; then
                    screen_line="."
                else
# here, insert all lines needing accurate screen locations
                    printf "\n"
                fi
                if [[ "${line:0:8}" == "<center>" ]];then
                    line="${line:8}"
                    ! [[ -z "$line" ]] && line="$([[ $(((cols - ${#line}) / 2 )) -ge 1 ]] && printf -- '%.s'" " $(seq $(((cols - ${#line}) / 2 ))))""$line"
                fi
                firstofline=""
                for ((linepointer=0;linepointer<${#line};));do
                    printout=""
                    for ((i=cols;i>=0;i--));do
                        if [[ $((linepointer+i)) -ge ${#line} ]];then
                            printout="${line:linepointer}"
                            linepointer=${#line}
                            i=0
                        elif [[ ${line:i+linepointer:1} =~ [[:space:]] ]];then
                            printout="${line:linepointer:i}"
                            ((i++))
                            linepointer=$((linepointer+=i))
                            i=0
                        elif [[ $((i)) -lt $((cols)) ]] && [[ ${line:i+linepointer:1} =~ - ]] && [[ ${line:i+linepointer-1:1} =~ [[:alnum:]] ]];then
                            ((i++))
                            printout="${line:linepointer:i}"
                            linepointer=$((linepointer+=i))
                            i=0
                        fi
                    done
                    if [[ -z "$firstofline" ]]; then
                        firstofline="."
                    else
                        printout="\n""$printout"
                    fi
                    printf -- "$printout"
        	    done
            done
return
}
showthis () {
# $1 is main text to display
# $2 is type of box to use
# $3 is title of inmost box
# $4 is background title
# $5 and following is list of checklist or menu entries
# integrate with press_a_key?
rows=24
cols=80
#NOTE: BECAUSE OF THE NEED FOR tput IN THIS FUNCTION, WE MUST NOT REDIRECT STDERR OF THE CALLING STATEMENT TO THIS FUNCTION
# THEREFORE THE WHIPLOG ANSWER WILL BE CONTROLLED WITHIN HERE, THE FILE NAME IS THEN HARDCODED BOTH HERE AND IN THE CALLER
if ! [[ -z "$tputpath" ]];then
    rows="$($tputpath lines)"
    cols="$(($($tputpath cols)))"
fi
if [[ -z "$tputpath" ]] && ! [[ -z "$resizepath" ]];then # Resizing tested slower that using tput
    eval `$resizepath`
   rows=$LINES
   cols=$COLUMNS
fi
maxwidthforwhiplogbox=$((cols - 8))
title="$(! [[ -z "$dialogpath" ]] && printf "\\Zb\\Z1")$3"
# THIS PART OF THIS FUNCTION NOW EXPANDS BACKTITLE ($4 COMING IN HERE) IF TPUT IS PRESENT USING THE LAST TWO-SPACE SEQUENCE IN BACKTITLE IN WHICH TO INSERT ADDITIONAL PADDING
backtitle="$4"
if ! [[ -z "$4" ]] && [[ ${#4} -lt $((cols - 2)) ]];then
    if [[ "${4%'  '*}" == "${4%%'  '*}" ]];then
        backtitle="${4%%'  '*}$(printf '%.s'" " $(seq $((cols $([[ -z "$dialogpath" ]] && printf -- "+ 2") - ${#4}))))${4#*'  '}"
    else
        backtitle_2nd_segment="${4#*'  '}"
        backtitle="${4%%'  '*}$(printf '%.s'" " \
        $(seq $(((cols $([[ -z "$dialogpath" ]] && printf -- "+ 2") - ${#4} + 2) / 2))))${backtitle_2nd_segment%'  '*}$(printf '%.s'" " \
        $(seq $(((cols $([[ -z "$dialogpath" ]] && printf -- "+ 2") - ${#4}$([[ $localwarning =~ bash\ shell\ version ]] && printf " + 1" || printf " + 3")) / 2))))${backtitle_2nd_segment##*'  '}" # needed to be a 3 adjust for all until whiptail in CentOS 7, then made it a 1
#        backtitle="${4%%'  '*}$(printf '%.s'" " \
#        $(seq $(((cols $([[ -z "$dialogpath" ]] && printf -- "+ 2") - ${#4} + 2) / 2))))${backtitle_2nd_segment%'  '*}$(printf '%.s'" " \
#        $(seq $(((cols $([[ -z "$dialogpath" ]] && printf -- "+ 2") - ${#4}$([[ -z "$rhelchkconfigpath" ]] && printf " + 3" || printf " + 1")) / 2))))${backtitle_2nd_segment##*'  '}" # needed to be a 3 adjust for all until whiptail in CentOS 7, then made it a 1
    fi
fi
screen_line=""
# boxheightestimate="$5"
argnum=6
if ! [[ -z "$whiplogpath" ]];then
numoflinesinoutput="0"
colors=$([[ -z "$whiptailpath" ]] && printf -- "--colors")
#   NOTE THAT OUR DEVELOPMENT PLATFORM DID NOT GIVE THE '--SCROLLTEXT' OPTION FUNCTIONALITY.  ALSO NOTE THAT FreeBSD DIALOG(1) MAN PAGES STATE --SCROLLTEXT IS MAPPED TO --SCROLLBAR
    case $2 in 
    infobox)
# Dialog won't scroll infobox!  It needs to be something besides infobox for longer messages.  CentOS 7 or old bash won't respond to excape key
        printf -- "$1$([[ -z "$dialogpath" ]] && ! [[ $localwarning =~ bash\ shell\ version ]] && printf "\nQuit: escape key")\n"| \
        while IFS= read -r line;do
            if [[ -z "$screen_line" ]]; then
                screen_line="."
            else
                numoflinesinoutput="$(($numoflinesinoutput + 1))"
            fi
            if [[ "${line:0:8}" == "<center>" ]];then
                line="${line:8}"  #The adjustment for centering on display must occur in the dialog command line
            fi
            firstofline=""
            for ((linepointer=0;linepointer<${#line};));do
                for ((i=cols-12;i>=0;i--));do #The 12 is line waste in dialog infobox
                    if [[ $((linepointer+i)) -ge ${#line} ]];then
                        linepointer=${#line}
                        i=0
                    elif [[ ${line:i+linepointer:1} =~ [[:space:]] ]];then
                        ((i++))
                        linepointer=$((linepointer+=i))
                        i=0
                    fi
                done
                if [[ -z "$firstofline" ]]; then
                    firstofline="."
                else
                    numoflinesinoutput="$(($numoflinesinoutput + 1))"
                fi
            done
            printf "$numoflinesinoutput" > /tmp/fifos_and_temp_files_for_poofitee_installer/numoflinesinoutput
        done
        numoflinesinoutput="$(cat /tmp/fifos_and_temp_files_for_poofitee_installer/numoflinesinoutput)"
        rm /tmp/fifos_and_temp_files_for_poofitee_installer/numoflinesinoutput
# Haven't been able to get infobox to display in whiptail with xterminals so we change to msgbox
        [[ $((rows - numoflinesinoutput)) -gt 11 ]] && rowsfordialog=$(($numoflinesinoutput + 3)) || rowsfordialog=$(($rows - 8)) 
        $whiplogpath $colors --title "$title" --backtitle "$backtitle" \
            --nocancel \
            --scrolltext $([[ -z "$whiptailpath" ]] && printf -- "--$2" || printf -- "--msgbox") -- "$(screen_line=""; \
            printf -- "$1$([[ -z "$dialogpath" ]] && ! [[ $localwarning =~ bash\ shell\ version ]] && printf "\n<center>Quit: escape key")\n"|while IFS= read -r line;do \
                if [[ -z "$screen_line" ]]; then \
                    screen_line="."; \
                else \
                    printf "\n"; \
                fi; \
                if [[ "${line:0:8}" == "<center>" ]];then
                    line="${line:8}"
                    [[ $((((cols - ${#line}) / 2) - 6)) -gt 0 ]] && line="$(printf '%.s'" " $(seq $((((cols - ${#line}) / 2) - 6))))""$line"; \
                fi; \
                printf -- "$line"; \
            done; \
        )" $(($rowsfordialog $(! [[ -z "$whiptailpath" ]] && printf -- "+ 4 "))) $maxwidthforwhiplogbox 2>/tmp/fifos_and_temp_files_for_poofitee_installer/answergui
        ! [[ "$?" == "0" ]] && exit
        printf "\n" >> /tmp/fifos_and_temp_files_for_poofitee_installer/answergui
    ;;
    yesno)
        printf -- "$1\n"| \
        while IFS= read -r line;do
            if [[ -z "$screen_line" ]]; then
                screen_line="."
            else
                numoflinesinoutput="$(($numoflinesinoutput + 1))"
            fi
            if [[ "${line:0:8}" == "<center>" ]];then
                line="${line:8}"  #The adjustment for centering on display must occur in the dialog command line
            fi
            firstofline=""
            for ((linepointer=0;linepointer<${#line};));do
                for ((i=cols-12;i>=0;i--));do #The 12 is line waste in dialog infobox
                    if [[ $((linepointer+i)) -ge ${#line} ]];then
                        linepointer=${#line}
                        i=0
                    elif [[ ${line:i+linepointer:1} =~ [[:space:]] ]];then
                        ((i++))
                        linepointer=$((linepointer+=i))
                        i=0
                    fi
                done
                if [[ -z "$firstofline" ]]; then
                    firstofline="."
                else
                    numoflinesinoutput="$(($numoflinesinoutput + 1))"
                fi
            done
            printf "$numoflinesinoutput" > /tmp/fifos_and_temp_files_for_poofitee_installer/numoflinesinoutput
        done
        numoflinesinoutput="$(cat /tmp/fifos_and_temp_files_for_poofitee_installer/numoflinesinoutput)"
        rm /tmp/fifos_and_temp_files_for_poofitee_installer/numoflinesinoutput
# Haven't been able to get infobox to display in whiptail with xterminals so we change to msgbox
        [[ $((rows - numoflinesinoutput)) -gt 11 ]] && rowsfordialog=$(($numoflinesinoutput + 3)) || rowsfordialog=$(($rows - 8)) 
        $whiplogpath $colors --title "$title" --backtitle "$backtitle" \
            --scrolltext $([[ -z "$whiptailpath" ]] && printf -- "--$2" || printf -- "--$2") "$(screen_line=""; \
            printf -- "$1\n"|while IFS= read -r line;do \
                if [[ -z "$screen_line" ]]; then \
                    screen_line="."; \
                else \
                    printf "\n"; \
                fi; \
                if [[ "${line:0:8}" == "<center>" ]];then
                    line="${line:8}"
                    [[ $((((cols - ${#line}) / 2) - 6)) -gt 0 ]] && line="$(printf '%.s'" " $(seq $((((cols - ${#line}) / 2) - 6))))""$line"; \
                fi; \
                printf -- "$line"; \
            done; \
        )" $(($rowsfordialog $(! [[ -z "$whiptailpath" ]] && printf -- "+ 4 "))) $maxwidthforwhiplogbox "${@:5}" 2>/tmp/fifos_and_temp_files_for_poofitee_installer/answergui
        printf "\n" >> /tmp/fifos_and_temp_files_for_poofitee_installer/answergui
    ;;
    msgbox)
        printf -- "$1\n$(! [[ $localwarning =~ bash\ shell\ version ]] && printf "Quit: escape key\n")"| \
        while IFS= read -r line;do
            if [[ -z "$screen_line" ]]; then
                screen_line="."
            else
                numoflinesinoutput="$(($numoflinesinoutput + 1))"
#printf "\n" >> /tmp/fifos_and_temp_files_for_poofitee_installer/sandbox
            fi
            if [[ "${line:0:8}" == "<center>" ]];then
                line="${line:8}"  #The adjustment for centering on display must occur in the dialog command line
            fi
            firstofline=""
            for ((linepointer=0;linepointer<${#line};));do
#printout=""
                for ((i=cols-12;i>=0;i--));do #The 12 is line waste in dialog infobox
                    if [[ $((linepointer+i)) -ge ${#line} ]];then
#printout="${line:linepointer}"
                        linepointer=${#line}
                        i=0
                    elif [[ ${line:i+linepointer:1} =~ [[:space:]] ]];then
#printout="${line:linepointer:i}"
                        ((i++))
                        linepointer=$((linepointer+=i))
                        i=0
                    fi
                done
                if [[ -z "$firstofline" ]]; then
                    firstofline="."
                else
#printout="\n""$printout"
                    numoflinesinoutput="$(($numoflinesinoutput + 1))"
                fi
#printf -- "$printout" >> /tmp/fifos_and_temp_files_for_poofitee_installer/sandbox
            done
            printf "$numoflinesinoutput" > /tmp/fifos_and_temp_files_for_poofitee_installer/numoflinesinoutput
        done
        numoflinesinoutput="$(($(cat /tmp/fifos_and_temp_files_for_poofitee_installer/numoflinesinoutput) + 2))"
        ! [[ -z "$whiptailpath" ]] && numoflinesinoutput="$(($numoflinesinoutput + 2))"
        rm /tmp/fifos_and_temp_files_for_poofitee_installer/numoflinesinoutput
        [[ $((rows - numoflinesinoutput)) -gt 11 ]] && rowsfordialog=$(($numoflinesinoutput + 3)) || rowsfordialog=$(($rows - 8)) 
        $whiplogpath $colors --title "$title" --backtitle "$backtitle" \
            --nocancel \
            --scrolltext "--$2" "$(screen_line=""; \
            printf -- "$1\n$(! [[ $localwarning =~ bash\ shell\ version ]] && printf "<center>Quit: escape key\n")"|while IFS= read -r line;do \
                if [[ -z "$screen_line" ]]; then \
                    screen_line="."; \
                else \
                    printf "\n"; \
                fi; \
                if [[ "${line:0:8}" == "<center>" ]];then
                    line="${line:8}"
                    [[ $((((cols - ${#line}) / 2) - 6)) -gt 0 ]] && line="$(printf '%.s'" " $(seq $((((cols - ${#line}) / 2) - 6))))""$line"; \
                fi; \
                printf -- "$line"; \
            done; \
        )" $rowsfordialog $maxwidthforwhiplogbox 2>/tmp/fifos_and_temp_files_for_poofitee_installer/answergui
        ! [[ "$?" == "0" ]] && exit
        printf "\n" >> /tmp/fifos_and_temp_files_for_poofitee_installer/answergui
    ;;
    checklist|checkbox)
        printf -- "$1\n"| \
        while IFS= read -r line;do
            if [[ -z "$screen_line" ]]; then
                screen_line="."
            else
                numoflinesinoutput="$(($numoflinesinoutput + 1))"
#printf "\n" >> /tmp/fifos_and_temp_files_for_poofitee_installer/sandbox
            fi
            if [[ "${line:0:8}" == "<center>" ]];then
                line="${line:8}"  #The adjustment for centering on display must occur in the dialog command line
            fi
            firstofline=""
            for ((linepointer=0;linepointer<${#line};));do
#printout=""
                for ((i=cols-12;i>=0;i--));do #The 12 is line waste in dialog infobox
                    if [[ $((linepointer+i)) -ge ${#line} ]];then
#printout="${line:linepointer}"
                        linepointer=${#line}
                        i=0
                    elif [[ ${line:i+linepointer:1} =~ [[:space:]] ]];then
#printout="${line:linepointer:i}"
                        ((i++))
                        linepointer=$((linepointer+=i))
                        i=0
                    fi
                done
                if [[ -z "$firstofline" ]]; then
                    firstofline="."
                else
#printout="\n""$printout"
                    numoflinesinoutput="$(($numoflinesinoutput + 1))"
                fi
#printf -- "$printout" >> /tmp/fifos_and_temp_files_for_poofitee_installer/sandbox
            done
            printf "$numoflinesinoutput" > /tmp/fifos_and_temp_files_for_poofitee_installer/numoflinesinoutput
        done
        numoflinesinoutput="$(($(cat /tmp/fifos_and_temp_files_for_poofitee_installer/numoflinesinoutput) + 2))"
        ! [[ -z "$whiptailpath" ]] && numoflinesinoutput="$(($numoflinesinoutput + 2))"
        rm /tmp/fifos_and_temp_files_for_poofitee_installer/numoflinesinoutput
#        [[ $((rows - numoflinesinoutput)) -gt 11 ]] && rowsfordialog=$(($numoflinesinoutput + 3)) || rowsfordialog=$(($rows - 8))
        [[ $((rows - numoflinesinoutput)) -gt 11 ]] && rowsfordialog=$(($numoflinesinoutput + $(($5 + $([[ -z "$dialogpath" ]] && printf "2" || printf "4"))))) || rowsfordialog=$(($rows - 8)) 
        $whiplogpath $colors --title "$title" --backtitle "$backtitle" \
                --scrolltext \
                --separate-output \
                $([[ -z "$dialogpath" ]] && printf -- "--separate-output") \
                --noitem \
                --nocancel \
                --checklist -- "$(screen_line=""; \
                printf -- "$1\n"|while IFS= read -r line;do \
                    if [[ -z "$screen_line" ]]; then \
                        screen_line="."; \
                    else \
                        printf "\n"; \
                    fi; \
                    if [[ "${line:0:8}" == "<center>" ]];then
                        line="${line:8}"
                        [[ $((((cols - ${#line}) / 2) - 6)) -gt 0 ]] && line="$(printf '%.s'" " $(seq $((((cols - ${#line}) / 2) - 6))))""$line"; \
                    fi; \
                    printf -- "$line"; \
                done; \
            )" $rowsfordialog $maxwidthforwhiplogbox "${@:5}" 2>/tmp/fifos_and_temp_files_for_poofitee_installer/answergui
        printf "\n" >> /tmp/fifos_and_temp_files_for_poofitee_installer/answergui
        while IFS= read -r line;do
            index=0
            for argument in "${@:argnum}";do 
                if [[ $index =~ [02468]$ ]];then
                    [[ "$line" == "$argument" ]] && answer+="$((index / 2))\n"
                fi
                index=$((index + 1))
            done
        done < /tmp/fifos_and_temp_files_for_poofitee_installer/answergui
        printf -- "$answer\n" > /tmp/fifos_and_temp_files_for_poofitee_installer/answergui
    ;;
    radiobox|radiolist)
        printf -- "$1\n"| \
        while IFS= read -r line;do
            if [[ -z "$screen_line" ]]; then
                screen_line="."
            else
                numoflinesinoutput="$(($numoflinesinoutput + 1))"
printf "\n" >> /tmp/fifos_and_temp_files_for_poofitee_installer/sandbox
            fi
            if [[ "${line:0:8}" == "<center>" ]];then
                line="${line:8}"  #The adjustment for centering on display must occur in the dialog command line
            fi
            firstofline=""
            for ((linepointer=0;linepointer<${#line};));do
printout=""
                for ((i=cols-12;i>=0;i--));do #The 12 is line waste in dialog infobox
                    if [[ $((linepointer+i)) -ge ${#line} ]];then
printout="${line:linepointer}"
                        linepointer=${#line}
                        i=0
                    elif [[ ${line:i+linepointer:1} =~ [[:space:]] ]];then
printout="${line:linepointer:i}"
                        ((i++))
                        linepointer=$((linepointer+=i))
                        i=0
                    fi
                done
                if [[ -z "$firstofline" ]]; then
                    firstofline="."
                else
printout="\n""$printout"
                    numoflinesinoutput="$(($numoflinesinoutput + 1))"
                fi
printf -- "$printout" >> /tmp/fifos_and_temp_files_for_poofitee_installer/sandbox
            done
            printf "$numoflinesinoutput" > /tmp/fifos_and_temp_files_for_poofitee_installer/numoflinesinoutput
        done
        numoflinesinoutput="$(($(cat /tmp/fifos_and_temp_files_for_poofitee_installer/numoflinesinoutput) + 2))"
        ! [[ -z "$whiptailpath" ]] && numoflinesinoutput="$(($numoflinesinoutput + 2))"
        rm /tmp/fifos_and_temp_files_for_poofitee_installer/numoflinesinoutput
        [[ $((rows - numoflinesinoutput)) -gt 11 ]] && rowsfordialog=$(($numoflinesinoutput + $(($5 + $([[ -z "$dialogpath" ]] && printf "2" || printf "4"))))) || rowsfordialog=$(($rows - 8)) 
        $whiplogpath $colors --title "$title" --backtitle "$backtitle" \
                --scrolltext \
                $([[ -z "$dialogpath" ]] && printf -- "--separate-output") \
                --noitem \
                --nocancel \
                --radiolist -- "$(screen_line=""; \
                printf -- "$1\n"|while IFS= read -r line;do \
                    if [[ -z "$screen_line" ]]; then \
                        screen_line="."; \
                    else \
                        printf "\n"; \
                    fi; \
                    if [[ "${line:0:8}" == "<center>" ]];then
                        line="${line:8}"
                        [[ $((((cols - ${#line}) / 2) - 6)) -gt 0 ]] && line="$(printf '%.s'" " $(seq $((((cols - ${#line}) / 2) - 6))))""$line"; \
                    fi; \
                    printf -- "$line"; \
                done; \
            )"  "$rowsfordialog" $maxwidthforwhiplogbox "${@:5}" 2>/tmp/fifos_and_temp_files_for_poofitee_installer/answergui
        printf "\n" >> /tmp/fifos_and_temp_files_for_poofitee_installer/answergui
        while IFS= read -r line;do
            index=0
            for argument in "${@:argnum}";do 
                if [[ $index =~ [02468]$ ]];then
                    [[ "$line" == "$argument" ]] && answer+="$((index / 2))\n"
                fi
                index=$((index + 1))
            done
        done < /tmp/fifos_and_temp_files_for_poofitee_installer/answergui
        printf -- "$answer\n" > /tmp/fifos_and_temp_files_for_poofitee_installer/answergui
    ;;
    menu)
        printf -- "$1\n<center>Quit: escape key\n"| \
        while IFS= read -r line;do
            if [[ -z "$screen_line" ]]; then
                screen_line="."
            else
                numoflinesinoutput="$(($numoflinesinoutput + 1))"
printf "\n" >> /tmp/fifos_and_temp_files_for_poofitee_installer/sandbox
            fi
            if [[ "${line:0:8}" == "<center>" ]];then
                line="${line:8}"  #The adjustment for centering on display must occur in the dialog command line
            fi
            firstofline=""
            for ((linepointer=0;linepointer<${#line};));do
printout=""
                for ((i=cols-12;i>=0;i--));do #The 12 is line waste in dialog infobox
                    if [[ $((linepointer+i)) -ge ${#line} ]];then
printout="${line:linepointer}"
                        linepointer=${#line}
                        i=0
                    elif [[ ${line:i+linepointer:1} =~ [[:space:]] ]];then
printout="${line:linepointer:i}"
                        ((i++))
                        linepointer=$((linepointer+=i))
                        i=0
                    fi
                done
                if [[ -z "$firstofline" ]]; then
                    firstofline="."
                else
printout="\n""$printout"
                    numoflinesinoutput="$(($numoflinesinoutput + 1))"
                fi
printf -- "$printout" >> /tmp/fifos_and_temp_files_for_poofitee_installer/sandbox
            done
            printf "$numoflinesinoutput" > /tmp/fifos_and_temp_files_for_poofitee_installer/numoflinesinoutput
        done
        numoflinesinoutput="$(($(cat /tmp/fifos_and_temp_files_for_poofitee_installer/numoflinesinoutput) + 2))"
        ! [[ -z "$whiptailpath" ]] && numoflinesinoutput="$(($numoflinesinoutput + 2))"
        rm /tmp/fifos_and_temp_files_for_poofitee_installer/numoflinesinoutput
        if [[ "$5" == "0" ]];then
            [[ -z "$whiptailpath" ]] && adjust_for_menu="0" || adjust_for_menu="4"
        else
            [[ -z "$whiptailpath" ]] && adjust_for_menu="4" || adjust_for_menu="2"
        fi
rowsfordialog=$(($numoflinesinoutput + $5 + $adjust_for_menu))
#        [[ $((rows - numoflinesinoutput)) -gt 11 ]] && rowsfordialog=$(($numoflinesinoutput + $(($5 + $([[ -z "$dialogpath" ]] && printf "2" || printf "4"))))) || rowsfordialog=$(($rows - 8))
#        [[ $((rows - numoflinesinoutput)) -gt 11 ]] && rowsfordialog=$(($numoflinesinoutput + $(($5 + $([[ -z "$dialogpath" ]] && printf "2" || printf "4"))))) || rowsfordialog=$(($rows - 8))
# printf "\n$rowsfordialog\n";exit #added 5 lines to min (2), only add 2 when $5 == "0" in dialog, 6 in whiptail when linesinput is low.  Line count high: add 4 to numoflinesinoutput in whiptail, no diff in dialog)
        $whiplogpath $colors --title "$title" --backtitle "$backtitle" \
                --scrolltext \
                $([[ -z "$dialogpath" ]] && printf -- "--separate-output") \
                --noitem \
                --$2 "$(screen_line=""; \
                printf -- "$1\n<center>Quit: escape key\n"|while IFS= read -r line;do \
                    if [[ -z "$screen_line" ]]; then \
                        screen_line="."; \
                    else \
                        printf "\n"; \
                    fi; \
                    if [[ "${line:0:8}" == "<center>" ]];then
                        line="${line:8}"
                        [[ $((((cols - ${#line}) / 2) - 6)) -gt 0 ]] && line="$(printf '%.s'" " $(seq $((((cols - ${#line}) / 2) - 6))))""$line"; \
                    fi; \
                    printf -- "$line"; \
                done; \
            )"  $(($rowsfordialog)) $maxwidthforwhiplogbox "${@:5}" 2>/tmp/fifos_and_temp_files_for_poofitee_installer/answergui
#            )"  "$rowsfordialog" $maxwidthforwhiplogbox "${@:5}" 2>/tmp/fifos_and_temp_files_for_poofitee_installer/answergui
        ! [[ "$?" == "0" ]] && exit
        printf "\n" >> /tmp/fifos_and_temp_files_for_poofitee_installer/answergui
        while IFS= read -r line;do
            index=0
            for argument in "${@:argnum}";do 
                if [[ $index =~ [02468]$ ]];then
                    [[ "$line" == "$argument" ]] && answer+="$((index / 2))\n"
                fi
                index=$((index + 1))
            done
        done < /tmp/fifos_and_temp_files_for_poofitee_installer/answergui
        printf -- "$answer\n" > /tmp/fifos_and_temp_files_for_poofitee_installer/answergui
    ;;
    esac
else
#    until
        activeitem=1
        clear
        layitout "$backtitle\n"
        layitout "$([[ $(((cols - ${#title}) / 2 )) -ge 1 ]] && printf -- '%.s'" " $(seq $(((cols - ${#title}) / 2 ))))""$title\n\n"
        if [[ "$2" =~ ^radio|^check|^menu ]];then #hijack the loop for the entries, saving the line numbers of entry locations
            index="$argnum"
            minpadding=$((cols / 2 ))
            for argument in "${@:argnum}";do # should also create an array b/c we will be using it for fast lookup, storing select status, etc. things
                [[ $index =~ [02468]$ ]] && [[ $(((cols - ${#argument} - 4) / 2 )) -lt $(($minpadding)) ]] && minpadding=$(((cols - ${#argument} - 4) / 2 ))
                if ! [[ $((minpadding)) -gt 0 ]];then
                    minpadding=0;break
                fi
                index=$((index + 1))
            done
            index="$argnum"
            maxindex=-1
            for argument in "${@:argnum}";do
#                layitout "\n" # This is fine only when selections are few
                if [[ $index =~ [02468]$ ]];then
                    maxindex=$((maxindex + 1))
                    printf "\033[6n" ; read -sd R cp;cp="${cp#*[}"
                    selectionrow[$(((index - argnum) / 2))]="$((${cp%;*} - 1))"
                    selectioncol[$(((index - argnum) / 2))]="$((minpadding + ${cp#*;}))"
                    [[ $((minpadding)) -gt 0 ]] && layitout "$(printf '%.s'" " $(seq $((minpadding))))"
                    layitout "$(printf -- "$([[ $2 =~ ^radio ]] && printf "( ) " || printf "[ ] ")$argument")"
                    layitout "\n"  # This is fine only when selections are few
                else
                    selection_select_status[$(((index - 1 - argnum) / 2))]="$argument"
                fi
                index=$((index + 1))
            done
#            layitout "\n" # Give some visual separation aftermenu choices
        else
            layitout "$1"
            [[ "$2" =~ ^msgbox|^infobox ]] && press_a_key
            return
        fi
        layitout "$1"
        printf "\033[6n" ; read -sd R cp;cp="${cp#*[}"
        quitrow="$((${cp%;*} - 2))"
        highlightedentryid=0
        ! [[ -z  "$tputpath" ]] && $tputpath cup ${selectionrow[highlightedentryid]} ${selectioncol[highlightedentryid]}
        key=""
        while [[ "$2" =~ ^radio|^check|^menu ]];do 
            while IFS= read -rsn1 char;do
                key+="$(printf "%d" "'$char")," # '
                for ((i=1;i<5;i++));do
                    read -rst 0.001 -n1 char
                    key+="$(printf "%d" "'$char")," # '
                done
                case "$key" in
                    "32,0,0,0,0,") #Space bar, reverse selected status of highighted entry and go to that line and rewrite the selected field, then put at waiting place again
                        if ! [[ -z "$tputpath" ]] && [[ ${selection_select_status[highlightedentryid]} == "ON" ]];then
                            selection_select_status[highlightedentryid]="OFF"
                            mark_char=" "
                        elif ! [[ -z "$tputpath" ]];then
                            selection_select_status[highlightedentryid]="ON"
                            mark_char="*"
                        fi
                        printf -- "$mark_char"
                        $tputpath cup ${selectionrow[highlightedentryid]} ${selectioncol[highlightedentryid]}
                    ;;
                   "0,0,0,0,0,")# Enter key, put final selections outside this while loop into an existing variable that invoker can read
                        index="-1";echo "" > /tmp/fifos_and_temp_files_for_poofitee_installer/answergui
                        for item in "${selection_select_status[@]}";do
                           index="$((index + 1))"
                           if [[ ${selection_select_status[index]} == "ON" ]];then
                               echo "$index" >> /tmp/fifos_and_temp_files_for_poofitee_installer/answergui
                            fi
                        done
                        break 2
                    ;;
                   "27,91,65,0,0,"|"27,91,66,0,0,")
                         if [[ "$key" == "27,91,65,0,0," ]] || [[ "$key" == "27,91,66,0,0," ]];then # trap up and down arrows
                              if [[ "$key" == "27,91,65,0,0," ]] && [[ $(($highlightedentryid)) -gt 0 ]];then # up arrow
                                   highlightedentryid=$(( $highlightedentryid - 1 ))
                                  ! [[ -z  "$tputpath" ]] && $tputpath cup ${selectionrow[highlightedentryid]} ${selectioncol[highlightedentryid]}
                              elif [[ "$key" == "27,91,66,0,0," ]] && [[ $(($highlightedentryid)) -lt $((maxindex)) ]];then
                                   highlightedentryid=$(( $highlightedentryid + 1 )) # down arrow
                                  ! [[ -z  "$tputpath" ]] && $tputpath cup ${selectionrow[highlightedentryid]} ${selectioncol[highlightedentryid]}
                              fi
#                              if [[ "$key" == "27,91,66,0,0," ]] && [[ $(($highlightedentryid)) -lt 1 ]];then # 
#                                    highlightedentryid=$(( $highlightedentryid + 1 ))
#                                    continue
#                              fi
#                              scratchpad="$printout"
#                              for i in `seq 2 $(( $highlightedentryid ))`;do
#                                   ! [[ -z "${scratchpad#*'\n'}" ]] \
#                                       && scratchpad="${scratchpad#*'\n'}" \
#                                       || highlightedentryid=$(( $highlightedentryid - 1 ))
#                              done
#                              scratchpad="${scratchpad%%'\n'*}"
#                              printf "\r${scratchpad}\033[K"
#                              horizptr="$(( ${#scratchpad} ))"
#                         elif [[ "$char1$char2$char3" == "[C" ]];then
#                              if [[ $(( ${horizptr} )) -lt $(( ${#scratchpad} )) ]];then
#                                    horizptr="$(( ${horizptr} + 1 ))"
#                                    printf "\033[1C"
#                              fi
#                         elif [[ "$char1$char2$char3" == "[D" ]];then
#                              if [[ $(( ${horizptr} )) -gt 0 ]];then
#                                    horizptr="$(( ${horizptr} - 1 ))"
#                                    printf "\033[1D"
#                              fi
#                         elif [[ "$char1$char2$char3" == "OF" ]];then
#                              horizptr="$(( ${#scratchpad} ))"
#                              printf "\r\033[${#scratchpad}C"
#                         elif [[ "$char1$char2$char3" == "OH" ]];then
#                              horizptr="0"
#                              printf "\r"
#                         elif [[ "$char1$char2$char3" == "[3~" ]];then
#                              if [[ $(( ${horizptr} )) -lt $(( ${#scratchpad} )) ]];then
#                                   scratchpad="${scratchpad:0:horizptr}${scratchpad:horizptr+1}" # handles the delete character
#                                   printf "${scratchpad:horizptr}\033[K\r${scratchpad:0:horizptr}"
#                              fi
                         fi
                ;;
                *) : # TODO: Any other key, go to next entry that begins with that character
                ;;
                esac
            key=""
            done
        done
fi
<<EOF
#insert       27,91,50,126,0,
#home         27,91,72,0,0,
#page up      27,91,53,126,0,
#delete       27,91,54,126,0,
#end          27,91,70,0,0,
#page down    27,91,54,126,0,
#backspace    127,0,0,0,0,
#esc          27,0,0,0,0,
#F1
#F2           27,79,81,0,0,
#F3           27,79,82,0,0,
#F4           27,91,49,53,126,
#F5           27,91,49,55,126,
#F6           27,91,49,56,126,
#F7           27,91,49,57,126,
#F8           27,91,49,57,126,
#F9           27,91,50,48,126,
#F10
#F11
#F12          27,91,50,52,126,
#up arrow     27,91,65,0,0,
#down arrow   27,91,66,0,0,
#left arrow   27,91,68,0,0,
#right arrow  27,91,67,0,0,
#space bar    32,0,0,0,0,
#tab          9,0,0,0,0,
EOF
}

#Why we use whereis instead of locate: 1.  because locate will see too many directories...like "Downloads" and, in the event of VMWare being present, the files of other virtual machines.
# and #2: locate results are only as current as the last cron-scheduled update of its database while apps like poofitee that install supporting tools need immediate-after-install currency
usrdir="";localdir="";sharedir="";bindir="";sbindir="";binaryflag="-b";dirsign="";counter=0
D2b=({0..1}{0..1}{0..1}{0..1}{0..1}{0..1})
until whereispath="$usrdir$localdir$sharedir$bindir$sbindir$dirsign""whereis";[[ ++counter -eq 64 ]] || [[ "$($whereispath $binaryflag whereis &> /dev/null;echo $?)" == "0" ]];do
    ! [[ -z "$binaryflag" ]] && binaryflag="" && continue
    binaryflag="-b"
    dirsign="/"
    usrdir="";localdir="";sharedir="";bindir="";sbindir=""
    cntr="${D2b[counter]}"
    [[ "$cntr" =~ ^1 ]] && usrdir="/usr"
    [[ "$cntr" =~ ^.1 ]] && localdir="/local"
    [[ "$cntr" =~ ^..1 ]] && sharedir="/share"
    [[ "$cntr" =~ ^...1 ]] && bindir="/bin"
    [[ "$cntr" =~ ^....1 ]] && sbindir="/sbin"
done
if [[ counter -eq 64 ]];then echo "Unable to locate executable files on your system";exit;fi
whereispath="${whereispath#*:}";whereispath="${whereispath# }";whereispath="${whereispath%% *}"
[[ -z "$binaryflag" ]] && "$whereispath -b whereis" && binaryflag="-b"
resizepath="$($whereispath $binaryflag resize)";resizepath="${resizepath#*:}";resizepath="${resizepath# }";resizepath="${resizepath%% *}"
pspath="$($whereispath $binaryflag ps)";pspath="${pspath#*:}";pspath="${pspath# }";pspath="${pspath%% *}"
greppath="$($whereispath $binaryflag grep)";greppath="${greppath#*:}";greppath="${greppath# }";greppath="${greppath%% *}"
ippath="$($whereispath $binaryflag ip)";ippath="${ippath#*:}";ippath="${ippath# }";ippath="${ippath%% *}"
wcpath="$($whereispath $binaryflag wc)";wcpath="${wcpath#*:}";wcpath="${wcpath# }";wcpath="${wcpath%% *}"
sedpath="$($whereispath $binaryflag sed)";sedpath="${sedpath#*:}";sedpath="${sedpath# }";sedpath="${sedpath%% *}"
rhelchkconfigpath="$($whereispath $binaryflag chkconfig)";rhelchkconfigpath="${rhelchkconfigpath#*:}";rhelchkconfigpath="${rhelchkconfigpath# }";rhelchkconfigpath="${rhelchkconfigpath%% *}"
if [[ "$*" =~ ^awk=/ ]] || [[ "$*" =~ \ awk=/ ]];then
    index=1
    for arg in "$@"
    do
        [[ "${arg#*'awk='}" == "$arg" ]] || awkpath="${arg#*'awk='}"
        ! [[ -z "$awkpath" ]] && break
        let "index+=1"
    done
else
     awkpath="$($whereispath $binaryflag awk)"
     awkpath="${awkpath#*:}";awkpath="${awkpath# }";awkpath="${awkpath%% *}"
fi
headpath="$($whereispath $binaryflag head)";headpath="${headpath#*:}";headpath="${headpath# }";headpath="${headpath%% *}"
curlpath="$($whereispath $binaryflag curl)";curlpath="${curlpath#*:}";curlpath="${curlpath# }";curlpath="${curlpath%% *}"
unamepath="$($whereispath $binaryflag uname)";unamepath="${unamepath#*:}";unamepath="${unamepath# }";unamepath="${unamepath%% *}"
sortpath="$($whereispath $binaryflag sort)";sortpath="${sortpath#*:}";sortpath="${sortpath# }";sortpath="${sortpath%% *}"
filepath="$($whereispath $binaryflag file)";filepath="${filepath#*:}";filepath="${filepath# }";filepath="${filepath%% *}"
lsmodpath="$($whereispath $binaryflag lsmod)";lsmodpath="${lsmodpath#*:}";lsmodpath="${lsmodpath# }";lsmodpath="${lsmodpath%% *}"
# The reject and exit notices should be in order of how extensive of upgrades would be required.  Entire computer first, then OS, then executable version, then installed packages
trap "echo $exitmsg" EXIT
exitmsg="Thank you for running this POOFITEE configuration script...God loves you...pass it on"
dialogpath=""
dialogpath="$($whereispath $binaryflag dialog)";dialogpath="${dialogpath#*:}";dialogpath="${dialogpath# }";dialogpath="${dialogpath%% *}"
whiplogpath="$dialogpath"
[[ -z "$dialogpath" ]] && whiptailpath="$($whereispath $binaryflag whiptail)";whiptailpath="${whiptailpath#*:}";whiptailpath="${whiptailpath# }";whiptailpath="${whiptailpath%% *}"
[[ -z "$dialogpath" ]] && whiplogpath="$whiptailpath"
tputpath="$($whereispath $binaryflag tput)" ;tputpath="${tputpath#*:}";tputpath="${tputpath# }";tputpath="${tputpath%% *}"
globalbacktitle="Required Reading  POOFITEE  $version"
if [[ "$($unamepath)" =~ BSD ]] || [[ "$($unamepath)" =~ Darwin ]];then
    failreason="  This firewalling solution does not accommodate Mac nor BSD due to \
iptables and crontab dysfunction in those *NIXes"
fi
if ! [[ "$($filepath "/bin/bash")" =~ ^/bin/bash:\ ELF ]];then
    failreason+="\n\n  This version of POOFITEE is unable to run on non-ELF platforms \
such as yours simply because it's cron=scheduled 'tail -F ... /var/log/syslog' entry requires stdbuf, \
which is available only on OS platforms using ELF."
fi
mkdir /tmp/fifos_and_temp_files_for_poofitee_installer 2>/dev/null
touch /tmp/fifos_and_temp_files_for_poofitee_installer/file_create_rights_test 2>/dev/null
rm /tmp/fifos_and_temp_files_for_poofitee_installer/file_create_rights_test &>/dev/null || \
    failreason+="\n\n  Unable to create files the temporary directory needed: /tmp/fifos_and_temp_files_for_poofitee_installer"
if ! [[ -z "$failreason" ]];then
    failreason="<center>THANK YOU FOR TRYING THIS POOFITEE INSTALLER, BUT...\
\nYOU CANNOT RUN POOFITEE INSTALLER WITH YOUR OPERATING SYSTEM FOR THE FOLLOWING REASON[S]:\n\n$failreason$([[ -z "$whiptailpath" ]] && printf -- "\n\nPress any key...")"
    localbacktitle="Exit Notice  POOFITEE  $version"
    showthis "$failreason" infobox "$localtitle" "$localbacktitle"
    ! [[ -z "$dialogpath" ]] && read -sn1;read -rst 0.001 -n4 discard
    exit
fi
#We'll place this installer path variable here for future use possibly to inform in the next warning section
installers=("apt-get" "-y install" dnf install yum "-y install" zypper install emerge "" pacman "--noconfirm -S" pkg install  pkg_add "" xbps-install -Sy brew install port install)
num_of_installers="${!installers[*]}"
num_of_installers="${num_of_installers##* }"
num_of_installers=$(((num_of_installers +1) / 2))
for installer_index in `seq 0 $num_of_installers`;do
    installer_index=$((installer_index * 2))
    installerpath="$($whereispath $binaryflag ${installers[$((installer_index))]})";installerpath="${installerpath#*:}";installerpath="${installerpath# }";installerpath="${installerpath%% *}";installerpath="${installerpath%%:*}"
    ! [[ -z "$installerpath" ]] && installerpath+="  ${installers[$(($installer_index + 1))]}" && break
done
min_bash_version_tested="4.3.11"
attention="YOUR COOPERATION OR ATTENTION IS NEEDED"
if ! [[ "$($sortpath <<<"$(printf "$BASH_VERSION\n$min_bash_version_tested")"|$headpath -n 1)" == "$min_bash_version_tested" ]];then
   localwarning+=" run-time errors, your version of bash might be too old."
   trap "echo If you had$localwarning $exitmsg" EXIT
   localwarning="\nThe bash shell version running now is older than what this script was written \
and tested in.  If you experience$localwarning\n"
fi
if ! [ "$(whoami)" == "root" ];then
    ! [[ -z "$localwarning" ]] && localwarning+="\nAdditionally, \n"
    localwarning+="\nWithout being launched by su, this script won't be able to do anything except \
display menus.  No installation on this computer can be made by this script unless \
re-launched by root.\n"
fi
sudopath="$($whereispath $binaryflag sudo)";sudopath="${sudopath#*:}";sudopath="${sudopath# }";sudopath="${sudopath%% *}"
if  [[ -z "$sudopath" ]];then
    ! [[ -z "$localwarning" ]] && localwarning+="\nAdditionally, \n"
    localwarning+="\nThe actual sudo command is necessary for several aspects of this installer, \
but cannot be found.  Please install it before continuing.  Use another window or end this \
script and restart it later.  In Arch Linux you may install sudo using \
the following command:\n\n		pacman -Syy --noconfirm base-devel\n"
fi
if [[ "$*" =~ ^awk=/ ]] || [[ "$*" =~ \ awk=/ ]];then
    index=1
    for arg in "$@"
    do
        [[ "${arg#*'awk='}" == "$arg" ]] || awkpath="${arg#*'awk='}"
        ! [[ -z "$awkpath" ]] && break
        let "index+=1"
    done
else
     awkpath="$($whereispath $binaryflag awk)"
     awkpath="${awkpath#*:}";awkpath="${awkpath# }";awkpath="${awkpath%% *}"
fi
#force these to be global variables, we need them to perform the install:
gawkpath=""
mawkpath=""
# pythonpath="$($whereispath $binaryflag python)";pythonpath="${pythonpath#*:}";pythonpath="${pythonpath# }";pythonpath="${pythonpath%% *}"
ifconfigpath="$($whereispath $binaryflag ifconfig)";ifconfigpath="${ifconfigpath#*:}";ifconfigpath="${ifconfigpath# }";ifconfigpath="${ifconfigpath%% *}"
uniqpath="$($whereispath $binaryflag uniq)";uniqpath="${uniqpath#*:}";uniqpath="${uniqpath# }";uniqpath="${uniqpath%% *}"
findpath="$($whereispath $binaryflag find)";findpath="${findpath#*:}";findpath="${findpath# }";findpath="${findpath%% *}";
tailpath="$($whereispath $binaryflag tail)";tailpath="${tailpath#*:}";tailpath="${tailpath# }";tailpath="${tailpath%% *}"
xargspath="$($whereispath $binaryflag xargs)";xargspath="${xargspath#*:}";xargspath="${xargspath# }";xargspath="${xargspath%% *}"
getentpath="$($whereispath $binaryflag getent)";getentpath="${getentpath#*:}";getentpath="${getentpath# }";getentpath="${getentpath%% *}"
adduserpath="$(whereis $binaryflag adduser)";adduserpath="${adduserpath#*:}";adduserpath="${adduserpath# }";adduserpath="${adduserpath%% *}"
[[ -z "$adduserpath" ]] && adduserpath="$(whereis $binaryflag useradd)";adduserpath="${adduserpath#*:}";adduserpath="${adduserpath# }";adduserpath="${adduserpath%% *}"
passwdpath="$($whereispath $binaryflag passwd)";passwdpath="${passwdpath#*:}";passwdpath="${passwdpath# }";passwdpath="${passwdpath%% *}";
for pgm in ifconfig uniq find tail xargs getent adduser;do
    if [[ -z "$(eval printf -- "\$$pgm""path" 2>/dev/null)" ]];then
        localwarning+="\n$pgm needs to be installed\n"
    fi
done
localbacktitle="Deficiency Notice  POOFITEE  $version"
if ! [[ -z "$localwarning" ]];then
    localwarning="<center>Your operating system is not entirely adequate:\n\n""$localwarning" # "$([[ -z "$whiptailpath" ]] && printf -- "\n\npress any key, Ctrl-c aborts....")"
    showthis "$localwarning" msgbox "$attention" "$localbacktitle" 0 -- "" ""
#    ! [[ -z "$dialogpath" ]] && read -sn1;read -rst 0.001 -n3 discard #Need for this line depends on which box is utilized
fi
if  [[ -z "$sudopath" ]];then
    showthis "The actual sudo command is necessary for several aspects of this installer, \
but it cannot be found.  Please install it before continuing.  Use another window or \
end this script and restart it later.  In Arch Linux you may install sudo using \
the following command:\
\n\n       pacman -Syy --noconfirm base-devel\n" infobox "Reminder Notice" "$globalbacktitle"
    ! [[ -z "$dialogpath" ]] && (printf "\r";press_a_key)
    sudopath="$($whereispath $binaryflag sudo)";sudopath="${sudopath#*:}";sudopath="${sudopath# }";sudopath="${sudopath%% *}"
fi
#  Beginning of copyright message
clear
showthis "\n<center>POOFITEE IS CURRENTLY AVAILABLE IN EXPERIMENTAL STATUS\
\n\n\nSpecifically -\
\n\n - No ability to configure either virtual or normal interfaces for you.  Little or no \
testing has been done in a virtual interface environment, but no problems per se are expected.\
\n\n - No ability to differentiate between, nor work with, initsystem types.  \
So for persistence of the  this script installs, you're on your own.\
\n\n - No command line help, package [un]installation including dependency tracking, \
nor man (reference manual pager) support is provided.\
\n\n - If loadable modules for iptables are not automatically loaded in your Linux \
kernel as it is configured, some options of poofitee will end execution \
of this script early and inform you to manually load the ipset module, \
a one-time necessary event. Currently, poofitee is not advanced enough to \
load kernel modules itself.\
\n\n - The source code is not beautified and full of extraneous reminders helpful to the script\'s development team.\
\n\n - Enhancements are being added weekly or even more often\
\n\n\n<center>Your suggestions for improvements are solicited and \
welcome.  Use the POOFITEE Wiki to offer them...\
\n\n\n<center>Copyright 2016 - Kenneth L. Anderson MCSE, RDH, BGS, BT\
\n\n\nThis work of authorship is made available to you under only one out of the \
following two arrangements.  In both arrangements, this copyright message must \
remain with this work of authorship and any and all of its derivatives.\
\n\n1.  Arrangement for your freedom from monetary obligation to the author:\
\n - This copyright message must continue to be displayed at launch time\
\n - This copyright message includes the statement\
\n\n<center>\"Jesus Christ is Lord of all ... press key/click OK to acknowledge\"\
\n\ndisplayed on its own line with blank lines adjacently both above and below \
said statement and rendered statically without attempt made to render said \
statement transiently.\
\n\n2.  Arrangement for your freedom from copyright display obligation, or to \
contribute, see the comments within the source code of this script.\
\n\n<center>Jesus Christ is Lord of all ... press a key/click OK to acknowledge" \
msgbox \
"Limitations and Copyright" \
"Copyright Screen  POOFITEE  $version"
# Dialog won't scroll infobox!  It needs to be something besides infobox for longer messages
#    ! [[ -z "$dialogpath" ]] && (printf "\r";press_a_key)
pumppath="$($whereispath $binaryflag pump)";pumppath="${pumppath#*:}";pumppath="${pumppath# }";pumppath="${pumppath%% *}"
# dhcp_lease_path=$($findpath / -maxdepth 5 -name dhclient*.lease* 2> /dev/null)
# eval "$pythonpath -c \"import platform;print(platform.linux_distribution()[0])\" &> /dev/null > "/tmp/fifos_and_temp_files_for_poofitee_installer\distributionby.${0#*/}\"" \
#    || (eval "printf \"Functionality may be limited due to inability to determine distribution type\n";press_a_key) \
#    || eval "echo $OSTYPE > "/tmp/fifos_and_temp_files_for_poofitee_installer\distributionby.${0#*/}\""
# eval "$ifconfigpath -a|$awkpath -F'^ ' '{print \$1}'|$awkpath '{print \$1}'|$greppath -vw lo|$xargspath" > "interfacesby.${0#*/}"
# Introduction ? and what we'll do
# POOFITEE: "Packet filtering Owner Only access linux Firewall - the system is Invisible To Everyone Else"
external_net_interface="$($ippath -o route get 8.8.8.8 2>/dev/null|$awkpath '{for (i=1;i<=NF;i++) {if ($i=="dev"){ print $(i+1);exit }}}')"
internal_net_interfaces="$($ippath link show|$greppath -E "^[1-9][0-9]*:"|$greppath -vw lo:\
    |$greppath -vw "$external_net_interface"\
    |$sedpath 's/://g'\
    |$awkpath '{print $2}')"
! [[ -z "$internal_net_interfaces" ]] && internal_net_interfaces+="\n"
likeliest_internal_net_interface="$(printf "$internal_net_interfaces"|$headpath -n1)"
if  [[ -z "$external_net_interface" ]];then
    internal_net_interfaces="$($ippath link show|$greppath -E "^[1-9][0-9]*:"|$greppath -vw lo:\
        |$sedpath 's/://g'\
        |$awkpath '{print $2}')"
    ! [[ -z "$internal_net_interfaces" ]] && internal_net_interfaces+="\n"
    until ! [[ -z "$external_net_interface" ]];do
        rm /tmp/fifos_and_temp_files_for_poofitee_installer/answergui 2>/dev/null
        clear
        showthis "\n<center>Unable to identify an Internet connection\n\nType in/select the name of the Internet-\
facing interface from the following choices, but even so, without Internet access no dependency packages can be installed (obviously):\n" \
            radiolist "$attention" "$globalbacktitle" $(printf "$internal_net_interfaces"|$wcpath -l) \
             $($ippath link show|$greppath -E "^[1-9][0-9]*:"|$greppath -vw lo:\
             |$sedpath 's/://g'\
             |$awkpath '{print $2" OFF"}')
        [[ -f /tmp/fifos_and_temp_files_for_poofitee_installer/answergui ]] && [[ $(($(wc -l < /tmp/fifos_and_temp_files_for_poofitee_installer/answergui))) -gt 0 ]] && \
            external_net_interface=$(cat /tmp/fifos_and_temp_files_for_poofitee_installer/answergui 2>/dev/null) || \
            $ippath link show|$greppath -E "^[1-9][0-9]*:"|$greppath -v lo:\
             |$sedpath 's/://g'\
             |$awkpath '{print "-> "$2}' >/dev/null \
               && external_net_interface="" \
               && read -er external_net_interface
        printf "$internal_net_interfaces"|$greppath -w $external_net_interface &>/dev/null\
            && internal_net_interfaces="$($ippath link show|$greppath -E "^[1-9][0-9]*:"|$greppath -vw lo:\
               |$greppath -vw "$external_net_interface"\
               |$sedpath 's/://g'\
               |$awkpath '{print $2}')" \
            || external_net_interface=""
    done
fi
maintitle="SELECT DESIRED OPTIONS FOR THIS INSTALLATION"
mainbacktitle="Main Menu  POOFITEE  $version"
mainchecklisttest="\n<center>Select with spacebar/tab... all or any services listed below that \
you want, then enter/OK\n"
if [[ $($pspath aux|$greppath -vw grep|$greppath -we pump -we dhclient -we udhcpc -we dhcpcd -we dhclient3|$greppath -w $external_net_interface|$wcpath -l) -eq 0 ]] \
       || ! [[ $(firewall_external_interface_not_in_privateIP_ranges;printf "$?") =~ ^123$ ]];then
    notdhcp="notdhcp"
    mainchecklisttest+="<center>(Not available with this IP address: dynamic IP address change notifier)\n"
fi
maincheckitems=("firewalling" \
"email remote control" \
"dynamic IP address change notifier" \
"port knocking" \
"lists (white, black, & static_trusted) to/from storage" \
"copy current configuration to a storage medium" \
"restore the previously saved configuration" \
"helpful information, alone or in context" \
"quit (or Tab/Enter key with no selections)" \
"f" \
"e" \
"d" \
"p" \
"c" \
"l" \
"r" \
"q" \
"?")
answer=""
ghbacktitle="Main Menu  POOFITEE  $version"
ghscreen1="This Linux script can install several Internet security features useful \
in homeowner and enterprise systems alike. Enterprise systems however, typically \
are stranger-visible, but POOFITEE ruleset produces stranger-INvisibility.  Gone \
are the complex, buggy \"badguy detection\" algorithms of other firewalls.  More \
unique still to POOFITEE is that the only continuously-running process it has is \
a \"tail -f\" bash script line monitoring kernel log events for the purpose of \
launching a script.  So POOFITEE is a firewall-plus paradigm, not a running \
program.  For a similar reason, it is not an iptables front-end and does not \
interfere with manual iptables manipluation, allowing you to fine-tune the rule-\
set yourself.  Only trusted addresses can initiate a dialog under the POOFITEE \
ruleset.  Of course, those source addresses can be spoofed, but when spoofed, a \
two-way connection capable of stealing information is not really possible: the \
legitimate computer owning the spoofed trusted address will receive return \
communications and, without a reason to be in collusion with the spoofer, not \
relay the information on to them.  Where public services are hosted, POOFITEE is \
capable of adding pseudo application-layer/stateful protection to mere packet \
filtering by virtue of a combination of delayed blacklisting and log file \
monitoring: well-behaving, never-previously-blacklisted sources not inside \
blacklisted network ranges can be whitelisted (non-persistent by default) if \
they generate log file activity you've specified within some number of minutes.  \
\"POOFITEE\" is derived from the descriptive phrase \"Packet filtering Owner Only\
access Firewall - Invisible To Everyone Else\"."
ghscreen2="\n\nThe advantages of using scripting over a compiled program are significant:\
\n\n - most importantly - robust operation in indefinitely continuous duty\
\n\n - less script complexity means less risk of programming bugs and \
mysterious, hard-to-troubleshoot resource limitations\
\n\n - source code is simple and extremely easy for you to customize to your \
liking\
\n\n - iptables rule changes are implemented instantly without any process \
restarts nor conflicts with iptables rules manipulated manually\
\n\n - system operators can customize the behavior of all aspects of \
POOFITEE support scripts without learning to compile, and those \
customizations are implemented instantly."
prefix="( As you read, please realize the difference between this installation \"helper \
script\" that you are running now and the \"script set\" it helps you install )\
\n"
postfix="\n\n* No testing has been done using DHCP client nor server on the private interface"
fwscreen="$prefix""To configure firewalling, port-knocking, or email remote control, iptables & \
netfilter-persistent are required if not already present.  These are standard \
for any Linux firewalling.  As far as manual control of iptables during run \
time, POOFITEE plays fair.  It will simply configure iptables - an \
initial configuration by the helper script, then periodic configurations of \
iptables throughout the course of normal operations by the installed script set.  \
Unlike what exists with ufw, shorewall, and fail2ban, no ongoing integration \
with iptables will exist to interfere at any time with direct user adjustment of \
the iptables ruleset.\
\nFirewalling options this install script can alter from the script set defaults:\
\n  -- Stop probe logging/blacklisting to save space or if you're just not curious\
\n  -- Open specific ports to allow http, irc and/or other public services hosting\
\n  -- Force single-interface firewalling even though two interfaces exist""$postfix"
rcscreen="$prefix""What we mean by Remote Control Via Email:  You find yourself travelling far \
from home, and thus, far away from this computer you are configuring.  You \
decide you need this computer to do a few things for you now before you return.  \
One is to turn on and off one of the electrical outlets that it controls through \
a USB-connected Arduino board.  You also remember that there is an old iptables \
rule whitelisting an IP address that belongs no longer belongs to you, so you \
need your home system to remove it from the iptables whitelist.  This and more \
is possible if you just connect that Arduino you've built and run this script.  \
This helper script will need from you name and password of the email account \
that this computer will retrieve the emails from that you send to it.  This \
helper script will test its functionality and give you a choice of which port \
number you want to use (knock) to trigger your system to read and parse emails.  \
Ideally, you would want to choose a port number that never gets probed by \
the hackers of the world.  Logging probed ports (configured in the firewall \
section of this helper script) would be a handy reference here.""$postfix"
dascreen="$prefix""To configure firewalling, port-knocking, or email remote control, iptables &\
netfilter-persistent are required if not already present.  These are standard\
for any Linux firewalling.  As far as manual control of iptables during run\
time, this script set is friendly.  It will simply configure iptables - an\
initial configuration by the helper script, then periodic configurations of\
iptables throughout the course of normal operations by the installed script set.\
Unlike what exists with ufw, shorewall, and fail2ban, no ongoing integration\
with iptables will exist to interfere at any time with direct user adjustment of\
the iptables ruleset.\
\nFirewalling options this install script can alter from the script set defaults:\
\n  -- Stop probe logging/blacklisting to save space or if you're just not curious\
\n  -- Open specific ports to offer public services\
\n  -- Force single-interface firewalling even though two interfaces exist\
\n  -- Alter the IP address of the private-side interface from 192.168.3.1"\
"$postfix"
pkscreen="$prefix""To configure firewalling, port-knocking, or email remote control, iptables &\
netfilter-persistent are required if not already present.  These are standard\
for any Linux firewalling.  As far as manual control of iptables during run\
time, this script set is friendly.  It will simply configure iptables - an\
initial configuration by the helper script, then periodic configurations of\
iptables throughout the course of normal operations by the installed script set.\
Unlike what exists with ufw, shorewall, and fail2ban, no ongoing integration\
with iptables will exist to interfere at any time with direct user adjustment of\
the iptables ruleset.\
\nFirewalling options this install script can alter from the script set defaults:\
\n  -- Stop probe logging/blacklisting to save space or if you're just not curious\
\n  -- Open specific ports to offer public services\
\n  -- Force single-interface firewalling even though two interfaces exist\
\n  -- Alter the IP address of the private-side interface from 192.168.3.1"\
"$postfix"
listscreen="These lists are specific to an iptables extention called ipset.  This menu \
option allows you to enter, archive or transfer the ip address lists that you\
may have compiled from using POOFITEE or through another means.  Each list is of\
ip addresses is handled in two forms not intended to be mixed: CIDR &\
individual.  If entering a list or lists, you will actually enter the addresses\
as a single compilation of both address types, and the two types will get\
separated for you.  Each list entry can include a comment that conforms to the\
style required by ipset, including the fact that any and all double-quote marks\
will be discarded before saving the entry to the destination list.  You will be\
asked to indicate whether you are configuring ipset to utilize the list or lists\
of your choice inputted from stdin (keyboard or a normal file), displaying the\
lists active in ipset as currently running, or saving to storage the list or\
lists of your choice from ipset as currently configured."
savescreen="Selecting this is only meaningful if one or more of the above selections is also \
selected or has previously been configured.  Saving the configuration with this\
choice is a convenient way for you to replicate the configuration on other\
servers or prepare for an operating system upgrade on this one.  You'll be\
given a choice where to store the saved configuration, whether locally or on\
removeable media or remotely."
restorescreen="This is a convenient way to replicate the configuration on other servers or on \
this one after an operating system upgrade without answering the setup questions\
all over again.  This can be highly important when you don't know for sure that\
the person who needs to configure will know or remember the details of this\
configuration."
singinterf="Based on finding only one pluggable network interface, your intentions seem \
to be to have this firewalling computer be a terminal (end) device rather than \
an inline (passthrough) device.  That would result in any protective \
firewalling you'll set up next to apply only to this computer.  If instead you \
want this firewalling computer to protect other devices with its firewalling \
services, select"
infobacktitle="Information Screen  POOFITEE  $version"
postfix_already_conf=""
quitrow=""
index=0
# TODO: compress the following if construct into just a for construct
if [[ "$notdhcp" == "notdhcp" ]];then
    for letter in f e p l c r \? q;do
        chararray[index]=$letter
        index=$((index + 1))
    done
else
    for letter in f e d p l c r \? q;do
        chararray[index]=$letter
        index=$((index + 1))
    done
fi
answer=""
until ! [[ -z "$answer" ]];do
    if ! [[ -z "$notdhcp" ]] && [[ "$notdhcp" == "notdhcp" ]];then
        showthis "$mainchecklisttest" checklist "$maintitle" "$mainbacktitle" 8 \
        "${maincheckitems[0]}" OFF \
        "${maincheckitems[1]}" OFF \
        "${maincheckitems[3]}" OFF \
        "${maincheckitems[4]}" OFF \
        "${maincheckitems[5]}" OFF \
        "${maincheckitems[6]}" OFF \
        "${maincheckitems[7]}" OFF \
        "${maincheckitems[8]}" OFF
    else
        showthis "$mainchecklisttest" checklist "$maintitle" "$mainbacktitle" 9 \
        "${maincheckitems[0]}" OFF \
        "${maincheckitems[1]}" OFF \
        "${maincheckitems[2]}" OFF \
        "${maincheckitems[3]}" OFF \
        "${maincheckitems[4]}" OFF \
        "${maincheckitems[5]}" OFF \
        "${maincheckitems[6]}" OFF \
        "${maincheckitems[7]}" OFF \
        "${maincheckitems[8]}" OFF
    fi
#    [ "$?" == "0" ] && exit
#clear
    answer=""
    while read line;do # change numbers to letters for compatibility with original code
        ! [[ -z "$line" ]] && answer+=${chararray[$((line))]}
    done < /tmp/fifos_and_temp_files_for_poofitee_installer/answergui
#    rm /tmp/fifos_and_temp_files_for_poofitee_installer/answergui
    if [[ $answer =~ q ]] || [[ ${#answer} -eq 0 ]];then
        $tputpath cup $((quitrow)) 0
        exit
    fi
    clear
    if [[ $answer =~ \? ]];then
#        printf "  Since info is selected, no changes are to be made"
        if [[ $answer == "?" ]];then
            showthis "$ghscreen1" msgbox \
            "HELPER SCRIPT OVERVIEW" \
            "$infobacktitle" \
            --yes-button "Scrolled, now proceed" \
            --no-button "Quit now" \
            --scrolltext 22 76
            [ "$?" != "0" ] && exit
            printf "\r"
#            press_a_key # Would need with infobox
            showthis "$ghscreen2" msgbox \
            "HELPER SCRIPT OVERVIEW" \
            "$infobacktitle" \
            --yes-button "Scrolled, now proceed" \
            --no-button "Quit now" \
            --scrolltext 22 76
            [ "$?" != "0" ] && exit
            printf "\r"
#            press_a_key # Would need with infobox
        fi
        if [[ $answer =~ f ]] || [[ $answer == "?" ]];then
            showthis "$fwscreen" msgbox \
            "FIREWALLING WITH THIS SCRIPT SET" \
            "$infobacktitle" \
            "$ghscreen1""$fwscreen" \
            --yes-button "Scrolled, now proceed" \
            --no-button "Quit now" \
            --scrolltext 22 76
            [ "$?" != "0" ] && exit
            printf "\r"
#            press_a_key # Would need with infobox
        fi
        if [[ $answer =~ e ]] || [[ $answer == "?" ]];then
            showthis "$rcscreen" msgbox \
            "REMOTE CONTROL VIA EMAIL WITH THIS SCRIPT SET" \
            "$infobacktitle" \
             \
            --yes-button "Scrolled, now proceed" \
            --no-button "Quit now" \
            --scrolltext 22 76
            [ "$?" != "0" ] && exit
            printf "\r"
#            press_a_key # Would need with infobox
        fi
        if [[ $answer =~ d ]] || [[ $answer == "?" ]];then
            showthis "$dascreen" msgbox \
            "PORT KNOCKING WITH THIS SCRIPT SET" \
            "$infobacktitle" \
            --yes-button "Scrolled, now proceed" \
            --no-button "Quit now" \
            --scrolltext 22 76
            [ "$?" != "0" ] && exit
            printf "\r"
#            press_a_key # Would need with infobox
        fi
        if [[ $answer =~ p ]] || [[ $answer == "?" ]];then
            showthis "$pkscreen" msgbox \
            "BLACK, WHITE, & STATIC_TRUSTED FIREWALL LISTS" \
            "$infobacktitle" \
            --yes-button "Scrolled, now proceed" \
            --no-button "Quit now" \
            --scrolltext 22 76
            [ "$?" != "0" ] && exit
            printf "\r"
#            press_a_key # Would need with infobox
        fi
        if [[ $answer =~ l ]] || [[ $answer == "?" ]];then
            showthis "$listscreen" msgbox \
            "EMAIL NOTIFY OF DYNAMIC IP ADDRESS CHANGE WITH THIS SCRIPT SET" \
            "$infobacktitle" \
            --yes-button "Scrolled, now proceed" \
            --no-button "Quit now" \
            --scrolltext 22 76
            [ "$?" != "0" ] && exit
            printf "\r"
#            press_a_key # Would need with infobox
        fi
        if [[ $answer =~ s ]] || [[ $answer == "?" ]];then
            showthis "$savescreen" msgbox \
            "SAVING YOUR INSTALLED CONFIGURATION" \
            "$infobacktitle" \
            --yes-button "Scrolled, now proceed" \
            --no-button "Quit now" \
            --scrolltext 22 76
            [ "$?" != "0" ] && exit
            printf "\r"
#            press_a_key # Would need with infobox
        fi
        if [[ $answer =~ r ]] || [[ $answer == "?" ]];then
            showthis "$restorescreen" msgbox \
            "RESTORING YOUR PREVIOUSLY SAVED CONFIGURATION" \
            "$infobacktitle" \
            --yes-button "Scrolled, now proceed" \
            --no-button "Quit now" \
            --scrolltext 22 76
            [ "$?" != "0" ] && exit
            printf "\r"
#            press_a_key # Would need with infobox
        fi
        answer=""
    else
#  1.  Accept selections from main screen
#  2.  determine if any packages need installing, warn if no known installer found
#  3.  Install the packages needed by the particular selections, except for mail
#      -- if an installer is not found, inform operator to install listed programs
# In Ubuntu (and probably Debian), install the ipset and xtables-addons-source packages. Then, run module-assistant auto-install xtables-addons, and ipset is ready to test
#  packages required to install everything
        echo
        notinstalled="."
        until [ -z "$notinstalled" ];do  # this loop is to set path vars after pkgs get installed, every last pkg so paths populate even after new installs
            until ! [ -z "$goahead" ] && ! [ -z "$ackd" ] && [ "$goahead" == "true" ] || [ "$ackd" == "true" ];do
                  what_needs_to_be_installed checkawk
#                  printf "There are $(what_needs_to_be_installed;echo "$?") things needing to be installed";read -srn1
                  [[ "$?" == "0" ]] && break 2
                  ground_zero_install_needs="$not_installed_single_line"

#                  installers=("DEBIAN_FRONTEND=noninteractive apt-get" "install --fix-missing --force-yes" dnf install yum install zypper install emerge "" pacman -S pkg install pkg_add "" xbps-install -Sy brew install port install)
                  for installer in {0..10};do
                       installerpath=$($whereispath $binaryflag ${installers[$(($installer * 2))]});installerpath="${installerpath#*:}";installerpath="${installerpath# }";installerpath="${installerpath%% *}";installerpath="${installerpath%%:*}"
                       [[ -z "$installerpath" ]] && continue
                       installerpath+="  ${installers[$(($installer * 2 + 1))]}"
                       break
                  done
                  if [[ -z "$installerpath" ]] && ! [[ "$ackd" == "true" ]];then
                       not_advanced_enough="1"
                       showthis "\n<center>$attention\
\n\nThis POOFITEE installer version is not advanced enough to install needed \
programs$(! [[ -z "$not_advanced_enough" ]] && printf \
" on systems such as yours that don\'t use one of the more common package \
installers to install packages").\
\n\nFor this install script to serve its purpose,  you'll need to install all \
necessary programs yourself before anything referenced hereafter can succeed.  \
Consider yourself lucky if this script does anything at all for you beyond this \
point, but do understand that the programs most certainly won't get installed.\
\n\nThe necessary programs that won't get installed until you install them are:\
\n$notinstalled\
\n\nYou may install those packages OR a more common package installer for this \
installer to work with (in another terminal window, of course) and resume here." \
                       msgbox "$attention" "$localbacktitle" 0 -- "" ""
                       press_a_key
                       ackd="true"
                  elif [[ -z "$installerpath" ]];then
                       goahead="true"
                  else
                       break
                  fi
            done # this loops here once when installer pgm not found
        # in Ubuntu 15.10 and in /usr/share/netfilter-persistent/plugins.d there is a file called 15-ip4tables that needs to be edited and properly referenced elsewhere: 
#        need_file="/usr/share/netfilter-persistent/plugins.d/15-ip4tables"
#        if ! [[ -f $need_file ]];then
#             printf "\n\nUnknown configuration.  Modify this script yourself to accomodate it:\
#\nDid not find the expected file $need_file.\n\n"
#             exit
#        fi
# Might need to manually add to /etc/network/interfaces: pre-down /etc/init.d/netfilter-persistent save
            [ -z "$been_here_before" ] && clear
            if ! [ -z "$installerpath" ] && ! [ -z "$not_installed_single_line" ];then # install what is neededpress 
                 if [ -z "$been_here_before" ];then
                      ensure_connection
                      if [[ "$installerpath" =~ apt-get|pacman ]];then
                           printf "Installation of\n$notinstalled\nis required next.  Press u to update your system's package installer first,\
$([[ "$installerpath" =~ apt-get ]] && printf "\npress b to both update your system's package installer & have it run autoremove,")\
\nany other letter or number key not to update the installer first.  \n"
                           press_a_key u $([[ "$installerpath" =~ apt-get ]] && printf "b" || printf "<other-letter-or-number>")
                           if [[ "$installerpath" =~ apt-get ]] && [[ "$REPLY" =~ [Bb] ]];then
                                clear
                                installeranswer="$REPLY"
                                printf "\r\033[KCleaning up with apt-get autoremove...\n"
                                while true;do ps a|$greppath -v grep|$greppath preconfigure &>/dev/null || printf ".";sleep 1;done &
                                progress_dots="$!"
                                apt-get autoremove -y &>/dev/null
                                kill $progress_dots; trap 'kill $progress_dots' SIGTERM
                                REPLY="$installeranswer"
                           fi
                           if [[ "$REPLY" =~ [UuBb] ]];then
                                printf "\r\033[KUpdating your system\'s package installer...\n" # in arch, do pacman -Syuu
                                if [[ "$installerpath" =~ apt-get ]];then
                                    while true;do ps a|$greppath -v grep|$greppath preconfigure &>/dev/null || printf ".";sleep 1;done &
                                    progress_dots="$!"
                                    apt-get update &>/dev/null
                                    kill $progress_dots; trap 'kill $progress_dots' SIGTERM
                                else
                                    pacman --noconfirm -Syuu  # &>/dev/null
                                fi
                           fi
                           been_here_before="been_here_before"
                      fi
                 fi
                 printf "\r\033[KInstalling $not_installed_single_line...\n"
                 eval "$xargspath -a <(printf "$not_installed_single_line") -r -- $sudopath $installerpath" # 2>/dev/null
                 what_needs_to_be_installed # &>/dev/null #sending to null was to try to avoid some screen clutter, but it stops execution dead even before function
#                 press_a_key
# make the following into a function
#switch_from_more_common_package_to_less_common_package dnsutils dig ldns drill
#switch_from_more_common_package_to_less_common_package netfilter-persistent netfilter-persistent iptables-persistent iptables-persistent
# might need to check out http://tldp.org/LDP/abs/html/complexfunct.html
# can uninitialized variables be passed into function by reference?  Of course not!
                 if [[ "$not_installed_single_line" =~ ^netfilter-persistent ]];then
                      if ! [[ -z "$netfilter_persistent_already_given_a_chance" ]];then
                           netfilter_persistent_already_given_a_chance=""
                           iptabsavepath=$($whereispath $binaryflag iptables-save);iptabsavepath="${iptabsavepath#*:}";iptabsavepath="${iptabsavepath# }";iptabsavepath="${iptabsavepath%% *}"
                           if [[ -z "$iptabsavepath" ]];then
                                 eval "$xargspath -a <(printf "$not_installed_single_line"|$sedpath 's/netfilter/iptables/1') -r -- $sudopath $installerpath"
#                 press_a_key
                                 iptabsavepath=$($whereispath $binaryflag "iptables-save");iptabsavepath="${iptabsavepath#*:}";iptabsavepath="${iptabsavepath# }";iptabsavepath="${iptabsavepath%% *}"
                                 netfiltperspath=$($whereispath $binaryflag "iptables-restore");netfiltperspath="${netfiltperspath#*:}";netfiltperspath="${netfiltperspath# }";netfiltperspath="${netfiltperspath%% *}"
                                 what_needs_to_be_installed
                           else
                                 netfiltperspath=$($whereispath $binaryflag "iptables-restore");netfiltperspath="${netfiltperspath#*:}";netfiltperspath="${netfiltperspath# }";netfiltperspath="${netfiltperspath%% *}"
                           fi
                           iptabrestorepath="$netfiltperspath"
                      else
                           netfilter_persistent_already_given_a_chance="already_given_a_chance"
                      fi
                 fi
                 if [[ "$not_installed_single_line" =~ ^cronie ]];then
                      if ! [[ -z "$cronie_already_given_a_chance" ]];then
                           cronie_already_given_a_chance=""
                           crontabpath=$($whereispath $binaryflag crontab);crontabpath="${crontabpath#*:}";crontabpath="${crontabpath# }";crontabpath="${crontabpath%% *}"
                           if [[ -z "$crontabpath" ]];then
                                 eval "$xargspath -a <(printf "$not_installed_single_line"|$sedpath 's/cronie/bcron/1') -r -- $sudopath $installerpath"
#                 press_a_key
                                 crontabpath=$($whereispath $binaryflag crontab);crontabpath="${crontabpath#*:}";crontabpath="${crontabpath# }";crontabpath="${crontabpath%% *}"
                                 what_needs_to_be_installed
                           else
                                 crontabpath=$($whereispath $binaryflag crontab);crontabpath="${crontabpath#*:}";crontabpath="${crontabpath# }";crontabpath="${crontabpath%% *}"
                           fi
                           crontabpath="$crontabpath"
                      else
                          cronie_already_given_a_chance="already_given_a_chance"
                      fi
                 fi
                 if [ $? != "0" ] && [ -z "$previous_not_installed" ] || [ "$(what_needs_to_be_installed;echo "$?")" != "$previous_not_installed" ];then
                      : # keep looping as long as progress is being detected
                      previous_not_installed="$(what_needs_to_be_installed;echo "$?")"
                 elif [ $? != "0" ] && [ "$(what_needs_to_be_installed;echo "$?")" != "$previous_not_installed" ];then
                      :
                 elif [ $? != "0" ] && [ "$(what_needs_to_be_installed;echo "$?")" != "0" ];then
                      if [[ -z "$update_tried" ]];then
                           update_tried="yes"
                           printf "\r\033[KUpdating your system\'s package installer...\n"
                           while true;do ps a|$greppath -v grep|$greppath preconfigure &>/dev/null || printf ".";sleep 1;done &
                           progress_dots="$!"
                           apt-get update &>/dev/null
                           kill $progress_dots; trap 'kill $progress_dots' SIGTERM
                      else
                           printf "\r\033[KThe following $(what_needs_to_be_installed;echo "$?") packages failed to install:\n$notinstalled\
\npress R to retry (recommended as long as progress is being made with repeated\
\nretries), any other alpha-numeric key to ignore:\n"
                           press_a_key r "<other-letter-or-number>" || break
                           printf "\n"
                           for package in "$not_installed_single_line";do
                               eval "$xargspath -a <(printf "$package") -r -- $sudopath $installerpath"
#                 press_a_key
                           done
                           if [[ "$not_installed_single_line" =~ inotify-tools ]];then :
                               cat <<-EOF
				# Download inotify-tools source from http://github.com/downloads/rvoicilas/inotify-tools/inotify-tools-3.14.tar.gz then compile and install:
				# put into /usr/share/inotifywhatever and unzip
				# cd /usr/share/inotifywhatever
				#./configure --prefix=/usr && make && su -c 'make install'
				EOF
                           fi
                      fi
                 fi
            else
                 break
            fi
        done  # this loop is to set path vars after pkgs get installed, every last pkg so paths populate even after new installs
        if ! [[ -z "$ipsetpath" ]];then
            if $ipsetpath list -t >&/dev/null;then :;else
                if $lsmodpath|$greppath -e '^xt_set ' -e '^ip_set '  -e '^ipset ' -e '^xtset ' &>/dev/null;then :;else
                    showthis "\nThe ipset loadable kernel module is not automatically loaded for you.  \
This just happens to be the case with the particular Linux distro you're using.  \
You'll have to load the ipset module manually and restart poofitee installer.  Here \
is a web page that may help you with that:\
\n\n<center>http://www.fwbuilder.org/4.0/docs/users_guide5/Appendix.shtml\n" infobox "$globaltitle" "$globalbacktitle"
                    read -srn1;read -srn5 -t 0.001 discard
#                    exit # this checks to see whether we need to manually load the ipset maodule
                fi
            fi
        fi         
        while true;do
            if ($getentpath passwd|$greppath -w ^poofitee >/dev/null);then
                poofitee_home_dir="$($getentpath passwd|$greppath -w ^poofitee|$awkpath -F: '{printf $6}')"
            else
                poofitee_home_dir="$([[ -f poofitee_home_dir ]] && cat poofitee_home_dir)"
                [[ -z "$poofitee_home_dir" ]] && poofitee_home_dir="$poofitee_home_dir"
                [[ -z "$poofitee_home_dir" ]] && poofitee_home_dir="/home/poofitee"
                clear
                printf "\nSpecify a home directory which will be created for user poofitee, which is where\
\nthese scripts will be installed.  No deeper subdirectory will be used than what\
\nyou specify here, so include any final isolating or descriptive subdirectory\
\nlevel you will want:\n"
               read -eri "$poofitee_home_dir" poofitee_home_dir
               echo
               echo "poofitee ALL=NOPASSWD:ALL" > /etc/sudoers.d/poofitee
#                 echo "poofitee ALL=(ALL) NOPASSWD:ALL" > /etc/sudoers.d/poofitee
               chmod 0440 /etc/sudoers.d/poofitee
               $sedpath -i '/^sudo:.*,poofitee/b; s/^sudo:.*/&,poofitee/' /etc/group
               $adduserpath poofitee --home "$poofitee_home_dir" --system
               user_poofitee_created_this_run="."
               $passwdpath -l poofitee &>/dev/null
            fi
            if ! [[ -d "$poofitee_home_dir" ]];then
                 mkdir -p "$poofitee_home_dir" &>/dev/null \
                     && chown poofitee "$poofitee_home_dir" \
                     && chmod 770 "$poofitee_home_dir" &>/dev/null
                 [[ "$?" == "0" ]] && break
                 echo "Unable to use the path $poofitee_home_dir"
            fi
            if ! [[ -d "$poofitee_home_dir/preparedness" ]];then
                 $sudopath -u poofitee mkdir -p "$poofitee_home_dir/preparedness" &>/dev/null && chmod 700 "$poofitee_home_dir/preparedness" &>/dev/null
                 [[ "$?" == "0" ]] && break
                 echo "Unable to use the path $poofitee_home_dir/preparedness"
            else
                 break
            fi
        done
        echo "$poofitee_home_dir" > poofitee_home_dir # handy with subsequent runs of this script, will know where everything is
        poofitee_home_dir="${poofitee_home_dir%%/}"
        if ! [[  -z "$iptablespath" ]];then
            back_up_iptables_ruleset current && printf "\nIf you feel the changes that this script makes to your iptables ruleset are not\
\nwhat you wanted, restore the current ruleset by running\
\n\niptables-restore < \"$poofitee_home_dir/iptables_ruleset.$current_time\"\n\n" \
               || printf "Your current iptables ruleset did not get backed up as expected.  You should\
\npress ctl-c now and fix that, or you could be in a frustrating situation if\
\nsomething goes awry with this install.\n"
        fi
        chown poofitee "$poofitee_home_dir/iptables_ruleset.$current_time"
#       amount_of_free_memory="$($freepath -b|$awkpath '{if ($1=="Mem:"){printf $4;exit}}')"
        ! [[ -d "$poofitee_home_dir/ramdisk" ]] && $sudopath -u poofitee mkdir "$poofitee_home_dir/ramdisk" &>/dev/null && chown poofitee "$poofitee_home_dir/ramdisk" &>/dev/null
        (mount|$greppath "^tmpfs.*$poofitee_home_dir/ramdisk") &>/dev/null || mount -t tmpfs -o size=0 tmpfs "$poofitee_home_dir/ramdisk" &>/dev/null # the size when set to 0 is not limited.  Let POOFITEE use all it needs
        $greppath "^.*$poofitee_home_dir/ramdisk" < /etc/fstab &>/dev/null || echo "tmpfs      "$poofitee_home_dir/ramdisk"      tmpfs       size=0      0     0" >> /etc/fstab
        if [[ "$answer" =~ e ]];then
#            printf "remote controlling"
            sendmail_works_or_not
            if [[ -z $sendmail_works ]];then
                 outemail_warnings
                 press_a_key
            fi
            conf_postfix
            install_rc
        fi
        if [[ "$answer" =~ l ]];then
            clear;printf -- "       lists (white, black, & static_trusted) to/from storage\
\n\nThis menu option is under development.\
\n\n   s -- Save $ipsetpath sets (blacklist, blacklist_cidr, whitelist, whitelist_cidr,\
\n        static_trusted, and static_trusted_cidr) of this firewall's current\
\n        configuration to files in a directory you will choose\
\n\n   e -- Enter $ipsetpath sets into this firewall's configuration through the keyboard\
\n        or from files that conform to $ipsetpath \'save\' conventions\
\n\n"
            if (press_a_key s e);then
                if ($getentpath passwd|$greppath -w ^poofitee >/dev/null);then
                     directory_for_list_files="$([[ -f "$poofitee_home_dir/directory_for_list_files" ]] && cat "$poofitee_home_dir/directory_for_list_files")"
                     [[ -z "$directory_for_list_files" ]] && directory_for_list_files="$PWD"
                fi
                while printf "\nEnter the directory name where you want the firewall $ipsetpath sets to be saved to:\n";read -eri "$directory_for_list_files" directory_for_list_files;do
                     [[ -d "$directory_for_list_files" ]] && break
                     printf "\nNot a valid directory. Try again.  "
                     press_a_key
                done
                echo "$directory_for_list_files" > "$poofitee_home_dir/directory_for_list_files"
                $ipsetpath save -file "$directory_for_list_files/ipset.sets"
#                   $ipsetpath save blacklist -file "$directory_for_list_files/poofitee_blacklist"
#                   $ipsetpath save blacklist_cidr  -file "$directory_for_list_files/poofitee_blacklist_cidr"
#                   $ipsetpath save whitelist  -file "$directory_for_list_files/poofitee_whitelist"
#                   $ipsetpath save whitelist_cidr  -file "$directory_for_list_files/poofitee_whitelist_cidr"
#                   $ipsetpath save static_trusted  -file "$directory_for_list_files/poofitee_static_trusted"
#                   $ipsetpath save static_trusted_cidr  -file "$directory_for_list_files/poofitee_static_trusted_cidr"
                printf "The files are now saved to $directory_for_list_files"
            else
                if ($getentpath passwd|$greppath -w ^poofitee >/dev/null);then
                    directory_for_list_files="$([[ -f "$poofitee_home_dir/directory_for_list_files" ]] && cat "$poofitee_home_dir/directory_for_list_files")"
                    [[ -z "$directory_for_list_files" ]] && directory_for_list_files="$PWD"
                fi
                while printf "\nEnter the directory name containing the files that you want the firewall $ipsetpath sets to be configured from:\n";read -eri "$directory_for_list_files" directory_for_list_files;do
                     [[ -d "$directory_for_list_files" ]] && break
                     printf "\nNot a valid directory. Try again.  "
                     press_a_key
                done
                echo "$directory_for_list_files" > "$poofitee_home_dir/directory_for_list_files"
                $ipsetpath restore -file "$directory_for_list_files/ipset.sets"
#                   $ipsetpath restore blacklist -file "$directory_for_list_files/poofitee_blacklist"
#                   $ipsetpath restore blacklist_cidr  -file "$directory_for_list_files/poofitee_blacklist_cidr"
#                   $ipsetpath restore whitelist  -file "$directory_for_list_files/poofitee_whitelist"
#                   $ipsetpath restore whitelist_cidr  -file "$directory_for_list_files/poofitee_whitelist_cidr"
#                   $ipsetpath restore static_trusted  -file "$directory_for_list_files/poofitee_static_trusted"
#                   $ipsetpath restore static_trusted_cidr  -file "$directory_for_list_files/poofitee_static_trusted_cidr"
                printf "The $ipsetpath sets are now restored from $directory_for_list_files"
            fi
        fi
        if [[ "$answer" =~ d ]] && ! [[ "$notdhcp" == "notdhcp" ]];then
#             printf "dynamic IP change notify"
            sendmail_works_or_not
            if [[ -z $sendmail_works ]];then
                outemail_warnings
                press_a_key
            fi
            conf_postfix
            install_rc
            install_dynIPch
        fi
        if [[ "$answer" =~ p ]];then
            sendmail_works_or_not
            if [[ -z $sendmail_works ]];then
                outemail_warnings
                press_a_key
            fi
            conf_postfix
            install_port_knocking
        fi
        if [[ "$answer" =~ f ]];then
            printf "."
#            echo "firewalling"
#             printf "iptables, including ruleset and crontab entries will be set up next.\
#\n   Press a key...";read -n1 -r
#             echo "going off to installbuildiptables"
#             printf "\nConfiguring..."
             install_buildiptablessh
#             echo "going off to tail f lines and recvg script"
            sendmail_works_or_not
            if [[ -z $sendmail_works ]];then
                outemail_warnings
                press_a_key
            fi
            conf_postfix
            install_tail_f_lines_and_receiving_script
        fi
        [[ "$answer" =~ [fep] ]] && advise_to_verify_persistency
        end_warnings
    fi
done

#IPSet RANDOM NOTES FOLLOW FROM DIFFERENT SITES.  DO WEB SEARCH ON THEM FOR MORE DETAILS
#
#SET
#   This module adds and/or deletes entries from IP sets which can be defined by ipset(8).
#
#   --add-set setname flag[,flag...]
#          add the address(es)/port(s) of the packet to the set
#
#   --del-set setname flag[,flag...]
#          delete the address(es)/port(s) of the packet from the set
#
#          where flag(s) are src and/or dst specifications and there can be no more
#          than six of them.
#
#   --timeout value
#          when adding an entry, the timeout value to use instead of the default one
#          from the set definition
#
#   --exist
#          when  adding  an  entry  if it already exists, reset the timeout value to
#          the specified one or to the default from the set definition
#
#   Use of -j SET requires that ipset kernel support is provided, which, for standard
#   kernels, is the case since Linux 2.6.39.
#
#Well, for ipset we are out of luck. Unless we want to try the uupdate method in order to update the package to the latest version the only option remaining is to download the sources from netfilter and do the usual: 
#You need to add make modules && make modules_install to the usually set of make commands
# make && make install && make clean

#This will place ipset in /usr/local/ and we - god forbid - will have to actually do a bit of sysadmin job trying to maintain the system without any yum, rpm or apt.

#Inform the kernel about the new modules:

# depmod && depmod -A

#Time to test ipset. I assume you still into the source directory.

# cd tests && ./runtest.sh

#This will automatically run a bucket load of tests to check that the installation went ok. After it has finished running you should read this:

#All tests are passed

#... well everything went ok ;)

#iptables -A INPUT \
#         -p tcp --dport 25 \
#         -j SET --add-set banned_hosts src
#iptables -A INPUT \
#         -m set --set banned_hosts src \
#         -j DROP
#
# - install package xtables-addons-source
# - build it with module-assistant auto-install (you can shorten it to m-a a-i) xtables-addons
#
#  building the ipset module (package 'ipset_source') with module-assistant:
#
# $sudopath -i
# apt-get install ipset ipset_source
# module-assistant prepare
# module-assistant build ipset
# module-assistant install ipset
# exit
#
# ip sets can then be created and used as per documentation. See http://ubuntuforums.org/showthread.php?t=1590923 for an example.
#
